<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>共白头</title>
    <url>/posts/9a70fb8f.html</url>
    <content><![CDATA[       共白头  忽有故人心上过，回首山河已入冬。 他朝若是同淋雪，此生也算共白头。 白头若是雪可替，世间何来伤心人。 此时若有君在侧，何须淋雪作白头。   
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型与变量</title>
    <url>/posts/52c049c7.html</url>
    <content><![CDATA[数据类型
数据类型可分为基本类型、复合类型（派生类型）和自定义类型，每种类型对应固定的内存大小和操作规则。

基本类型


类型
典型大小（32&#x2F;64 位系统）
含义 &#x2F; 范围
面试考点



bool
1 字节
布尔值：true（1）&#x2F;false（0）
不可用0&#x2F; 非0代替（语法允许但不规范）；sizeof (bool) 恒为 1。


char
1 字节
字符（ASCII 码：-128127 或 0255）
区分signed char（带符号）和unsigned char（无符号）；默认符号性由编译器决定。


short
2 字节
短整数：-32768~32767
与short int等价；常用于节省内存。


int
4 字节（32&#x2F;64 位通用）
整数：-2^31~2^31-1
平台无关性（主流编译器统一 4 字节）；返回值、计数首选类型。


long
4 字节（32 位）&#x2F;8 字节（64 位）
长整数：-2^31~2^31-1（32 位）等
注意平台差异（避免依赖long的大小，优先用int64_t等固定宽度类型）。


long long
8 字节
超长整数：-2^63~2^63-1
C++11 后标准，跨平台 8 字节，适合大整数。


float
4 字节
单精度浮点：有效数字～6-7 位
精度低，适合存储大量数据；避免直接比较（误差问题）。


double
8 字节
双精度浮点：有效数字～15-17 位
默认浮点类型（如3.14是 double）；科学计算首选。


void
无大小
无类型（表示 “空”）
用于函数返回值（无返回）、指针（void*可指向任意类型）。



如何保证整数类型的跨平台一致性
使用 C++11 引入的固定宽度类型（定义于&lt;cstdint&gt;），如int32_t（32 位带符号）、uint64_t（64 位无符号），避免依赖long等平台相关类型。


sizeof对基本类型的计算结果
sizeof(char)恒为 1；sizeof(int)通常 4 字节；sizeof(void)无意义（编译报错）；sizeof(bool)为 1（无论值是 true&#x2F;false）。



复合类型（派生类型）
基于基本类型或自定义类型扩展，核心包括指针、引用、数组、结构体、联合体、枚举

指针
存储另一个变量的内存地址（32 位系统占 4 字节，64 位占 8 字节，与指向的类型无关）。

未初始化的指针为野指针（指向随机地址，操作会导致未定义行为，如崩溃）；

nullptr（C++11）：空指针常量（替代NULL，NULL本质是0，可能引发歧义）；

指针运算：仅对数组指针有意义（p++指向后一个元素，步长为指向类型的大小）。

数组名是“指向首元素的常量指针”（不可修改指向）


引用
变量的 “别名”，语法：类型&amp; 引用名 = 变量名（必须初始化，且绑定后不可更改）。




维度
指针
引用



定义
可空（nullptr）
不可空（必须绑定变量）


指向修改
可重新指向其他变量
绑定后不可更改


初始化
可延迟初始化（但风险高）
必须在定义时初始化


内存
占内存（存储地址）
不占额外内存（编译器优化）


用途
动态内存管理、多级间接访问
函数参数 &#x2F; 返回值（避免拷贝）、简化代码


结构体
用户自定义数据类型，核心作用是将多个不同类型的数据（成员）组合成一个整体—— 成员按顺序占用独立的内存空间，互不干扰，可同时访问所有成员。结构体的大小 &#x3D; 所有成员大小之和 + 内存对齐所需的填充字节。

联合体
所有成员共享同一块内存空间。这意味着联合体的大小由其最大的成员决定，且同一时间只能有效使用其中一个成员。

// 定义一个联合体类型UnionDataunion UnionData &#123;    int i;       // 4字节（假设int为4字节）    float f;     // 4字节    char c;      // 1字节&#125;;


核心特性：
成员共享内存：所有成员的起始地址相同，共用一块内存。修改其中一个值会直接覆盖其他成员存储内容。
大小由最大成员决定：联合体的总大小 &#x3D; 最大成员的大小（需满足对齐要求）
同一时间只能用一个成员：由于共享内存，同时使用多个成员会导致数据混乱






对比项
结构体（Struct）
联合体（Union）



内存分配
成员依次占用独立内存，总大小 &#x3D; 成员大小之和 + 填充
所有成员共享同一块内存，总大小 &#x3D; 最大成员大小（+ 对齐填充）


成员关系
成员是 “并存” 的（可同时访问所有成员）
成员是 “互斥” 的（同一时间只能有效使用一个成员）


用途
组合不同类型的数据（如记录一个人的姓名、年龄、身高）
节省内存（当成员不同时使用）或实现类型转换（通过不同成员访问同一块内存）


枚举
传统枚举类型：（enum E {A, B=5, C};）成员作用域全局（易冲突），可隐式转换为int。

强类型枚举：（enum class E {A, B};，C++11）作用域受限（需E::A访问），不可隐式转换（更安全，推荐使用）。

用户自定义的整数类型，用于将一组含义相关的 “命名常量” 组合在一起，本质是给整数起有意义的名字

核心特性：

本质是整数：默认类型为int
默认值规则：未手动赋值时，第一个常量为0，后续依次+1；若中间某个常量手动赋值，后续常量在其基础上+1。






对比项
枚举（Enum）
#define 宏



类型检查
有类型（枚举类型），编译器会检查赋值合法性（C++ 更严格）
无类型，仅文本替换，不做任何检查


作用域
C++ 强类型枚举有独立作用域（enum class），避免冲突
全局作用域，从定义处到文件结束，易冲突


调试友好性
调试时显示常量名（如MON），可读性高
调试时显示替换后的数值（如0），难理解


自动赋值
支持自动递增赋值（无需手动写1,2,3）
需手动为每个常量赋值，繁琐且易出错


取值范围约束
枚举变量理论上只能取枚举常量的值（增强代码健壮性）
无约束，变量可被赋任意值


自定义类型
class（类）、struct（结构体）、enum（枚举）等定义的类型，核心是数据的封装与行为。


变量变量定义与初始化
定义：编译器分配内存
初始化：定义时赋初值（避免未初始化的“垃圾值”）
常见初始化方式：（列表初始化的优势——防止类型窄化）



int a = 10;       // 拷贝初始化int b(20);        // 直接初始化（适合构造函数）int c&#123;30&#125;;        // 列表初始化（C++11，禁止窄化转换，如int&#123;3.14&#125;编译报错）int d = &#123;40&#125;;     // 拷贝列表初始化

存储类别（关键字修饰）
决定变量的生命周期和作用域（auto、static、extern、register、mutable）

auto（类型推导，C++11）
编译器根据初始化值自动推导变量类型
auto不能用于函数参数（除非是模板）、数组类型推导。
推导引用时，需显式添加&amp;（如auto &amp;），否则推导为值类型。

static（静态存储）
局部静态变量：在函数内定义，生命周期为程序全程（首次调用初始化，后续调用不重新初始化），作用域仅限函数内。
全局静态变量：文件作用域（仅当前.cpp可见），避免文件命名冲突（替代全局变量，减少耦合）。
类静态成员：属于类而非对象，所有对象共享，需在类外初始化（除const static整数）。

extern（外部声明）
声明变量&#x2F;函数在其他文件中定义，用于跨文件共享，避免重复定义。

extern仅声明，不分配内存；若带初始化则变为定义，可能导致重复定义错误。


register（存储器存储，C++17后弃用）
提示编译器将变量存储在寄存器（速度更快），但现代编译器优化已足够，无需手动指定

mutable（易变的）
仅用于类的非静态成员变量，允许const成员函数修改它（突破const限制）

volatile（禁止编译器优化）
告知编译器：该变量的值可能被 “当前代码流之外的因素” 意外修改（如硬件寄存器、中断服务程序、多线程共享变量等），因此禁止对其进行 “缓存到寄存器”“指令重排” 等优化，确保每次访问都直接从内存读取。

问答
局部变量屏蔽全局变量时，如何访问被屏蔽的全局变量？
用::（全局作用域解析符），


全局变量和局部static变量的初始化顺序？
全局变量（包括命名空间内）在main前初始化，局部static变量在首次进入函数时初始化（C++11 后线程安全）。两者销毁顺序与初始化顺序相反。


未初始化的局部变量和全局变量有何区别？
局部非static变量（自动存储期）未初始化时是 “垃圾值”（内存残留数据）；全局变量和static变量会被零初始化（数值类型为 0，指针为nullptr等）。



常量
常量是不可修改的变量，核心区分const（只读）和constexpr（编译期常量）

const
修饰变量：值初始化后不可修改，作用域与变量一致。
修饰指针：需区分“指针常量”和“常量指针”：

const int* p;  // 常量指针：指向的内容不可改（*p不可改），p可改指向int* const p;  // 指针常量：p的指向不可改，*p可改const int* const p;  // 指向常量的指针常量：均不可改

constexpr（C++11，编译器常量）
要求表达式在编译器可计算，比const更严格（const可运行期初始化）。
用途：定义数组大小、模板参数等，依赖编译期常量的场景。

类型转换
分隐式转换（编译器自动）和显式转换（强制转换）

隐式转换（自动转换）
”安全优先“原则，优先“小范围”-&gt;“大范围”（类型提升），避免溢出；若无法安全转换，则可能导致精度丢失，但编译器通常不报错。
bool → char&#x2F;signed char&#x2F;unsigned char → short&#x2F;unsigned short → int&#x2F;unsigned int → long&#x2F;unsigned long → long long&#x2F;unsigned long long → float → double → long double
explicit关键字可以禁止隐式类型转换。

显式转换（四种强制转换）[[强制类型转换]]



转换方式
用途
风险



static_cast
基本类型转换（int→double）、父类 &#x2F; 子类指针转换（无动态检查）
子类→父类安全，父类→子类可能越界


dynamic_cast
多态类型转换（仅用于含虚函数的类），运行期检查有效性
转换失败返回nullptr（指针）或抛出异常（引用），开销略大


const_cast
移除const属性（仅用于指针 &#x2F; 引用）
修改原const变量会导致未定义行为


reinterpret_cast
底层二进制重解释（如int*→char*）
高度危险，依赖平台，几乎不保证可移植性



何时用dynamic_cast？
多态场景下，需要将父类指针安全转换为子类指针（需父类有虚函数，运行期检查转换合法性）


为什么避免reinterpret_cast？
它直接操作二进制，忽略类型安全。



]]></content>
      <categories>
        <category>C++</category>
        <category>1. 基础语法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>变量</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符与表达式</title>
    <url>/posts/dc2fae3c.html</url>
    <content><![CDATA[
逻辑运算符的短路求值：

&amp;&amp;：左操作数为false时，右操作数不执行（直接返回 false）。
||：左操作数为true时，右操作数不执行（直接返回 true）。


逗号运算符（,）：

按顺序执行多个表达式，返回最后一个表达式的值，优先级最低。


右结合运算符



赋值运算符&#x3D;
条件运算符?&#x3D;
单目运算符（包括前缀 ++、前缀 --、*、&amp;、!、~、+（正）、-（负）、sizeof 等）

]]></content>
      <categories>
        <category>C++</category>
        <category>1. 基础语法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>运算符</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>函数基础</title>
    <url>/posts/1111c3f5.html</url>
    <content><![CDATA[
函数声明与定义：原型声明需匹配参数类型&#x2F;个数（返回类型不影响）
参数传递：
按值传递：形参是实参拷贝（修改不影响实参）
按引用传递：int&amp;（形参是实参别名，避免拷贝，修改影响实参）
按指针传递：int*（通过地址间接修改，可传递nullptr）


函数重载：同一作用域，函数名相同，参数列表（类型&#x2F;个数&#x2F;顺序）不同（返回类型不参与重载）
重载协议：编译器根据实参类型匹配最佳函数（隐式转换可能影响匹配）


内联函数：inline（建议编译器嵌入调用处，减少调用开销，适合短函数；不能有循环&#x2F;递归）
默认参数：靠右原则（默认参数只能从右往左开始省略，不能跳过右侧参数省略左侧参数）

函数的基本结构与声明定义声明与定义的区别
声明：仅告知编译器函数的 “存在及原型”（返回类型、函数名、参数列表），不包含实现，用于 “提前声明”（解决函数调用在前、定义在后的问题）。（参数名在声明时是可选的）
定义：包含函数声明 + 函数体（具体实现），编译器会为其分配内存（生成指令）。规则：一个函数可以声明多次，但只能定义一次（否则链接报错 “重复定义”）。

参数传递值传递
将实参的副本传入函数，函数内修改形参不影响实参。
优点：安全，简单
缺点：会产生拷贝（对大对象开销大）

引用传递
将实参的“别名”传入函数，函数内修改形参直接影响实参（无拷贝，效率高）
优点：无拷贝（适合大对象）、可修改实参、语法简洁
引用必须绑定实参，不能传字面量，且绑定后不可更改指向。

指针传递
将实参的地址传入函数，通过解引用指针修改实参（本质是值传递地址，需手动解引用）
优点：可修改实参，允许传递nullptr
缺点：需显式解引用（易漏写*导致逻辑错误），可能出现野指针




维度
值传递
引用传递
指针传递



内存开销
拷贝实参（大对象开销大）
无拷贝（仅别名）
拷贝地址（固定大小，4&#x2F;8 字节）


实参修改
不可修改
可修改
可修改（需解引用）


空值传递
不支持
不支持（引用必须绑定对象）
支持（可传nullptr）


适用场景
小对象、无需修改实参
大对象、需修改实参
需要 “空值” 语义的场景


返回值返回值类型
基本类型（int、double等）：直接返回值（拷贝）。
自定义类型（类 &#x2F; 结构体）：返回对象副本（可被编译器优化，如返回值优化 RVO）。
引用（&amp;）：返回变量的别名（无拷贝，效率高），但禁止返回局部变量的引用（局部变量生命周期随函数结束，引用变为 “悬垂引用”，访问即未定义行为）。

特殊返回值：void
void表示 “无返回值”，函数体中可省略return，或用return;提前结束。
不能定义void类型的变量（void x; 报错），但可定义void*指针（指向任意类型，需强转后使用）。

返回值优化（RVO&#x2F;NRVO）
编译器对 “返回大型对象” 的优化：避免函数返回时的临时对象拷贝（直接在调用处构造对象）。
RVO 是编译器优化，不依赖代码修改，可显著提升大型对象返回的效率。

函数重载
同一作用域中定义同名函数，只要参数列表不同（重载），用于 “同一功能的不同参数版本”。

重载的条件
同一作用域（如同一命名空间、同一类）

函数名相同

参数列表不同：参数类型、个数、顺序不同（至少一项不同）

函数参数为引用&#x2F;指针时，const修饰可形成重载

类的成员函数中，const修饰this指针可形成重载


重载决议
编译器通过“实参类型与形参类型的匹配度” 选择最佳重载函数，匹配度从高到低：
精确匹配（类型完全一致）；
提升转换（如char→int、float→double）；
标准转换（如int→double、指针→void*）；
用户定义转换（如类的构造函数、运算符重载）。



内联函数
用inline修饰的函数，编译器会尝试将函数体”嵌入“调用处（而非生成函数调用指令），减少调用开销（如栈帧创建 &#x2F; 销毁）。

核心特性
建议性：inline是对编译器的 “建议”，而非强制（复杂函数，如含循环、递归，编译器会忽略inline）。
定义即声明：内联函数需在调用前定义（不能仅声明），通常放在头文件中（方便多个编译单元包含）。
避免重复定义：内联函数允许在多个编译单元中定义，但必须完全相同（否则链接报错）。

与宏的区别


维度
内联函数（inline）
宏（#define）



类型检查
有（编译期检查参数类型）
无（文本替换，易出类型错误）


调试
支持（可打断点）
不支持（替换后无宏信息）


复杂度
支持复杂逻辑（循环、分支）
适合简单表达式（复杂易出错）


作用域
受作用域限制
全局替换（无作用域）


]]></content>
      <categories>
        <category>C++</category>
        <category>2. 函数与指针</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>函数</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>程序结构与预处理</title>
    <url>/posts/43ae7cb1.html</url>
    <content><![CDATA[
程序入口：main函数（返回值int，return 0表示正常退出）
预处理指令：
#include：头文件包含（&lt;&gt;系统文件；&quot;&quot;自定义头文件，搜索路径有所区别）
#define：宏定义（无类型检查，带参数宏的陷阱）
条件编译：#ifdef（若已定义则编译）&#x2F;#ifndef（若未定义则编译）&#x2F;endif（用于跨平台代码、防止头文件重复包含）
#pragma once：替代#ifndef防止头文件重复包含（非标准但广泛支持）



程序结构
执行流程：预处理-&gt;编译-&gt;汇编-&gt;链接-&gt;执行。

预处理
预处理是编译的第一个阶段，由预处理器处理所有以#开头的指令，生成”预处理后的源代码“（消除注释、展开宏、处理条件编译等）。

#include
#include &lt;header&gt;：优先搜索系统标准头文件目录（如/usr/include），用于引入标准库（如&lt;iostream&gt;、&lt;vector&gt;）。
#include &quot;header&quot;：优先搜索当前源文件所在目录，再搜索系统目录，用于引入自定义头文件（如&quot;myfunc.h&quot;）。

宏定义
在预处理阶段执行

#define 宏名 替换文本


常量宏定义：文本替换

函数宏定义：没有错误处理，并非真正的函数调用，存在带参数宏陷阱

#undef：用于取消宏定义

与函数的区别：宏无类型检查、无调用开销（替换展开）、可操作类型（如#define SWAP(T,a,b) {T t=a;a=b;b=t;}）；函数有类型检查、有调用栈开销。

与const的区别：const变量有类型、作用域、可调试；宏无类型、全局替换、不可调试。


宏定义的优缺点
优点：
提升可读性：为常量或复杂表达式赋予有意义名称；
便于修改：修改宏定义即可统一更新，无需逐个替换；
增强可移植性：支持条件编译，适配不同平台 &#x2F; 编译器。


缺点：
无类型检查：仅文本替换，不校验参数类型，易藏错误；
可能代码膨胀：大量使用函数宏会导致目标代码体积增大；
作用域风险：作用域从定义到文件结束（或#undef），易引发命名冲突。



条件编译
在预处理阶段进行

通过#if、#ifdef、#ifndef等指令，根据条件决定部分代码是否进入编译阶段，常用于 “跨平台适配”“调试 &#x2F; 发布版本区分”“头文件防重复包含”。

#ifdef MACRO：若MACRO已定义，则编译后续代码。

#ifndef MACRO：若MACRO未定义，则编译后续代码（常用）。

#if 表达式：表达式为真则编译（支持defined(MACRO)判断宏是否定义）。

#else&#x2F;#elif：分支控制。

#endif：结束条件编译块（必须配对）。

#error：预处理阶段报错，终止编译。（可以用于检查版本和系统）

#pragma pack(n)：设置结构体对齐字节数（面试结合结构体对齐考），如#pragma pack(1)强制 1 字节对齐。



带参数宏陷阱运算符优先级错乱
宏替换时会直接插入代码，不自动添加括号，若替换体或参数中包含运算符（如+、*、&amp;&amp;），会与上下文的运算符优先级冲突，导致逻辑偏离预期。

#define MUL(a, b) a * b


解决办法：给宏的每个参数和整个替换体都加上括号，强制改变优先级。

参数副作用（多次计算）
宏的参数若包含 “副作用表达式”（如i++、++j、x+=1，即执行后会修改自身值的表达式），由于宏替换会让参数被多次展开计算，导致副作用被放大。

// 宏定义：取两数最大值（无参数隔离）#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))int main() &#123;    int i = 3, j = 5;    // 预期：比较i=3和j=5，返回5，i只自增1次    // 实际替换：((i++) &gt; (j++) ? (i++) : (j++))    // 执行过程：    // 1. 先计算条件：3 &gt; 5？假（此时i=4，j=6）    // 2. 执行else分支：j++ → 返回6（此时j=7）    // 最终i=4，j=7，返回值6（而非预期的5）    int res = MAX(i++, j++);     printf(&quot;res=%d, i=%d, j=%d\n&quot;, res, i, j); // 输出 res=6, i=4, j=7    return 0;&#125;


对比：
函数：参数先计算一次（i++和j++各执行 1 次），再传入函数，无副作用放大；
宏：参数在替换体中出现几次，就计算几次（上例中i++出现 2 次，j++出现 2 次）。


解决办法：


避免将带副作用的表达式（i++、++j等）作为宏参数；
若必须使用，先将参数值存入临时变量，再传入宏

重复计算（性能 + 逻辑风险）
即使参数无副作用，若参数是复杂表达式（如函数调用、耗时计算），宏替换会导致表达式被多次执行，既浪费性能，也可能引发逻辑问题（若表达式有状态依赖，如获取系统时间）。
解决办法：


避免将带副作用的表达式（i++、++j等）作为宏参数；
若必须使用，先将参数值存入临时变量，再传入宏

宏缺少分号导致逻辑断裂
开发者习惯在函数调用后加;，若宏的替换体是多行代码（用\换行），且末尾未加{}包裹，会导致分号被插入错误位置，破坏语法逻辑。（也就是如果多加了;，会提前结束代码逻辑，造成if-else等逻辑错误
解决办法：使用do{...}while(0)包裹多行宏体

宏与变量 &#x2F; 函数同名（命名冲突）
宏的作用域是 “从定义处到文件结束”（除非用#undef取消），且预处理时会无差别替换所有匹配的标识符—— 若宏名与变量、函数名同名，会导致代码被错误替换，引发语法或逻辑错误。
解决办法


宏名采用 “全大写 + 下划线” 命名规范（如MAX_VALUE），与变量 &#x2F; 函数名区分；
用#undef 宏名及时取消不需要的宏，缩小作用域；
避免使用库函数名、关键字作为宏名。

]]></content>
      <categories>
        <category>C++</category>
        <category>1. 基础语法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>程序结构</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>友元与运算符重载</title>
    <url>/posts/6ea8b1ca.html</url>
    <content><![CDATA[
友元：
友元函数：friend void print(A a);（非成员函数，可访问私有成员，破坏封装）
友元类：friend class B;（类 B 可访问当前类私有成员）


运算符重载：
可重载：+，-，*，&#x2F;，&#x3D;，=&#x3D;，!&#x3D;，&lt;&lt;，&gt;&gt;等（&lt;&lt;，&gt;&gt;需作为非成员函数）
不可重载：.&#x2F;.*&#x2F;::&#x2F;? :&#x2F;sizeof
赋值运算符&#x3D;：只能作为成员函数（编译器默认生成，深拷贝需重写）

友元函数：打破封装
友元函数是被类声明为 “朋友” 的外部函数，可以直接访问类的私有（private）和保护（protected）成员

核心特性
声明方式：在类内部用friend关键字声明，函数定义可在类内或类外（通常在类外，保持类定义简洁）。
非成员函数：友元函数不是类的成员函数，没有this指针，访问类成员时需显式传递对象参数。

友元的种类
友元函数：单个函数作为友元
友元类：整个类作为友元，其所有成员函数可访问当前类的私有成员
友元成员函数：类的某个成员函数作为友元

关键特性
不可传递性
单向性
声明位置无关

运算符重载：自定义类型重载规则
语法：返回类型 operator运算符(参数列表) { ... }


不能重载的六个运算符：.（成员访问）、.*（成员指针访问）、::（作用域解析）、sizeof（大小计算）、?:（三目运算符）、typeid（类型信息）。
不能改变运算符的优先级和结合性
不能改变运算符的操作数个数
必须包含至少一个自定义类型的操作数

重载形式成员函数重载
隐含左侧操作数为this指针（当前对象），参数列表只需传入右侧操作数
适用场景：左侧操作数是当前类对象

友元函数重载
无this指针，需显式传入所有操作数（左侧和右侧）
适用场景：左侧操作数不是当前类对象

]]></content>
      <categories>
        <category>C++</category>
        <category>4. 面向对象编程OOP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>友元</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/posts/3a517f26.html</url>
    <content><![CDATA[
访问控制：public（接口）、private（实现）、protected（继承）
const成员：
const成员变量：必须在初始化列表初始化
const成员函数：不能修改成员变量，可被const对象调用


static成员：
静态成员变量：类共享，需类外定义
静态成员函数：无this指针，只能访问静态成员，可通过类名直接调用



基本概念
类：是抽象的数据类型模板，定义了对象的属性（数据成员）和行为（成员函数），描述了一类对象的共同特征。
对象：是类的具体实例，占用实际内存，拥有类定义的属性和行为。

核心特性：封装
封装是面向对象的三大特性之一，核心是”隐藏实现细节，暴露公共接口“，通过访问空字符实现




访问控制符
可访问范围
作用



public
类内、类外、派生类
暴露接口（如成员函数），供外部调用


private
仅类内和友元
隐藏数据成员和内部实现（核心封装）


protected
类内、友元、派生类（不允许类外访问）
为继承预留（派生类可访问父类受保护成员）



封装的意义：
数据安全：防止外部随意修改内部数据
代码维护性：内部实现修改时，只要接口不变，外部调用者无需修改
信息隐藏：只暴露必要接口，降低使用复杂度



构造函数：对象的初始化
能重载（参数列表不同即可），不能为虚函数（对象未构造，无法动态绑定）。
核心特点：
函数名与类名相同，无返回值
可重载
对象创建时自动调用



常见类型默认构造函数
无参数，或所有参数都有默认值的构造函数
若用户未定义任何构造函数，编译器会自动生成默认构造函数（无任何操作）
若用户定义了其他构造函数，编译器不再生成默认构造函数（需手动定义，否则报错）

带参构造函数
用于通过参数初始化对象（解决默认构造灵活性不足的问题）

拷贝构造函数
用于用已有对象初始化新对象（参数必须为”同类对象的const引用“）
调用时机：
对象初始化
函数参数按值传递
函数返回值为对象（非引用）


默认拷贝构造：若用户未定义，编译器会生成默认拷贝构造，执行浅拷贝（逐个复制成员变量）
安全场景：数据成员为基本类型，浅拷贝无问题
危险场景：数据成员包含指针，浅拷贝会导致两个对象的指针指向同一块内存，析构时双重释放（崩溃），需手动实现深拷贝。


浅拷贝和深拷贝：
浅拷贝仅复制对象的 “表层数据”（如基本类型成员），对于指针 &#x2F; 引用成员，仅复制其指向的地址（不复制底层数据）。可能导致重复释放内存。
深拷贝不仅复制表层数据，对于指针 &#x2F; 引用成员，会重新分配一块新内存，并复制底层数据到新内存，新指针指向新内存。（深拷贝赋值运算符需处理自我赋值，释放旧资源）



移动构造函数
移动构造函数通过接管原对象的资源

新对象直接 “窃取” 原对象的动态资源（如堆内存指针）；

原对象被 “掏空”（通常将其资源指针置空），避免析构时重复释放资源；

整个过程无需复制资源，仅涉及指针的转移，效率接近 “浅拷贝”，但比浅拷贝安全（不会共享资源）。

基本实现：


class 类名 &#123;public:    // 移动构造函数：参数为右值引用（T&amp;&amp;），通常标记为noexcept    类名(类名&amp;&amp; 源对象) noexcept &#123;        // 转移源对象的资源到当前对象        当前对象的资源指针 = 源对象的资源指针;        // 掏空源对象（避免源对象析构时释放资源）        源对象的资源指针 = nullptr;     &#125;&#125;;


右值引用（T&amp;&amp;）：专门用于绑定 “临时对象” 或 “即将销毁的对象”（右值），确保移动构造仅在源对象 “不再被使用” 时调用；
noexcept：告诉编译器该函数不会抛出异常，这对 STL 容器（如 vector）的性能优化至关重要（避免容器在移动时额外分配内存用于异常处理）。

初始化列表
构造函数中，推荐用初始化列表初始化成员，而非函数体赋值
必须用初始化列表的场景：
常量成员（const）
引用成员（&amp;）
没有默认构造函数的类成员



析构函数：对象的清理
不能重载（无参数，无法重载），能为虚函数（且基类建议设为虚函数，避免泄漏）。
若类作为基类，需声明为virtual，否则删除派生类对象时内存泄漏。
核心特点：
函数名：~类名，无参数，无返回值，不能重载（一个类只能有一个析构函数）
调用时机：对象生命周期结束时（如局部对象出作用域、delete动态对象时）
默认析构：若用户未定义，编译器生成默认析构（无任何操作）


必须手动定义析构函数的场景：当类中包含动态分配的资源（如new的内存），默认析构不会释放堆内存导致内存泄漏，必须手动定义。

this指针（隐藏的当前对象指针）
在非静态成员函数中，编译器会隐式传递一个this指针，指向当前调用函数的对象，用于区分成员变量和参数。
核心特性：
类型：类名* const（指针本身不可修改，指向当前对象）
只能在非静态成员函数中使用（静态成员函数无this指针）


用途：
区分成员变量和参数（如this-&gt;name = name）；
返回当前对象的引用（支持链式调用）



静态成员（属于类）
静态成员（静态成员变量 &#x2F; 函数）属于整个类，所有对象共享，不依赖具体对象存在。

静态成员变量
声明：类内用static修饰，必须在类外初始化（类内仅声明）
访问：通过类名::变量名或对象.变量名（推荐前者，更清晰）
特点：不占用对象内存（存储在全局数据区），生命周期与程序一致。

静态成员函数
声明：类内用static修饰，无this指针
访问：通过类名::函数名调用（无需创建对象）
限制：只能访问静态成员（不能访问非静态成员，因无this指针）

类的大小计算
类的大小仅取决于非静态数据成员，循 “内存对齐” 原则，与成员函数、静态成员无关（存储在代码区 &#x2F; 全局区）。
规则：
空类（无任何成员）的大小为1字节（编译器为了区分不同对象的地址，分配 1 字节占位）
非静态成员按“内存对齐”排列（对齐系数通常为成员类型大小，或编译器默认值如 4&#x2F;8 字节）
类的总大小时最大对齐系数的整数倍
成员函数、静态成员不占用类的大小。



问答
构造函数和析构函数的调用顺序？
创建对象时，构造函数按 “对象创建顺序” 调用（如局部对象先定义先构造）；销毁时，析构函数按 “构造的相反顺序” 调用（后构造的先析构）。


拷贝构造函数的参数为什么必须是引用？
若参数是值传递，会触发 “用实参初始化形参” 的拷贝构造调用，导致无限递归（形参初始化又需要拷贝构造，直到栈溢出）。用引用可避免此问题。



]]></content>
      <categories>
        <category>C++</category>
        <category>4. 面向对象编程OOP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>指针与引用</title>
    <url>/posts/eed757dd.html</url>
    <content><![CDATA[
指针：

野指针：未初始化&#x2F;已释放的指针（内存访问错误）
空指针：nullptr
函数指针：int (*func_ptr)(int, int)（指向函数的指针，可作为参数&#x2F;返回值，实现回调）
指针数组和数组指针：
[]优先级高于*，()会提高优先级
指针数组：类型* 数组名[数组长度];（[] 优先级高于 *，因此先构成数组，再说明元素是指针）
数组指针：类型 (*指针名)[数组长度];（() 提升 * 的优先级，先说明是指针，再指向一个数组）




引用：

必须初始化，不可改指向，无空引用，sizeof(ref)&#x3D;sizeof(原变量)
与指针的区别：语法（无*&#x2F;&amp;操作）、语义（绑定实体，非对象）
应用：函数返回值（返回全局 &#x2F; 静态变量引用，避免拷贝）


两者访问效率基本相同

需空值、动态指向、多级访问 → 用指针；

需简洁语法、确保有效、避免误操作 → 用引用。


本质
指针：本质是存储内存地址的变量
引用：本质是变量的别名（编译器层面通常用指针实现，但语法上无独立内存）

对比


特性
指针（Pointer）
引用（Reference）



初始化
可延迟初始化（如 int* p;），但未初始化时是野指针
必须在定义时初始化（如 int&amp; r = a;），且必须绑定已存在的变量


指向可修改性
可重新指向其他变量（p = &amp;b; 合法）
绑定后不可更改指向（r = b; 是修改 a 的值，而非更改绑定）


空值支持
可指向 nullptr（int* p = nullptr;）
无 “空引用”（必须绑定有效变量，不存在 nullptr 引用）


解引用
需显式用 *（*p = 10;）
无需解引用（r = 10; 直接修改绑定变量）


算术运算
支持（步长为指向类型大小，如 int* p; p++ 移动 4 字节）
不支持（引用不是对象，无地址，无法运算）


多级嵌套
支持多级指针（int**p 指向指针的指针）
不支持多级引用（int&amp;&amp; r 是右值引用，非 “引用的引用”）


补充作为函数参数：传递机制与影响
指针传参：本质是 “值传递地址”，函数内修改指针本身（如 p = &amp;b;）不影响实参；但修改指针指向的内容（*p = 10;）会影响实参。
引用传递：传递的是 “变量别名”，函数内修改引用（r = 20;）直接修改实参；且无法修改引用的指向（语法禁止）。

作为返回值：悬垂问题
两者都禁止返回局部变量（生命周期随函数结束）
返回局部变量的指针：得到野指针（指向已释放内存）
返回局部变量的引用：得到悬垂引用（绑定已销毁变量）

const修饰
const指针：分 “指针指向常量” 和 “指针本身是常量”；左定值（常量指针），右定向（指针常量）。
const引用：const T&amp;是“指向常量的引用”，不可通过引用修改绑定变量（可以修改，只是不能通过引用修改），但可绑定临时对象（如字面量、表达式结果）

]]></content>
      <categories>
        <category>C++</category>
        <category>2. 函数与指针</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>数组基础</title>
    <url>/posts/c24002d9.html</url>
    <content><![CDATA[
数组名：首元素地址，但是sizeof(arr)是数组总大小
多维数组：本质是数组的数组，mat[i][j]==*(*(mat+i)+j)
数组传参：会退化为指针

数组名与指针数组名不退化的3种场景
sizeof(数组名)：计算整个数组的字节大小（而非指针大小）
&amp;数组名：获取指向”整个数组“的指针
数组名作为[[decltype]]的参数：decltype(arr)推导为数组类型，而非指针。

数组作为函数参数
数组作为函数参数时，会退化为指针（丢失长度信息），需额外传递长度参数

一维数组传参的3种写法// 写法1：数组形式（实际退化为指针）void func1(int arr[5]) &#123; ... &#125;  // 5无意义，可写任意值// 写法2：省略长度的数组形式void func2(int arr[]) &#123; ... &#125;   // 等价于int* arr// 写法3：显式指针形式void func3(int* arr) &#123; ... &#125;    // 最直观，推荐

二维数组传参（必须指定第二维长度）
二维数组退化后时”指向一维数组的指针“，因此必须指定第二维长度

// 正确写法：第二维长度3不可省略void func(int mat[][3], int rows) &#123; ... &#125;// 错误写法：第二维长度省略（编译器无法确定步长）void func(int mat[][], int rows, int cols) &#123; ... &#125;  // 编译报错


函数内无法通过sizeof获取数组长度，必须显示传递长度。

字符串与字符数组
C风格字符串是以&#39;\0&#39;（空字符）结尾的字符数组，会自动填充。
字符串长度：strlen(str)计算&#39;\0&#39;前的字符数（不包含&#39;\0&#39;），而sizeof(str)计算整个数组大小（包含&#39;\0&#39;和未使用空间）。

char str[] = &quot;hello&quot;;cout &lt;&lt; strlen(str);  // 5（&#x27;h&#x27;到&#x27;o&#x27;）cout &lt;&lt; sizeof(str);  // 6（包含&#x27;\0&#x27;）

数组和动态容器


维度
数组（Array）
vector（动态数组）



大小
编译期固定，不可修改
运行时动态调整（push_back自动扩容）


内存管理
手动管理（栈 &#x2F; 全局区），无自动释放
自动管理（堆内存），析构时释放


长度获取
需手动计算（sizeof(arr)/sizeof(arr[0])）
内置size()方法


传参
退化为指针，需额外传长度
传引用即可（vector&lt;int&gt;&amp;），保留长度


安全性
无越界检查，风险高
可通过at()做越界检查（抛异常）


]]></content>
      <categories>
        <category>C++</category>
        <category>3. 数组与字符串</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串基础</title>
    <url>/posts/5f08cd61.html</url>
    <content><![CDATA[
C 风格字符串：char str[] = &quot;hello&quot;（以&#39;\0&#39;结尾），函数：
strlen：长度（不含&#39;\0&#39;）
strcpy：拷贝（无长度检查，可能溢出） vs strncpy
strcmp：比较字典序（返回 0 表示相等）


C++ std::string：
成员函数：size()&#x2F;length()、c_str()（转为 C 风格字符串）、substr(pos, len)
操作：+拼接、[]访问（无越界检查）、at()（越界抛异常）
底层：动态字符数组，小字符串优化（SSO，短字符串存储在栈上）



C风格字符串：以&#39;\0&#39;结尾的字符数组初始化
char类型数组，必须以&#39;\0&#39;结尾（表示字符串结束）

// 方式1：字符串字面量（自动添加&#x27;\0&#x27;）char str1[] = &quot;hello&quot;;  // 长度6：&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;&#125;// 方式2：显式初始化（需手动添加&#x27;\0&#x27;）char str2[] = &#123;&#x27;h&#x27;,&#x27;i&#x27;,&#x27;\0&#x27;&#125;;  // 正确：以&#x27;\0&#x27;结尾，长度3// 方式3：指定长度（未初始化部分自动填&#x27;\0&#x27;）char str3[10] = &quot;hi&quot;;  // 前2位为&#x27;h&#x27;,&#x27;i&#x27;，剩余7位（含第3位）为&#x27;\0&#x27;

关键操作函数（cstring库）


函数
功能
陷阱与注意事项



strlen(s)
计算&#39;\0&#39;前的字符数
若字符串无&#39;\0&#39;，会越界扫描（未定义行为）


strcpy(dst, src)
复制src到dst
dst容量不足会溢出，需确保dst足够大


strcat(dst, src)
拼接src到dst末尾
需dst已含&#39;\0&#39;，且总长度不超dst容量


strcmp(s1, s2)
比较字符串（字典序）
返回 0 表示相等，正数表示s1 &gt; s2


C++ std::string：动态管理的字符串
动态大小：无需预先指定长度，push_back、append等操作自动扩容。
安全操作：内置边界检查（at()方法越界抛异常）
便捷接口：重载+（拼接）、=&#x3D;（比较）等运算符，提供find、substr等实用方法。
内存自动管理：析构时自动释放内存，无需手动处理&#39;\0&#39;

常用方法


方法
功能
注意事项



size()&#x2F;length()
返回字符数（不含&#39;\0&#39;）
两者功能完全一致（历史原因并存）


c_str()&#x2F;data()
返回指向 C 风格字符串的指针（以&#39;\0&#39;结尾）
指针有效期与string一致（修改string后可能失效）


substr(pos, len)
提取子串（从pos开始，长度len）
pos越界抛异常，len超出范围则取到末尾


find(sub, pos)
从pos开始查找sub，返回起始索引
未找到返回string::npos（需用string::npos判断，而非 - 1）


reserve(n)
预分配至少n个字符的内存
减少扩容次数（提升效率），不改变size


resize(n, c)
调整size为n，不足补c
改变实际字符数，可能截断或填充


深入特性内存管理
std::string通常采用 “动态数组 + 小字符串优化（SSO）”：
短字符串（如长度≤15）：直接存储在string对象内部（栈内存），无需堆分配。
长字符串：存储在堆内存，string对象仅保存指针和长度。



迭代器失效
执行push_back、append等可能导致扩容的操作时，底层内存可能重分配，原有迭代器、指针、引用失效。

C风格字符串转换
std::string → C 风格：用c_str()（返回const char*，需确保string未被修改）。
C 风格 → std::string：直接赋值（string s = c_str; 自动处理&#39;\0&#39;）。

字符串拷贝C语言拷贝函数strcpy（最基础，不安全，补&#39;\0&#39;）
原型：char* strcpy(char* dest, const char* src);
核心逻辑：从src逐字节拷贝到dest，直到遇到&#39;\0&#39;（会将&#39;\0&#39;一并拷贝）。
关键特点：
无长度检查，若dest缓冲区小于src长度，会导致缓冲区溢出。
返回dest指针，支持链式操作（如strcpy(dest, strcpy(tmp, src))）。



strncpy（带长度限制，仍需注意终止符，不补&#39;\0&#39;）
原型：char* strncpy(char* dest, const char* src, size_t n);
核心逻辑：最多拷贝n个字节，若src长度≤n，拷贝完src后补&#39;\0&#39;；若src长度 &gt; n，只拷贝前n个字节，不补&#39;\0&#39;。
关键特点：
有长度限制，降低溢出风险，但需手动确保dest以&#39;\0&#39;结尾。
适合已知源 &#x2F; 目标缓冲区大小的场景。



strlcpy（安全首选，非C标准，补&#39;\0&#39;）
原型：size_t strlcpy(char* dest, const char* src, size_t dest_size);
核心逻辑：以dest_size为目标缓冲区总大小，最多拷贝dest_size-1个字节，强制补&#39;\0&#39;，返回src的总长度（不含&#39;\0&#39;）。
关键特点：
完全避免溢出（自动留 1 字节存&#39;\0&#39;），是最安全的 C 语言拷贝函数。
非 ISO C 标准，但广泛用于 Linux、BSD 等系统。



memcpy（按字节拷贝，不依赖&#39;\0&#39;）
原型：void* memcpy(void* dest, const void* src, size_t n);
核心逻辑：不管内容，直接拷贝n个字节，不关心&#39;\0&#39;（需手动控制长度和终止符）。
关键区别：
适用于任意数据（字符串、数组、结构体），而非仅字符串。
字符串拷贝时需手动计算src长度（含&#39;\0&#39;），避免遗漏终止符。



C++字符串拷贝
拷贝构造：string dest(src);
赋值运算符：string dest = src;
assign方法：dest.assign(src, 0, n);（从src第 0 位开始拷贝n个字符）

]]></content>
      <categories>
        <category>C++</category>
        <category>3. 数组与字符串</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>STL基础</title>
    <url>/posts/6e08d78f.html</url>
    <content><![CDATA[
容器底层实现
vector：动态数组（连续内存），扩容机制（通常翻倍，旧元素拷贝到新内存），迭代器失效（插入 &#x2F; 删除可能导致）
list：双向链表（非连续），插入 &#x2F; 删除不失效迭代器，无随机访问
deque：分段连续内存（双端队列），头尾插入 &#x2F; 删除高效
map&#x2F;set：红黑树（平衡二叉搜索树），有序，插入 &#x2F; 查找 O (logn)
unordered_map&#x2F;unordered_set：哈希表，无序，插入 &#x2F; 查找 O (1)（平均），哈希冲突处理
stack&#x2F;queue：适配器（默认基于deque）


迭代器
分类：输入、输出、前向、双向、随机访问（vector是随机访问，list是双向）
失效场景：vector插入（可能扩容）、删除（当前及之后迭代器失效）；map删除（仅当前迭代器失效）


算法：
sort：基于快速排序（随机访问迭代器，vector可排序，list不可）
find：线性查找；lower_bound&#x2F;upper_bound：二分查找（有序范围）



STL的核心组件
容器（Containers）：封装数据结构的类模板（如 vector、map），用于存储数据。
算法（Algorithms）：实现通用操作的函数模板（如 sort、find），通过迭代器操作容器元素。
迭代器（Iterators）：类似指针的对象，提供对容器元素的访问接口，是容器与算法的桥梁。
仿函数（Functors）：重载operator()的类 &#x2F; 结构体（函数对象），用于算法中的自定义逻辑（如比较、谓词）。
适配器（Adapters）：转换已有组件的接口（如 stack&#x2F;queue 是容器适配器，将 deque 适配为栈 &#x2F; 队列）。

容器
按存储结构分为序列式容器（元素有序，依赖位置）和关联式容器（元素无序，依赖键值）。

序列式容器
元素按插入顺序排列，访问依赖位置索引。

vector：动态数组
底层实现：连续的动态数组，内存地址连续，通过指针管理。
核心特性：
随机访问高效（[]或at()，时间复杂度O(1)）；
动态扩容：当容量不足时，申请2 倍（或 1.5 倍，取决于编译器）原容量的新内存，拷贝旧元素后释放旧内存（扩容成本高）；
尾部插入 &#x2F; 删除高效（push_back()&#x2F;pop_back()，O(1)），中间 &#x2F; 头部插入 &#x2F; 删除低效（需移动元素，O(n)）。


关键接口：
reserve(n)：预分配至少n个元素的内存（不改变大小size，减少扩容次数）；
resize(n, val)：调整大小为n，不足补val（改变size，可能扩容）；
erase(iter)：删除迭代器指向的元素，返回下一个有效迭代器（可能导致迭代器失效）。


适用场景：频繁随机访问、尾部增删，如存储列表数据、缓存等。

list：双向链表
底层实现：双向链表（每个节点含数据、前驱指针、后继指针），内存不连续。
核心特性：
随机访问低效（需遍历，O(n)）；
任意位置插入 &#x2F; 删除高效（只需修改指针，O(1)，前提是已定位到位置）；
不支持[]访问，迭代器是双向迭代器（支持++&#x2F;--，不支持+n）。


适用场景：频繁在中间插入 &#x2F; 删除，如实现链表、队列（非 FIFO 场景）等。

deque：双端队列
底层实现：分段连续的动态数组（多个固定大小的缓冲区，通过中控器指针数组管理）。
核心特性：
头部和尾部插入 &#x2F; 删除高效（push_front()&#x2F;pop_front()，O(1)）；
随机访问效率高于list但低于vector（O(1)，但需通过中控器定位缓冲区）；
扩容成本低于vector（只需新增缓冲区，无需拷贝全部元素）。


适用场景：需要双端操作的队列（如广度优先搜索 BFS 的队列）。

关联式容器
元素按“键”存储，支持快速查找，分为有序关联容器（红黑树实现）和无序关联容器（哈希表实现）

有序关联容器（红黑树， O(logn)操作）
set：存储唯一键（键即值），元素按键升序排列（默认less&lt;Key&gt;）。
multiset：与set类似，但允许键重复。
map：存储键值对（Key-Value），键唯一，按键升序排列。
multimap：与map类似，允许键重复。

核心特性
底层是红黑树（自平衡二叉搜索树），保证插入、删除、查找的时间复杂度为O(logn)；
支持按键范围查询（如lower_bound&#x2F;upper_bound）；
迭代器是双向迭代器（不支持随机访问），遍历为有序序列。

无序关联容器（哈希表，O(1)平均操作）
unordered_set：存储唯一键，键无序（哈希表存储）。
unordered_multiset：允许键重复的无序集合。
unordered_map：存储键值对，键唯一，无序。
unordered_multimap：允许键重复的无序映射。

核心特性
底层是哈希表（数组 + 链表 &#x2F; 红黑树，解决哈希冲突），平均插入、删除、查找时间复杂度O(1)，最坏O(n)（哈希冲突严重时）；
不支持有序遍历，迭代器是前向迭代器（仅支持++）；
需为键类型提供哈希函数（自定义类型需手动实现std::hash特化）。

map和unordered_map


维度
map（红黑树）
unordered_map（哈希表）



查找效率
O(logn)（稳定）
O(1)（平均），最坏O(n)


内存占用
较低（仅存储键值对和树结构）
较高（哈希表需要额外空间解决冲突）


有序性
支持（按键升序）
不支持


迭代器类型
双向迭代器（支持++&#x2F;--）
前向迭代器（仅支持++）


适用场景
需要有序遍历、范围查询
频繁查找，不关心顺序


容器适配器
stack：栈（后进先出 LIFO），默认底层容器是deque（也可指定list&#x2F;vector），接口：push()&#x2F;pop()&#x2F;top()。
queue：队列（先进先出 FIFO），默认底层容器是deque，接口：push()&#x2F;pop()&#x2F;front()&#x2F;back()。
priority_queue：优先队列（默认最大堆），底层是vector+ 堆算法，接口：push()&#x2F;pop()&#x2F;top()（访问堆顶元素）。

迭代器迭代器类型


迭代器类型
支持操作（除++外）
对应容器示例



输入迭代器
*（读）、&#x3D;&#x3D;,!&#x3D;
istream_iterator


输出迭代器
*（写）
ostream_iterator


前向迭代器
输入 + 输出迭代器功能，支持多遍访问
unordered_set&#x2F;unordered_map


双向迭代器
前向迭代器功能 + --
list、map、set


随机访问迭代器
双向迭代器功能 + +n&#x2F;-n&#x2F;[]
vector、deque、数组


迭代器失效
vector迭代器失效：
插入元素（push_back&#x2F;insert）：若触发扩容（内存重分配），所有迭代器失效；未扩容时，插入位置及之后的迭代器失效。
删除元素（erase）：删除位置及之后的迭代器失效，返回下一个有效迭代器（需用iter = vec.erase(iter)更新）。


list迭代器失效：
插入元素：迭代器不失效（仅修改指针，内存不移动）。
删除元素：仅被删除元素的迭代器失效，其他迭代器有效。


map&#x2F;set迭代器失效：
插入元素：迭代器不失效（红黑树结构调整，节点地址不变）。
删除元素：仅被删除节点的迭代器失效，其他迭代器有效。



算法常用算法及适用迭代器
排序：sort(first, last)（需随机访问迭代器，如vector&#x2F;deque），底层是introsort（结合快速排序、堆排序、插入排序）。
list不支持sort算法（无随机访问迭代器），需用自带成员函数list::sort()。


查找：find(first, last, val)（线性查找，O(n)）；binary_search(first, last, val)（二分查找，需有序序列，O(logn)）。
遍历：for_each(first, last, func)（对每个元素执行func，func可为函数或仿函数）。
删除：remove(first, last, val)（逻辑删除，移动元素覆盖目标值，返回新尾迭代器，需配合erase真正删除：container.erase(remove(...), container.end())）。

仿函数（Functors）：算法的自定义逻辑
仿函数是重载operator()的类 &#x2F; 结构体，用于算法中传递自定义操作（如比较、转换），比函数指针更灵活（可携带状态）。

]]></content>
      <categories>
        <category>C++</category>
        <category>5. 模板与STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>RAII</title>
    <url>/posts/1fa3f2ba.html</url>
    <content><![CDATA[
资源获取即初始化。
核心：用对象生命周期管理资源（构造时获取，析构时释放）
应用：智能指针、fstream（自动关闭文件）

核心思想
RAII 的本质是：将资源的获取（分配）与对象的初始化绑定，资源的释放（回收）与对象的析构绑定。
当对象被创建（构造函数调用）时，自动获取资源（如new内存、打开文件、加锁）；
当对象超出作用域（生命周期结束，析构函数调用）时，自动释放资源（如delete内存、关闭文件、解锁）。



RAII的实现原理
封装资源：定义一个类，将资源（如指针、句柄）作为类的私有成员；
获取资源：在类的构造函数中获取资源（如new分配内存、fopen打开文件），确保资源获取成功后对象才有效；
释放资源：在类的析构函数中释放资源（如delete内存、fclose关闭文件），无论对象如何销毁（正常退出、异常），析构函数都会被调用；
禁止拷贝（可选）：若资源不可共享（如独占锁），需禁止类的拷贝（删除拷贝构造和赋值运算符），避免资源被重复释放。

典型应用场景动态内存管理（智能指针式RAII的经典实现）
构造函数：接收动态内存指针（获取资源）；
析构函数：自动释放内存（delete&#x2F;delete[]）；
确保动态内存不会因忘记释放或异常导致泄漏。

互斥锁管理（避免死锁）
多线程中，锁的手动释放（忘记解锁）会导致死锁。

文件句柄管理（避免文件未关闭）
文件操作中，fopen后需fclose，忘记关闭会导致文件描述符泄漏。

网络连接
在对象创建时建立连接，对象销毁时断开连接。

RAII的优势
自动释放资源：无需手动调用释放函数（如delete&#x2F;free&#x2F;unlock），避免因疏忽导致的资源泄漏；
异常安全：即使函数因异常退出，对象的析构函数仍会被调用（C++ 标准保证），资源仍能释放；
简化代码：将资源管理逻辑封装在类中，业务代码无需关注释放细节，提高可读性和可维护性；
资源独占性：通过禁止拷贝，确保资源不被意外共享（如独占锁、unique_ptr）。

RAII与其他资源管理方式对比


管理方式
缺点
RAII 的优势



手动释放
易遗漏（如忘记delete）、异常下失效
自动释放，异常安全


goto 跳转释放
代码混乱（C 语言常用），多出口难维护
无需显式控制流程，依赖对象生命周期


函数末尾释放
提前返回时失效（如return前未释放）
无论退出方式（正常 &#x2F; 提前返回 &#x2F; 异常），均释放


问答RAII如何保证异常安全
C++标准规定，当异常抛出时，程序会销毁当前作用域内已构造的所有对象（调用其析构函数）。RAII将资源释放逻辑放在析构函数中，因此即使发生异常，对象析构仍会执行，资源被正确释放，避免异常导致的资源泄漏。

]]></content>
      <categories>
        <category>C++</category>
        <category>6. 内存管理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存</tag>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title>模板基础</title>
    <url>/posts/6bd4602e.html</url>
    <content><![CDATA[
函数模板：template &lt;typename T&gt; T max(T a, T b)（编译期生成具体类型函数，实例化方式）
类模板：template &lt;typename T&gt; T max(T a, T b)（编译期生成具体类型函数，实例化方式）
模板特化：
全特化：template &lt;&gt; class Vector&lt;char&gt; { ... };
偏特化：template &lt;typename T&gt; class Vector&lt;T*&gt;（对指针类型特化）


模板参数：类型参数（typename T）、非类型参数（template &lt;int N&gt; class A，N 必须是编译期常量）

模板的核心意义
模板通过将类型作为参数，让代码脱离具体类型约束，实现通用逻辑。

函数模板
函数模板是生成具体函数的 “模板”，编译器根据传入的实参类型自动生成对应版本的函数（称为 “实例化”）。

基本语法与实例化
定义：template&lt;模板参数列表&gt; 返回类型 函数名(参数列表) { … }
模板参数列表：用typename或class声明类型参数（如typename T），也可包含非类型参数


实例化：编译器根据实参类型自动推导模板参数，生成具体函数（隐式实例化）；也可显式指定类型（显式实例化）。

函数模板的重载
函数模板可以重载，需满足“模板参数列表不同“或”函数参数列表不同“，且非模板函数优先级高于模板函数。

类模板
类模板是生成具体类的 “模板”，用于创建与类型相关的通用类

基本语法与实例化
定义：template&lt;模板参数列表&gt; class 类名 { ... };
实例化：必须显式指定模板参数（编译器无法像函数模板一样推导），格式为类名&lt;类型&gt;。

类模板的成员函数
类模板的成员函数需在类外定义时保留模板参数

模板参数：类型参数与非类型参数类型参数（Type Parameter）
用typename或class声明，代表一种类型（如int、string、自定义类），是最常用的模板参数。

非类型参数（Non-Type Parameter）
代表一个编译期常量（如整数、指针、引用），需满足 “值在编译期可确定”。
常见类型：整数类型（int、size_t）、指针（指向全局变量 &#x2F; 函数）、引用（绑定全局变量）。
限制：不能是浮点数、类对象（因无法在编译期确定值）。



模板特化：定制特定类型的实现
模板特化是为特定类型提供定制化实现（覆盖泛化版本），解决泛化模板对某些类型不适用的问题

全特化
为模板的所有参数指定具体类型，完全覆盖泛化版本

偏特化（仅类模板支持）
为模板的部分参数指定具体类型（函数模板不支持偏特化）

补充
惰性实例化：模板仅实例化被使用的成员，未使用的成员不会实例化




维度
模板（Template）
宏（#define）



类型检查
编译期强类型检查（安全）
无类型检查（仅文本替换，易出错）


调试
支持调试（可看到具体实例化类型）
不支持（替换后无宏信息）


灵活性
支持复杂逻辑（类、函数重载、特化）
适合简单替换（复杂逻辑易出语法问题）


实例化
编译器自动生成具体类型代码
预编译期文本替换，不生成新代码


]]></content>
      <categories>
        <category>C++</category>
        <category>5. 模板与STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>动态内存</title>
    <url>/posts/58a84bc7.html</url>
    <content><![CDATA[
new&#x2F;delete：
new：分配内存 + 调用构造；new[]：数组（需匹配delete[]）
delete：调用析构 + 释放内存；不匹配new[]&#x2F;delete会导致未定义行为


智能指针（C++11，&lt;memory&gt;）
unique_ptr&lt;T&gt;：独占所有权（不可复制，可移动std::move）
shared_ptr&lt;T&gt;：共享所有权（引用计数，计数为0释放，线程安全）
weak_ptr&lt;T&gt;：弱引用（不增计数，解决shared_ptr循环引用）
实现：shared_ptr含指针+控制块（计数、删除器）



动态内存的核心概念动态内存与栈内存的区别
分配时机：栈内存由编译器自动分配（如局部变量），动态内存由程序员在运行时手动分配。
生命周期：栈内存随作用域结束自动释放，动态内存需手动释放（否则内存泄漏）
大小灵活性：栈内存大小固定（编译器确定），动态内存大小可在运行时根据需求调整。

动态内存的分配与释放C语言：malloc&#x2F;calloc&#x2F;realloc&#x2F;free
分配函数：
malloc(size)：分配size字节的未初始化内存，返回void*（需强制类型转换）
calloc(n,size)：分配n*size字节的内存，自动初始化为0，返回void*。
realloc(ptr,new_size)：释放已有动态内存的大小（可能迁移内存块）。


释放函数：free(ptr：释放ptr指向的动态内存（ptr必须是malloc系列函数返回的地址）

C++：new&#x2F;delete与new[]&#x2F;delete[]
核心优势是类型安全和自动调用构造&#x2F;析构函数

单个对象的分配与释放
new T：分配T类型大小的内存，自动调用T的构造函数，返回T*（无需类型转换）
delete ptr：自动调用T的析构函数，再释放内存。

数组的分配与释放
new\[T]：分配n个T类型的数组内存，调用n次T的构造函数

delete[] ptr：调用n次T的析构函数，再释放数组内存（必须用delete[]，而非delete）

若用delete释放new[]分配的数组，会导致仅第一个元素的析构函数被调用，其余元素析构函数未执行（资源泄漏），且释放内存的大小可能错误（崩溃风险）。

若用delete[]释放new分配的单个对象，会导致错误读取随机的 “数组长度”，对不存在的 “元素” 调用析构函数（可能多次调用，超出实际对象数量，若为自定义类型会引发资源重复释放），且释放内存的起始地址计算错误（破坏内存管理器状态，崩溃风险）。


new&#x2F;delete与malloc&#x2F;free的区别


维度
malloc&#x2F;free
new&#x2F;delete



类型安全
返回void*，需手动强转（不安全）
返回对应类型指针（无需转换，安全）


构造 &#x2F; 析构
不调用（仅分配 &#x2F; 释放内存）
自动调用构造函数（new）和析构函数（delete）


分配失败处理
返回NULL
默认抛出bad_alloc异常（可指定nothrow返回NULL）


数组支持
需手动计算总大小（n*sizeof(T)）
直接支持new T[n]（自动计算大小）


重载扩展
不可重载
可重载operator new&#x2F;operator delete定制内存分配


动态内存的底层机制
new&#x2F;delete并非直接操作内存，而是通过底层函数实现

new的执行流程
T* p = new T(args); 等价于：


调用operator new(sizeof(T))：分配sizeof(T)字节的原始内存（底层通常调用malloc）。
在分配的内存上调用T的构造函数：new(p) T(args)（placement new，在指定内存构造对象）。
返回指向对象的指针p。

delete的执行流程
delete p; 等价于：


调用p-&gt;~T()：执行T的析构函数（清理对象资源）。
调用operator delete(p)：释放p指向的内存（底层通常调用free）。

常见问题内存泄漏
定义：动态内存已不再使用，但未被释放，导致内存被永久占用（程序运行中可用内存逐渐减少）。
原因：
忘记调用delete&#x2F;free（最常见）
指针被重新赋值（原内存地址丢失，无法释放）
异常导致释放代码未执行（如new后抛出异常，delete未执行）


方案：
用智能指针（unique_ptr&#x2F;shared_ptr）自动管理内存；
遵循 “谁分配谁释放” 原则，封装内存管理逻辑；
用 RAII（资源获取即初始化）机制（对象析构时自动释放资源）。



野指针
定义：未初始化的指针（指向随机内存地址）。
危害：解引用野指针会导致未定义行为（读取垃圾值、修改无关内存、程序崩溃）。
避免方案：指针定义时初始化（如int* p = nullptr;），释放后置为nullptr。

悬空指针
定义：指向已释放内存的指针（内存已被回收，但指针仍保留旧地址）
危害：解引用会访问无效内存（可能暂时有效，导致逻辑错误；也可能崩溃）
避免方案：释放内存后立即将指针置为nullptr，避免重复释放。

智能指针（C++11+）：自动管理动态内存
智能指针是封装动态内存的类模板，通过RAII 机制在析构时自动释放内存，解决手动管理的缺陷

unique_ptr：独占所有权
特性：同一时间仅一个unique_ptr指向动态内存（所有权独占），不可复制（只能移动）
适用场景：单一所有者的动态内存（如局部动态对象）

shared_ptr：共享所有权
特性：多个shared_ptr可共享同一动态内存，通过引用计数管理生命周期（计数为0时自动释放）
适用场景：多所有者的动态内存（如共享资源）

weak_ptr：解决循环问题
特性：弱引用（不增加引用计数），用于观测shared_ptr管理的内存，可避免shared_ptr的循环引用问题。

问答智能指针的底层实现原理
智能指针是类模板，封装原始指针，通过 RAII 机制在析构函数中自动释放内存。unique_ptr通过删除拷贝构造 &#x2F; 赋值实现独占；shared_ptr通过引用计数（指针指向的控制块存储计数）实现共享，计数为 0 时释放内存；weak_ptr指向控制块，不影响计数。

]]></content>
      <categories>
        <category>C++</category>
        <category>6. 内存管理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态内存</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>继承与多态</title>
    <url>/posts/3a088510.html</url>
    <content><![CDATA[
继承解决“代码复用与扩展”，多态解决“接口统一与动态行为”
继承：
继承方式：public（父类public→public，protected→protected）、private、protected
构造 &#x2F; 析构顺序：先父后子（构造），先子后父（析构）
菱形继承：子类间接继承同一父类多次（导致成员二义性），解决方案：虚继承（class D : virtual public B）


多态：
核心：基类指针 &#x2F; 引用指向派生类对象，调用虚函数时执行派生类实现
虚函数：基类用virtual声明（virtual void func();），派生类可重写（override显式标注）★
纯虚函数：virtual void func() = 0;（无实现），含纯虚函数的类为抽象类（不能实例化）
实现原理：虚函数表（vtable，每个类一个，存储虚函数地址）+ 虚指针（vptr，对象中指向 vtable 的指针）
虚析构函数：基类析构必须virtual（确保删除派生类对象时调用正确析构）



继承：代码复用与层次化设计
继承是指一个类（派生类）从另一个类（基类）获取成员（属性和行为）的机制，核心是”站在已有类的基础上扩展功能“。

继承方式和成员访问权限


基类成员权限
public 继承
protected 继承
private 继承



public
派生类 public
派生类 protected
派生类 private


protected
派生类 protected
派生类 protected
派生类 private


private
派生类不可访问
派生类不可访问
派生类不可访问


派生类的构造与析构构造函数
先调用基类构造函数（初始化基类部分），再调用派生类构造函数（初始化派生类新增部分）。
若基类无默认构造函数，派生类必须在初始化列表中显示调用基类带参构造（否则编译报错）。

析构函数
先调用派生类析构函数（清理派生类资源），再调用基类析构函数（清理基类资源）。
若基类析构函数不是虚函数，删除派生类对象（通过基类指针）时，可能只调用基类析构，导致派生类资源泄漏。

菱形继承与虚继承
菱形继承：一个派生类间接继承自同一个基类多次，数据冗余和二义性
解决方法：虚继承（通过virtual关键字声明继承，确保间接基类在派生类中只存在一份实例）
原理：虚继承的派生类会通过虚基类表指针（vbptr）间接访问基类成员，避免数据冗余
虚继承的基类构造函数由最终派生类负责初始化（而非直接派生类）



多态：接口复用与动态行为
多态是指“同一接口，不同实现”，调用相同函数时，根据对象实际类型执行不同逻辑。

静态多态（编译期多态）
编译时确定调用哪个函数，通过函数重载或模板实现：
函数重载：同一作用域内同名函数，参数列表不同
模板：参数类型不同时生成不同版本的函数 &#x2F; 类



动态多态（运行期多态）
运行时根据对象实际类型确定调用的函数，通过虚函数实现。

虚函数的核心机制
基类中用virtual修饰的成员函数，允许派生类重写override该函数。
重写条件：
派生类函数与基类函数函数名、参数列表、返回类型完全一致（返回类型可协变：基类返回Base*，派生类可返回Derived*）
基类函数必须有virtual关键字
访问权限可不同（但通过基类指针调用时需权限允许）



动态绑定的底层实现：虚函数表和虚指针
虚函数表（vtable）：每个包含虚函数的类（基类 &#x2F; 派生类）有一个全局唯一的 vtable，存储该类所有虚函数的地址。
虚指针（vptr）：每个对象包含一个vptr 成员（占 8 字节，64 位系统），指向所属类的 vtable。
流程：


基类声明虚函数，编译器为基类生成 vtable，存储基类虚函数地址。
派生类重写虚函数，编译器为派生类生成 vtable，其中重写的虚函数地址替换为派生类版本，未重写的仍指向基类版本。
对象创建时，vptr 被初始化，指向所属类的 vtable。
调用虚函数时（如base_ptr-&gt;func()），编译器通过对象的 vptr 找到 vtable，再调用对应函数地址（运行时确定，即动态绑定）。

纯虚函数与抽象类
纯虚函数是 “未实现的虚函数”，用于定义接口（必须由派生类实现）：
抽象类：包含纯虚函数的类，不能实例化对象（只能作为基类）。
派生类：必须实现所有纯虚函数，否则仍是抽象类（无法实例化）。

补充重写（Override） vs 重载（Overload） vs 隐藏（Hide）（易混淆）
重写（Override）：派生类重写基类虚函数（同函数名、参数、返回值，动态多态）。
重载（Overload）：同一作用域内同名函数（参数列表不同，静态多态）。
隐藏（Hide）：派生类函数与基类函数同名，但不满足重写条件，导致基类函数被 “隐藏”（调用时只能通过基类名限定访问）。

虚函数的限制
静态成员函数不能是虚函数（无 this 指针，无法动态绑定）。
构造函数不能是虚函数（对象构造时 vptr 尚未初始化，无法访问 vtable）。
内联函数可以是虚函数，但调用时若触发动态绑定，内联会失效（内联是编译期，动态绑定是运行期）。

]]></content>
      <categories>
        <category>C++</category>
        <category>4. 面向对象编程OOP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分区</title>
    <url>/posts/b5d386b7.html</url>
    <content><![CDATA[
栈（stack）：局部变量、函数参数（自动分配&#x2F;释放，大小有限，速度块）
堆（heap）：动态内存（new&#x2F;delete，手动管理，大小灵活，速度慢）
全局&#x2F;静态区：全局变量、static变量（程序生命周期）
常量存储区：生命周期贯穿整个程序且只读的数据
代码区：可执行代码（只读）

内存分区的核心分类栈（stack）：函数调用的“临时空间”
存储内容：局部变量（函数内定义的变量）、函数参数、返回地址、寄存器上下文等。
生命周期：随函数调用创建，函数返回时自动释放（无需手动管理）
分配方式：编译器自动分配，遵循“先进后出（FILO）”原则二
特点：
大小固定（通常几MB，由操作系统决定），超出 则栈溢出（如递归过深、局部数组过大）
内存地址连续，生长方向向下（从高地址向低地址扩展）
分配效率极高（仅需移动栈顶指针）



堆（heap）：动态分配的“手动管理空间”
存储内容：程序运行中动态分配的内存（如new&#x2F;malloc申请的空间）
生命周期：由程序员手动分配（new&#x2F;malloc）和释放（delete&#x2F;free），若未释放则程序结束后由操作系统回收（否则导致内存泄漏）
分配方式：手动调用函数分配，内存管理复杂（依赖内存池或系统调用）
特点：
大小不固定（可至GB级，受限于系统内存），生长方向向上（从低地址向高地址扩展）
内存地址不连续（频繁分配&#x2F;释放会产生内存碎片）
分配效率低于栈（需查找空闲内存块）



全局&#x2F;静态存储区：”全局可见的持久空间“
存储内容：
全局变量（定义在函数外的变量）
静态变量（static修饰的变量，包括全局静态变量和局部静态变量）


生命周期：从程序启动（main函数执行前）到程序结束（main函数返回后），由操作系统自动释放。
分配方式：编译期确定大小，程序加载时由操作系统自动释放。
特点：
全局变量和静态变量存储在同一片区域，仅作用域不同（全局变量作用域未整个程序，静态变量作用域受限于未定义位置）
未初始化的全局&#x2F;静态变量默认值为0（编译器自动清零）



常量存储区：”只读的常量空间“
存储内容：常量（如字符串变量“hello”、const修饰的全局常量等）。
生命周期：同程序生命周期（从加载到结束）
特点：
内存只读（修改会导致未定义行为，如崩溃）
字符串常量可能被编译器优化为共享。


补充：
const局部变量存储在栈上（虽然
不可修改，但本质是栈内存，生命周期同局部变量）
字符串常量&quot;hello&quot;存储在常量区，而字符数组char arr[] = &quot;hello&quot;的内容存储在栈上



代码区：”程序指令的存储区“
存储内容：程序的机器指令（二进制代码）、只读数据（如一些常量表达式）
生命周期：同程序生命周期，程序加载时载入内存。
特点：
内存只读（防止程序被篡改）
可共享（多个线程运行同一程序时，共享同一份代码区，节省内存）



核心对比


分区
存储内容
生命周期
分配方式
管理方式



栈
局部变量、参数、返回地址
函数调用期间
编译器自动
自动释放


堆
动态分配的内存
手动分配到手动释放
程序员手动（new&#x2F;malloc）
手动释放（delete&#x2F;free）


全局 &#x2F; 静态存储区
全局变量、静态变量
程序整个运行期
编译期分配
程序结束自动释放


常量存储区
字符串常量、全局常量
程序整个运行期
编译期分配
程序结束自动释放


代码区
机器指令、只读数据
程序整个运行期
程序加载时
只读，不可修改


线程局部存储
存储内容：thread_local修饰的变量（线程私有变量）
生命周期：与线程一致（线程创建时分配，线程结束时释放）
特点：每个线程拥有独立的变量副本，互不干扰（解决多线程中全局变量的竞争问题）

补充全局变量、局部变量、静态局部变量分别存储在哪个区？生命周期如何？
全局变量：全局&#x2F;静态存储区，生命周期为整个程序运行期
局部变量：栈，生命周期为函数调用期间
静态局部变量：全局&#x2F;静态存储区，生命周期为整个程序运行期（作用域限于函数内）

]]></content>
      <categories>
        <category>C++</category>
        <category>6. 内存管理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存</tag>
        <tag>分区</tag>
      </tags>
  </entry>
  <entry>
    <title>类型推导</title>
    <url>/posts/6d04aba6.html</url>
    <content><![CDATA[
auto：编译器推导变量类型，不能用于函数参数&#x2F;数组
decltype：推导表达式类型（auto忽略引用，decltype保留）

auto：自动推导变量类型
auto让编译器根据初始化表达式自动推导变量类型，核心作用是简化长类型声明（如迭代器、复杂模板类型），避免手动拼写错误。

基本推导规则
auto根据初始化表达式的类型推导变量类型，必须初始化（否则编译器无法推导）。

auto与引用、const的结合
auto推导会忽略顶层const和引用（底层const保留）

顶层const
变量本身是常量，auto推导时会忽略顶层const

const int x = 10;auto a = x;  // a推导为int（顶层const被忽略）auto&amp; b = x; // b推导为const int&amp;（引用保留底层const）

引用
auto直接推导引用的目标类型，若需推导为引用，需显式加&amp;

int y = 20;int&amp; ref = y;auto c = ref;  // c推导为int（忽略引用，拷贝值）auto&amp; d = ref; // d推导为int&amp;（显式&amp;保留引用）

底层const
指向常量的指针&#x2F;引用，auto推导时保留底层const

const int* p = &amp;x;auto e = p;  // e推导为const int*（保留底层const）

auto的限制
不能用于函数参数（编译器无法推导未初始化的参数类型）
不能用于非静态成员变量（类成员初始化时机与auto推导冲突）
不能推导数组类型（会被推导为指针）

decltype：推导表达式类型
decltype用于推导表达式的精确类型（不执行表达式），与auto的核心区别是：auto关注“变量初始化的类型”。decltype关注“表达式本身的类型”

基本推导规则
decltype(变量名)：推导结果为变量的声明类型（保留const和引用）
decltype(表达式)：推导结果为表达式的返回类型（根据表达式值类别判断）
decltype(函数调用)：推导为函数的返回类型（不执行函数）

decltype与auto区别


特性
auto
decltype



推导依据
变量初始化表达式的类型
任意表达式的类型（不执行表达式）


引用 &#x2F;const
忽略顶层const和引用
完全保留表达式的const和引用


用途
简化变量声明（需初始化）
获取表达式精确类型（如模板返回值）


模板类型推导]]></content>
      <categories>
        <category>C++</category>
        <category>7. 现代C++特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>类型推导</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用和移动语义</title>
    <url>/posts/4d855a6b.html</url>
    <content><![CDATA[
右值：临时对象、字面量
右值引用：T&amp;&amp;（绑定右值，延长临时对象生命周期）
移动语义：转移资源而非拷贝（std::move将左值转为右值引用，触发移动构造&#x2F;赋值）
完美转发：std::forward（保持参数类别，用于模板：template &lt;typename T&gt; void func(T&amp;&amp; t) { f(std::forward&lt;T&gt;(t)); }）

左值与右值：C++中值的分类
核心在于是否可被取地址和是否有持久的生命周期

左值
定义：可放在赋值符号左侧的表达式，有持久的内存地址，生命周期较长
特征：可被&amp;取地址，可被赋值

右值
定义：只能放在赋值符号右侧的表达式，无持久内存地址（或地址无意义），生命周期短暂（如临时对象、字面量）
特征：不可被&amp;取地址（取地址会报编译错误），通常是临时结果。
右值又分为纯右值（如字面量、表达式结果）和将亡值（即将被销毁的对象）

右值引用：绑定右值的引用类型
右值引用（Rvalue Reference）是一种新的引用类型，语法为T&amp;&amp;，专门用于绑定右值（纯右值或将亡值），其核心作用是延长右值的生命周期并实现移动语义

右值引用的基本特性
绑定对象：只能绑定右值（纯右值或将亡值），不能直接绑定左值（需通过std::move转换）。
生命周期延长：右值引用绑定临时对象后，临时对象的生命周期会被延长至与右值引用相同（避免被立即销毁）。
可修改性：与const T&amp;（常量左值引用，只能读）不同，右值引用（T&amp;&amp;）可以修改所绑定的右值（因为右值即将销毁，修改不影响其他对象）。

右值引用和左值引用


类型
语法
可绑定对象
能否修改绑定值
典型用途



左值引用
T&amp;
左值
能（非 const）
传递参数、返回引用


常量左值引用
const T&amp;
左值、右值
不能
接收任意值（避免拷贝）


右值引用
T&amp;&amp;
右值（纯右值、将亡值）
能
实现移动语义、完美转发


移动语义：避免不必要的拷贝
移动语义通过转移资源所有权而非复制资源，避免了深拷贝。

移动构造函数和移动赋值运算符移动构造函数
语法：T(T&amp;&amp; other) noexcept;
作用：接管other的资源，并将other置为“可安全销毁”的状态

移动赋值运算符
语法：T&amp; operator&#x3D;(T&amp;&amp; other) noexcept;
作用：先释放当前对象的资源，再接管other的资源，最后将other置空。

移动语义的优势
性能优化：避免深拷贝的资源复制，将拷贝变为指针赋值。
资源转移安全：针对将亡值，转移资源不会影响其他对象
支持不可拷贝对象的转移：某些资源不可拷贝，但可通过移动语义转移所有权。

std::move：并非移动而是转换
作用是将左值强制转换为右值，而非实际移动资源。

特性
不实际移动资源，仅修改值的属性
转换后原对象仍有效，但不应再使用
可用于任何对象，包括自定义类型和内置类型

补充noexcept
移动构造 &#x2F; 赋值若可能抛出异常，标准容器（如vector）在扩容时会优先选择拷贝而非移动（避免异常导致数据丢失），失去优化意义。因此，移动函数通常需加noexcept。

]]></content>
      <categories>
        <category>C++</category>
        <category>7. 现代C++特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>右值引用</tag>
        <tag>移动语义</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/posts/bbcf5ff7.html</url>
    <content><![CDATA[
语法：[捕获列表](参数) mutable -&gt; 返回类型 { 函数体 }
捕获列表：[]（无）、[=]（按值）、[&amp;]（按引用）、[x, &amp;y]（混合）
应用：作为算法参数（sort的比较函数）

Lambda的语法结构
由捕获列表、参数列表、返回类型和函数体组成

[capture-list](parameter-list) mutable noexcept -&gt; return-type &#123; function-body &#125;


捕获列表（[]）：指定 Lambda 外的变量如何被内部访问（如值捕获、引用捕获），是 Lambda 最核心的特性。
参数列表（()）：与普通函数参数列表一致，可省略（无参数时）。
mutable：可选，允许 Lambda 内部修改值捕获的变量（默认值捕获为 const）。
noexcept：可选，声明 Lambda 不抛出异常。
返回类型（-&gt; type）：可选，编译器可自动推导（仅当函数体有return且类型唯一时）。
函数体（{}）：函数逻辑实现。

捕获列表按值捕获（[var]）
语法：[x] 表示拷贝外部变量x到 Lambda 内部（形成副本）。
特性：
Lambda 内部访问的是副本，修改副本不影响外部变量；
默认副本为const，若需修改需加mutable；
捕获的变量在 Lambda 创建时拷贝，而非调用时。



按引用捕获（[&amp;var]）
语法：[&amp;x] 表示捕获外部变量x的引用。
特性：
Lambda 内部直接访问外部变量，修改会影响外部；
需确保 Lambda 调用时，被引用的变量仍有效（避免悬垂引用）。



默认捕获（[&#x3D;]或[&amp;]）
[=]：默认按值捕获所有使用的外部变量（仅捕获 Lambda 中实际用到的变量）。
[&amp;]：默认按引用捕获所有使用的外部变量。

混合捕获（部分默认+部分显式）
规则：默认捕获（&#x3D;或&amp;）与显式捕获结合时，显式捕获需与默认捕获方式相反。
[=, &amp;x]：默认按值捕获，仅x按引用捕获；
[&amp;, y]：默认按引用捕获，仅y按值捕获。



捕获列表的禁忌
不能捕获this指针以外的局部变量的地址或引用
函数参数不能被捕获
全局变量无需捕获

Lambda的类型与存储
Lambda表达式的类型是编译器生成的匿名类（闭包类型），该类重载了operator()（即仿函数），因此 Lambda 可像函数对象一样使用。

Lambda的类型特性
每个Lambda的类型都是唯一的（即使代码相同），无法直接声明其类型，需通过auto推导或std::function包装。
无捕获的Lambda可隐式转换为函数指针，有捕获的Lambda则不能。

std::function包装Lambda
std::function（C++11）是通用函数包装器，可存储任何可调用对象（包括 Lambda、函数指针、仿函数），解决 Lambda 类型唯一化的问题。

问答
Lambda 与普通函数、仿函数的区别？
普通函数：全局可见，无状态（不能访问外部变量）；
仿函数：需定义类，可通过成员变量存储状态，代码冗余；
Lambda：匿名，可就地定义，通过捕获列表灵活访问外部变量，简化短小逻辑的传递。



]]></content>
      <categories>
        <category>C++</category>
        <category>7. 现代C++特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步</title>
    <url>/posts/895e9db.html</url>
    <content><![CDATA[
数据竞争：多线程并发访问共享资源且至少一个为写操作的未定义行为
互斥锁（Mutex）：
基础锁：std::mutex（lock()&#x2F;unlock()）
RAII 锁：std::lock_guard（自动管理，推荐）、std::unique_lock（灵活控制，配合条件变量）
特殊锁：std::recursive_mutex（允许同一线程重复加锁）、std::timed_mutex（超时尝试加锁）


条件变量（Condition Variable）：
核心接口：wait()（阻塞等待 + 释放锁）、notify_one()（唤醒一个）、notify_all()（唤醒所有）
应用场景：生产者 - 消费者模型
虚假唤醒：必须用谓词（wait(lock, []{...})）检查条件


原子操作（std::atomic）：
特性：不可分割操作，无锁同步
常用类型：atomic&lt;int&gt;、atomic_bool、atomic_ptr
内存序：memory_order_relaxed、memory_order_acquire&#x2F;release、memory_order_seq_cst（面试高频）


栅栏（Fence）：std::atomic_thread_fence（控制内存可见性，无锁编程）

线程同步的目标
限制线程的执行顺序或保证资源访问的原子性


数据一致性问题：多个线程读写共享数据，导致结果不可预测
执行顺序问题：线程执行顺序不符合业务逻辑

线程同步机制互斥锁：独占式访问
原理：通过 “加锁 - 操作 - 解锁” 流程，保证同一时间只有一个线程进入 “临界区”（访问共享资源的代码段），其他线程需等待锁释放。

std::mutex，配合std::lock_guard（RAII 自动管理锁）使用。

优点：适用范围广（任何共享资源），实现简单。

缺点：阻塞等待（未获取锁的线程会挂起），可能导致性能损耗；若使用不当易引发死锁。

std::mutex的lock()&#x2F;unlock()必须成对出现，否则死锁；std::lock_guard通过 RAII 自动保证解锁（即使发生异常）。

不可递归加锁（同一线程多次lock()会导致死锁），需递归锁时用std::recursive_mutex（但不推荐，易隐藏逻辑问题）。


条件变量：线程间通信
原理：实现线程间的 “等待 - 通知” 机制，让线程在满足特定条件前阻塞等待，当条件满足时被其他线程唤醒，避免 “忙等”（空循环浪费 CPU）。
接口：
wait(lock, predicate)：释放锁并阻塞，被唤醒后重新获取锁，若predicate为true则继续，否则再次阻塞（解决 “虚假唤醒”）。
notify_one()：唤醒一个等待的线程。
notify_all()：唤醒所有等待的线程。



问答
为什么需要与互斥锁配合？
wait()前需加锁检查条件（避免检查期间条件被修改），阻塞时释放锁（允许其他线程修改条件），唤醒后重新加锁（确保条件的一致性）。


什么是虚假唤醒？如何解决？
操作系统可能在无notify时唤醒wait()（如信号中断）。解决方式：wait()的第二个参数传入条件判断（predicate），唤醒后再次检查条件。



原子变量：无锁同步
原理：通过硬件级别的原子操作（如 CPU 的LOCK指令），保证对简单数据类型的读写操作不可分割，无需加锁即可避免数据竞争。
优点：非阻塞（不会导致线程挂起），性能远高于锁（尤其高并发场景）
缺点：仅支持简单操作（如++、--、load、store），复杂逻辑（如多步操作）仍需锁

问答
std::atomic与volatile的区别：
volatile仅保证变量不被编译器优化（每次从内存读取），但不保证原子性（多线程读写仍可能竞争）；atomic保证原子性，是线程安全的。



读写锁：读写分离优化
原理：区分“读操作”和“写操作”，允许多个线程同时读（共享锁）
C++标准库实现：std::shared_mutex，配合std::shared_lock（读锁）和std::unique_lock（写锁）。
适用场景：读操作远多于写操作（如缓存、配置读取），避免读操作互相阻塞。

同步机制的对比与选择


机制
核心原理
优点
缺点
适用场景



互斥锁
独占临界区
适用所有场景
阻塞，性能损耗大
复杂临界区（多步操作）


条件变量
等待 - 通知机制
解决执行顺序问题，避免忙等
需配合互斥锁，逻辑复杂
生产者 - 消费者、线程协作


原子变量
硬件级原子操作
非阻塞，性能极高
仅支持简单操作
计数器、标记位等简单共享数据


读写锁
读写分离，读共享写独占
优化读多写少场景的性能
实现复杂，写操作可能饥饿
缓存、配置等读多写少场景


线程同步的常见问题和解决方案死锁
两个或多个线程互相等待对方释放锁，导致所有线程永久阻塞。

避免方案
固定加锁顺序：所有线程按相同顺序加锁（如先锁 mtx1，再锁 mtx2）。
同时加锁多个锁：用std::lock(mtx1, mtx2)一次性加锁，避免部分加锁。
限时等待：用std::try_lock尝试加锁，超时则释放已持有的锁。
减少锁的粒度：缩小临界区范围，减少持有锁的时间。

活锁
线程不断尝试获取锁，但因相互谦让（如释放锁后立即重试），导致始终无法获取所有资源，看似活跃却无进展。

解决方案
重试前随机延迟（减少冲突概率），或引入优先级机制。

饥饿
某些线程长期无法获取资源（如低优先级线程被高优先级线程持续抢占）。

避免方案
公平锁（按请求顺序分配锁）、限制高优先级线程的执行时间。

问答条件变量为什么必须配合互斥锁使用
检查条件时需加锁，防止检查期间条件被其他线程修改
wait()阻塞前释放锁，允许其他线程修改条件
唤醒后重新加锁，确保条件的一致性。互斥锁保证了条件判断和修改的原子性

]]></content>
      <categories>
        <category>C++</category>
        <category>8. 多线程编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>线程基础</title>
    <url>/posts/b9f6280b.html</url>
    <content><![CDATA[
线程概念：进程与线程的区别（资源分配 vs 调度单位）、用户线程 vs 内核线程
线程创建与生命周期：
std::thread构造（函数、lambda、函数对象）
线程状态：就绪、运行、阻塞、终止
线程管理：join()（等待回收）、detach()（分离，避免异常）、joinable()（检查是否可 join）


线程标识：std::this_thread::get_id()、std::thread::id（唯一性判断）

线程的基本概念线程与进程
进程是程序的一次执行实例，拥有独立的内存空间（代码、数据、堆栈）。
线程是进程内的一个执行单元，共享进程的内存空间（代码、全局数据），但有独立的栈和寄存器。
核心区别：进程间通信（IPC）成本高（需跨地址空间），线程间通信成本低（共享内存）。

线程的优势
并发执行多个任务
充分利用多核CPU资源
比进程更轻量

线程的创建
C++11 引入std::thread库，标准化线程操作，避免依赖平台特定 API（如 Windows 的CreateThread、Linux 的pthread_create）。

线程创建的三种方式
函数指针&#x2F;函数对象（传递函数指针及参数）
Lambda表达式（最简洁，推荐）
类成员函数（传递成员函数指针、对象指针及参数）

join()与detach()的区别
join()：主线程等待子线程执行完毕后再继续，阻塞当前线程，回收子线程资源（避免“僵尸线程”）
detach()：主线程与子线程分离，子线程后台运行，主线程不等待，子线程资源由系统自动回收（慎用，可能主线退出后子线程访问无效资源）

]]></content>
      <categories>
        <category>C++</category>
        <category>8. 多线程编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型与高并发</title>
    <url>/posts/567736fd.html</url>
    <content><![CDATA[
阻塞IO：recv()&#x2F;accept()阻塞线程，并发低（1线程1连接）
非阻塞IO：fcntl设为非阻塞，操作立即返回（EAGAIN重试），需轮询（忙等，效率低）
IO多路复用：单线程监控多Socket，事件就绪后处理
select：监控文件描述符集合（上线FD_SETSIZE，轮询效率低）
poll：动态数组（无上限，仍轮询）
epoll（Linux）：
原理：内核维护事件表，epoll_ctl注册事件，epoll_wait返回就绪事件（无轮询）
模式：LT（水平触发，就绪则通知）、ET（边缘触发，状态变化才通知，需一次读完）




高并发模型：
Reactor 模式：事件驱动，epoll监控事件→分发处理器（读 &#x2F; 写 &#x2F; 连接）
多线程 Reactor：主线程epoll，子线程池处理任务



同步IO与异步IO
同步 IO：线程发起 IO 请求后，必须等待 IO 操作（如数据读写）完成才能继续执行（即使是 “轮询”，线程仍在主动等待）。
典型：阻塞 IO、非阻塞 IO、IO 多路复用（select&#x2F;poll&#x2F;epoll）。


异步 IO：线程发起 IO 请求后，无需等待，可继续执行其他任务；IO 完成后，内核通过信号或回调通知线程处理结果。
典型：POSIX AIO、Windows IOCP。


IO多路复用是同步IO（需主动读取就绪数据），而非异步IO。

五大IO模型的原理与对比
IO 操作的核心流程是 “发起 IO 请求→等待 IO 就绪→读取 &#x2F; 写入数据”，五大模型的差异在于 “等待 IO 就绪” 和 “数据拷贝” 的方式。

阻塞IO：最简单的IO模型
原理：线程发起 IO 请求后，内核会阻塞线程，直到 IO 操作（数据从网卡拷贝到用户缓冲区）完成，线程才继续执行。
流程：发起recv请求-&gt;内核阻塞线程-&gt;数据拷贝完成-&gt;线程唤醒，返回数据。
优点：实现简单（无需处理非阻塞逻辑），开发成本低。
缺点：一个线程只能处理一个连接，并发能力极差（线程阻塞期间无法做其他事）
适用场景：连接数少、逻辑简单的场景（如本地工具、小规模服务）。

非阻塞IO：轮询式IO
原理：线程发起 IO 请求后，内核立即返回（无论数据是否就绪）；若数据未就绪，返回 “未就绪” 标志（如EAGAIN），线程需主动轮询（反复发起请求），直到 IO 就绪。
流程：  发起 recv 请求 → 数据未就绪 → 返回EAGAIN → 线程轮询重试 → 数据就绪 → 数据拷贝 → 返回结果。
优点：线程不阻塞，可同时处理多个连接（轮询多个 FD）。
缺点：轮询会占用大量 CPU 资源（即使无数据就绪，线程仍在空转），效率低。
适用场景：极少单独使用，通常配合 IO 多路复用。

IO多路复用：高并发核心模型
原理：通过一个 “中间组件”（如 select&#x2F;poll&#x2F;epoll）管理多个 IO 连接（FD），线程阻塞在 “中间组件” 上，而非单个 IO 请求；当任一连接的 IO 就绪时，“中间组件” 通知线程，线程再处理该连接的 IO。
流程：注册多个 FD 到 epoll → 线程阻塞在 epoll_wait → 某 FD 就绪 → epoll 返回就绪 FD → 线程处理该 FD 的 IO（recv&#x2F;send）。
核心优势：单线程 &#x2F; 少量线程即可处理大量连接（避免线程阻塞在单个 IO），CPU 利用率高。
典型实现：




实现
底层结构
最大 FD 限制
效率
核心缺陷



select
位图
1024（固定）
O (n)（轮询）
FD 限制、轮询开销大


poll
动态数组
无（理论）
O (n)（轮询）
轮询开销大（高并发卡顿）


epoll
红黑树 + 就绪链表
无（系统限制）
O (1)（事件驱动）
仅支持 Linux（平台依赖）



epoll 的核心优化：
事件驱动而非轮询：epoll 通过回调机制记录就绪 FD，无需遍历所有注册 FD；
共享内存：FD 注册信息存储在内核态，避免用户态与内核态的频繁数据拷贝；
支持 LT&#x2F;ET 模式：
水平触发（LT）：只要 FD 缓冲区有数据，就持续通知（易用，不会漏数据，默认模式）；
边缘触发（ET）：仅在数据 “首次到来” 时通知一次（需一次性读完缓冲区，效率更高，适合高并发）。





信号驱动IO：极少使用
原理：线程通过sigaction注册信号回调，发起 IO 请求后不阻塞，继续执行；当 IO 就绪时，内核发送SIGIO信号，线程在信号回调中处理 IO。
优点：无需轮询，CPU 利用率高。
缺点：信号处理逻辑复杂（如信号竞态、嵌套），难以调试，实际场景中极少使用。

异步IO：理想模型
原理：线程发起 IO 请求时，指定 “IO 完成后的回调函数”，随后立即返回；内核完成 “数据拷贝”（从网卡→用户缓冲区）后，调用回调函数通知线程。
流程：发起 aio_read 请求（指定回调） → 线程继续执行其他任务 → 内核完成数据拷贝 → 调用回调函数。
优点：线程完全不参与 IO 等待和数据拷贝，并发效率最高。
缺点：跨平台支持差（Linux AIO 不成熟，Windows IOCP 常用），开发复杂度高。
适用场景：Windows 高并发服务（如游戏服务器），Linux 场景下较少用。

高并发的挑战与IO模型选择
高并发的核心目标是 “用有限的资源（CPU、内存）处理尽可能多的连接”，核心挑战是 “减少线程阻塞、降低资源开销”。

高并发的核心瓶颈
线程阻塞：BIO 模型中，线程阻塞在 IO 上，导致并发数受限；
线程切换开销：多线程模型中，大量线程切换会消耗 CPU 资源；
内核态与用户态拷贝：频繁的数据拷贝（如 select 的 FD 集合拷贝）降低效率。

高并发场景的IO模型选择
百万级并发（如 Web 服务器、即时通讯）：优先选「IO 多路复用（epoll）+ 线程池」；
原因：epoll 单线程处理百万级 FD，线程池处理 IO 就绪后的业务逻辑（避免单线程业务阻塞影响 IO）；
架构：epoll（IO 事件管理）+ 线程池（业务处理）+ 非阻塞 IO（ET 模式）。


中高并发（万级连接）：「IO 多路复用（epoll&#x2F;poll）+ 有限线程」；
低并发（千级以下）：「BIO + 线程池」（开发简单，无需复杂 IO 管理）。

高并发的优化策略
百万级并发（如 Web 服务器、即时通讯）：优先选「IO 多路复用（epoll）+ 线程池」；
原因：epoll 单线程处理百万级 FD，线程池处理 IO 就绪后的业务逻辑（避免单线程业务阻塞影响 IO）；
架构：epoll（IO 事件管理）+ 线程池（业务处理）+ 非阻塞 IO（ET 模式）。


中高并发（万级连接）：「IO 多路复用（epoll&#x2F;poll）+ 有限线程」；
低并发（千级以下）：「BIO + 线程池」（开发简单，无需复杂 IO 管理）。

]]></content>
      <categories>
        <category>C++</category>
        <category>9. 网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络</tag>
        <tag>IO模型</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>核心问题与机制</title>
    <url>/posts/739aa5fc.html</url>
    <content><![CDATA[
字节序转换：
主机字节序（小端 &#x2F; 大端）vs 网络字节序（大端）
转换函数：htons()&#x2F;ntohs()（短整型）、htonl()&#x2F;ntohl()（长整型）


TCP粘包
原因：流式传输，数据无边界，可能合并 &#x2F; 拆分
解决方法：固定长度、长度前缀（如 4 字节存长度）、分隔符


UDP数据报
读写函数：sendto()（指定目标地址）、recvfrom()（获取源地址）
特点：无粘包，可能丢包，数据报大小有限制



TCP粘包与半包问题
TCP是“字节流协议”（无消息边界），多个数据包可能被合并发送（粘包），或一个数据包被拆分发送（半包），导致接收方无法正确解析消息。

问题成因粘包
TCP的Nagle算法（默认开启）会合并小数据包（减少网络交互），导致多个小消息被合并为一个TCP报文。
接收方缓冲区未及时读取，后数据包被加入缓冲区，形成粘包。

半包
发送的消息长度超过TCP MSS（最大报文段长度），TCP会拆分消息为多个报文。
接收方缓冲区大小不足，只能读取部分数据，剩余数据留在缓冲区（形成半包）

解决方案
核心思路：在应用层定义消息边界，让接收方知道“一个完整消息的开始和结束”。
方案1：固定长度消息
约定每个消息的长度固定，接收方每次读取固定长度，不足则补0
优点：实现简单；缺点：灵活性差（消息长度不确定时浪费带宽）


方案2：分隔符标记
用特殊字符（如\r\n）作为消息结束标记，接收方读取到分隔符即认为一个消息结束 。
优点：灵活；缺点：需处理“消息内容中包含分隔符”的情况


方案3：消息头+消息体（最常用）
消息头分为两部分：固定长度的 “消息头”（存储消息体长度，如 4 字节表示长度）+“消息体”（实际数据）。
接收流程：先读消息头-&gt;解析出消息体长度-&gt;再读对应长度的消息体。



并发连接处理
服务器需同时处理大量客户端连接（如 Web 服务器），低效的并发模型会导致性能瓶颈。重点考察并发模型的选择与原理。

常见并发模型及对比模型 1：多线程 &#x2F; 多进程（每连接一线程 &#x2F; 进程）
原理：服务器为每个客户端连接创建一个线程&#x2F;进程，单独处理读写。
优点：实现简单（无需考虑共享状态）
缺点：资源开销大（线程&#x2F;进程创建、切换成本高），支持的并发数有限（如几千连接）
适用场景：连接数少、逻辑复杂的场景（如数据库连接）

模型2：I&#x2F;O 多路复用（select&#x2F;poll&#x2F;epoll&#x2F;kqueue）
原理：单个线程通过“事件通知”机制管理多个连接，仅在连接有数据可读&#x2F;可写时处理（非阻塞）。
核心函数：
select&#x2F;poll：轮询所有注册的连接，效率随连接数增加而下降（O(n)）
epoll(Linux)&#x2F;lqueue(BSD)：事件驱动，仅通知有事件的连接，效率高（O(1)），支持百万级连接。


优点：资源开销低，支持高并发
缺点：逻辑复杂（需处理非阻塞I&#x2F;O和事件循环）
适用场景：高并发场景（如Web服务器、即使通讯）

模型3：线程池&#x2F;进程池
原理：预先创建固定数量的线程&#x2F;进程，新连接分配给空闲线程处理，避免频繁创建销毁
优点：平衡资源开销与并发能力
缺点：线程数固定，极端情况可能瓶颈（需动态调整线程数）

epoll的核心优势
事件驱动而非轮询：epoll通过回调机制记录就绪连接，无需遍历所有连接；
共享内存：epoll的文件描述符（fd）集合存储在内核，避免用户态与内核态的频繁拷贝；
支持边缘触发（ET）和水平触发（LT）：
LT（默认）：只要缓冲区有数据，就持续通知（易用，不会漏数据）；
ET：仅在数据到来时通知一次（需一次性读完缓冲区，效率更高）。



连接可靠性保障（超时、心跳与重连）
网络不稳定（如断网、防火墙拦截）会导致连接 “假死”（双方认为连接有效，但实际已不可用），需通过机制检测并恢复。

超时处理
问题：recv&#x2F;send默认阻塞，若连接异常，可能永久阻塞线程。
解决方案：
用setsockopt设置Socket超时（SO_RCVTIMEO&#x2F;SO_SNDTIMEO)
结合select&#x2F;epoll的超时参数（如epoll_wait的超时时间），避免永久等待。



心跳机制（检测连接存活）
原理：定期发送“心跳包”（空包或固定格式消息），若超过一定次数未收到回应，判定连接失效。
实现方式：
应用层心跳：在业务协议中加入心跳包（如每 30 秒发送一次，5 秒未回应则断连）
TCP keeplive（底层心跳）：通过setsockopt开启，内核定期发送探测包（默认超时较长，需调整参数）。


优点：主动发现死连接，避免资源浪费。

断连重连机制（客户端）
原理：客户端检测到连接断开后，按策略重新连接服务器。
重连策略：
指数退避：重连间隔逐渐增加（如 1s→2s→4s→8s，上限 60s），避免频繁重试冲击服务器。
限制重试次数：超过最大次数后报警（如网络彻底故障）。



数据序列化与反序列化（跨平台传输）
网络传输的字节流，需将内存中的对象（如结构体、类）转换为字节流（序列化），接收方再还原为对象（反序列化）。

核心要求
跨平台兼容性（如大小端、数据类型长度差异）
效率（序列化&#x2F;反序列化速度、字节流大小）
可读性（调试友好）

常见方案方案1：自定义二进制格式
原理：手动按固定格式打包&#x2F;解析（如用htonl&#x2F;ntohl处理大小端）
优点：紧凑高效；缺点：开发复杂，兼容性差（需严格统一格式）

方案2：JSON&#x2F;XML（文本格式）
原理：用文本标记数据结构
优点：可读性好，跨平台；缺点：冗余大（字节流长），解析效率低

方案3：Protobuf&#x2F;FlatBuffers（二进制协议）
原理：通过 IDL 定义数据结构，自动生成序列化代码（二进制格式）。
优点：效率高（二进制 + 压缩），兼容性强（支持版本兼容）；缺点：可读性差（需工具解析）。
适用场景：高性能场景（如游戏、分布式系统）。

网络安全与攻击防护
SYN 洪水攻击：攻击者发送大量SYN报文但不完成三次握手，耗尽服务器连接资源。
防护：开启 SYN Cookie（服务器不维护半连接队列，用 Cookie 验证请求合法性）。


数据传输加密：避免明文被窃听，用 SSL&#x2F;TLS 协议（如 HTTPS）对传输数据加密。
端口扫描防护：限制异常 IP 的连接频率（如用防火墙或应用层限流）。

]]></content>
      <categories>
        <category>C++</category>
        <category>9. 网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络</tag>
        <tag>问题</tag>
        <tag>机制</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/posts/91149a63.html</url>
    <content><![CDATA[
协议栈：TCP&#x2F;IP四层模型（应用层、传输层、网络层、数据链路层）
TCP与UDP对比




维度
TCP
UDP



连接性
面向连接（三次握手）
无连接


可靠性
可靠（重传、确认）
不可靠（无重传）


传输速率
低（确认、重传等开销）
高（无额外开销）


数据形式
流式（无边界）
数据报（有边界）


拥塞控制
有（避免网络过载）
无（可能导致网络拥塞）


适用场景
文件传输、HTTP
实时通信（视频 &#x2F; 语音）


TCP与UDPTCP（传输控制协议）
面向连接：通信前需通过 “三次握手” 建立连接，结束后通过 “四次挥手” 断开连接。
可靠传输：通过 “确认重传”（丢失数据重传）、“序列号”（保证有序）、“滑动窗口”（流量控制）、“拥塞控制”（避免网络过载）确保数据不丢、不重、有序。
字节流：数据被视为连续的字节序列，无边界（需应用层自行处理数据分割）。
适用场景：对可靠性要求高，允许延迟（如文件传输、网页加载、邮件）。典型协议：HTTP、FTP、SMTP。

UDP（用户数据报协议）
无连接：通信前无需建立连接，直接发送数据（类似 “发快递不提前打招呼”）。
不可靠：不保证数据到达、有序，无重传机制（丢包由应用层处理）。
数据报：数据有明确边界（每次发送都是独立的 “报文”），接收方一次接收一个完整报文。
适用场景：对实时性要求高，可容忍少量丢包（如视频通话、语音聊天、直播、DNS 查询）。典型协议：RTP（实时传输）、DNS。

三次握手与四次挥手三次握手（建立连接）
目的：确保双方的 “发送” 和 “接收” 能力正常，协商初始序列号（避免历史报文干扰）。
过程（客户端→服务器）：


第一次握手：客户端发送SYN报文（同步请求），携带客户端初始序列号seq = x。
第二次握手：服务器收到SYN，回复SYN+ACK报文（同步 + 确认），携带服务器初始序列号seq = y，确认号ack = x + 1（表示已收到客户端的x）。
第三次握手：客户端收到SYN+ACK，回复ACK报文，确认号ack = y + 1（表示已收到服务器的y）。


完成后，双方确认彼此收发正常，连接建立。

问答
为什么需要三次握手？
避免 “过期的连接请求” 被服务器误接收。例如，客户端的旧 SYN 报文因网络延迟到达服务器，服务器若直接建立连接（两次握手），会导致服务器资源浪费；三次握手时，客户端会通过第三次 ACK 确认是否为有效请求，无效则不回复，服务器超时后释放资源。



四次挥手（断开连接）
目的：TCP 是 “全双工” 通信（双方可同时发送数据），需双方分别关闭各自的发送通道。
过程（假设客户端先发起关闭）：


第一次挥手：客户端发送FIN报文（终止请求），表示客户端不再发送数据，seq = u。
第二次挥手：服务器收到FIN，回复ACK报文，确认号ack = u + 1，表示已收到关闭请求，但服务器可能还有数据要发送，此时客户端→服务器的通道关闭。
第三次挥手：服务器数据发送完毕，发送FIN报文，seq = v，表示服务器不再发送数据。
第四次挥手：客户端收到FIN，回复ACK报文，确认号ack = v + 1，此时服务器→客户端的通道关闭。

问答
为什么需要四次挥手？
因为 TCP 是全双工，双方需各自关闭发送通道。第二次挥手是服务器确认收到客户端的关闭请求（但自身可能还在发送数据），第三次挥手才是服务器真正关闭发送通道，因此需要四次交互。



TIME_WAIT 状态
客户端发送第四次挥手的ACK后，会进入TIME_WAIT状态（默认 2MSL，MSL 是报文最大生存时间），目的：
确保服务器能收到第四次挥手的ACK（若服务器未收到，会重发FIN，客户端在TIME_WAIT内可重传ACK）。
避免客户端新连接收到旧连接的残留报文（2MSL 足够让网络中旧报文失效）。



Socket：网络编程的接口
Socket（套接字）是操作系统提供的网络编程接口，封装了 TCP&#x2F;UDP 的底层细节，让开发者无需直接操作协议栈。

Socket的本质
Socket 由 “IP 地址 + 端口号” 唯一标识（如(192.168.1.1, 8080)），是进程间通信的端点。通过 Socket，应用程序可调用bind（绑定端口）、listen（监听连接）、connect（发起连接）、send/recv（发送 &#x2F; 接收数据）等接口实现网络通信。

TCP Socket编程流程
服务器端：
socket()：创建 Socket（指定 TCP 协议）。
bind()：绑定 IP 和端口（让客户端知道如何连接）。
listen()：进入监听状态（设置最大连接队列）。
accept()：阻塞等待客户端连接，返回新的 Socket（用于与该客户端通信）。
recv()/send()：与客户端收发数据。
close()：关闭 Socket，断开连接。


客户端：
socket()：创建 Socket。
connect()：向服务器发起连接（三次握手在此完成）。
send()/recv()：与服务器收发数据。
close()：关闭 Socket（四次挥手在此完成）。



]]></content>
      <categories>
        <category>C++</category>
        <category>9. 网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/comments/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
