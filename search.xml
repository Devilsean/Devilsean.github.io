<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>共白头</title>
    <url>/posts/9a70fb8f.html</url>
    <content><![CDATA[       共白头  忽有故人心上过，回首山河已入冬。 他朝若是同淋雪，此生也算共白头。 白头若是雪可替，世间何来伤心人。 此时若有君在侧，何须淋雪作白头。   
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>函数基础</title>
    <url>/posts/1111c3f5.html</url>
    <content><![CDATA[核心要点速览
声明与定义：可多次声明，仅能一次定义；原型需匹配参数类型 &#x2F; 个数（返回类型不影响）
参数传递：值传递（拷贝，不影响实参）、引用传递（别名，无拷贝）、指针传递（地址，支持 nullptr）
函数重载：同名 + 参数列表不同（类型 &#x2F; 个数 &#x2F; 顺序），返回类型不参与重载
内联函数：inline 修饰，建议编译器嵌入调用处（适合短函数，无循环 &#x2F; 递归）
默认参数：遵循 “靠右原则”，不可跳过右侧参数省略左侧
返回值：禁止返回局部变量引用；大型对象返回有 RVO&#x2F;NRVO 优化


一、函数的声明与定义核心概念
声明：告知编译器函数的 “存在及原型”（返回类型、函数名、参数类型 &#x2F; 个数），不包含实现；参数名可选（仅声明时）。
用途：解决 “调用在前、定义在后” 的编译错误，如int add(int, int);


定义：包含声明 + 函数体（具体实现），编译器会分配内存生成指令。

关键规则
单定义原则（ODR）：一个函数可在多个文件中声明，但仅能在一个文件中定义（否则链接报错 “重复定义”）。
原型匹配：声明与定义的参数类型、个数必须一致；返回类型可省略（默认 int，不推荐），但建议显式声明。


二、参数传递参数传递决定函数与实参的交互方式，核心分三类，重点考察适用场景与区别。
1. 值传递
核心规则：形参是实参的拷贝，函数内修改形参不影响实参。

优点：安全（隔离实参）、逻辑简单。

缺点：大对象拷贝开销大（如大型结构体、类对象）。

示例：
  void swap(int a, int b) &#123; int t=a; a=b; b=t; &#125; // 仅交换拷贝，实参不变int x=1, y=2; swap(x,y); // x=1, y=2（实参未变）

2. 引用传递（int&amp;）
核心规则：形参是实参的别名，无拷贝开销；函数内修改形参直接影响实参。

优点：效率高（无拷贝）、语法简洁、可修改实参。

约束：引用必须绑定实参（不能传字面量，如func(5)报错），绑定后不可更改指向。

示例：
  void swap(int&amp; a, int&amp; b) &#123; int t=a; a=b; b=t; &#125;int x=1, y=2; swap(x,y); // x=2, y=1（实参已交换）

3. 指针传递（int*）
核心规则：形参是实参的地址拷贝，通过解引用（*p）间接修改实参。

优点：可修改实参，支持传递nullptr（空值语义）。

缺点：需显式解引用（易漏写*），可能出现野指针（未初始化指针）。

示例：
  void swap(int* a, int* b) &#123; int t=*a; *a=*b; *b=t; &#125;int x=1, y=2; swap(&amp;x,&amp;y); // x=2, y=1（通过地址修改）

三类传递方式对比表


对比维度
值传递
引用传递
指针传递



内存开销
拷贝实参（大对象开销大）
无拷贝（仅别名）
拷贝地址（4&#x2F;8 字节，固定）


实参修改
不可修改
可直接修改
可修改（需解引用）


空值传递
不支持
不支持（必须绑定对象）
支持（传nullptr）


适用场景
小对象、无需修改实参
大对象、需修改实参
需 “空值” 语义的场景


语法复杂度
简单（直接传值）
简洁（传变量名）
复杂（传地址 + 解引用）



三、返回值1. 返回值类型与规则
基本类型（int&#x2F;double等）：直接返回值拷贝，无额外风险。
自定义类型（类 &#x2F; 结构体）：返回对象副本，编译器可能触发返回值优化（RVO&#x2F;NRVO） ，避免临时对象拷贝。
引用返回（&amp;）：
优点：无拷贝，效率高（适合大对象）。

禁忌：禁止返回局部变量的引用（局部变量生命周期随函数结束，引用变为 “悬垂引用”，访问即未定义行为）。

示例（错误）：
int&amp; func() &#123; int x=10; return x; &#125; // x是局部变量，函数结束后销毁int&amp; res = func(); // 悬垂引用，访问res可能崩溃





2. 特殊返回值：void
表示 “无返回值”，函数体中可省略return，或用return;提前结束。
限制：不能定义void类型变量（void x;报错）；可定义void*指针（指向任意类型，需强转后使用）。

3. 返回值优化（RVO&#x2F;NRVO）
概念：编译器对 “返回大型对象” 的优化，直接在调用处构造对象，避免函数返回时的临时对象拷贝。
特点：无需手动修改代码，编译器自动触发（主流编译器均支持），显著提升大型对象返回效率。


四、函数重载核心定义同一作用域中，函数名相同但参数列表不同，用于实现 “同一功能的不同参数版本”。
重载的条件（缺一不可）
同一作用域（如同一命名空间、同一类）。
函数名完全相同。
参数列表不同（满足任一即可）：
参数类型不同（如add(int, int) vs add(double, double)）；
参数个数不同（如add(int) vs add(int, int)）；
参数顺序不同（如func(int, double) vs func(double, int)）。


补充场景（易忽略）：
参数为引用 &#x2F; 指针时，const修饰可形成重载（如func(int&amp;) vs func(const int&amp;)）；
类的成员函数中，const修饰this指针可形成重载（如void show() vs void show() const）。



重载的排除条件
返回类型不同不能形成重载（如int add(int) vs double add(int)，编译报错）；
参数名不同不能形成重载（如add(int a) vs add(int b)，视为同一函数）。

重载决议（编译器匹配逻辑）编译器按 “实参与形参的匹配度” 选择最佳函数，匹配度从高到低：

精确匹配（类型完全一致，含const匹配）；
提升转换（如char→int、float→double）；
标准转换（如int→double、int*→void*）；
用户定义转换（如类的构造函数、运算符重载）。


若匹配度相同（歧义），编译报错（需显式类型转换解决）。


五、内联函数（inline）核心特性
作用：建议编译器将函数体 “嵌入” 调用处（而非生成函数调用指令），减少栈帧创建 &#x2F; 销毁的开销。
建议性：inline是编译器 “建议”，非强制 —— 若函数含循环、递归、复杂分支，编译器会忽略inline，按普通函数处理。
定义即声明：内联函数需在调用前定义（不能仅声明），通常放在头文件中（方便多个编译单元包含）。
避免重复定义：允许在多个编译单元中定义，但所有定义必须完全一致（否则链接报错）。

与宏（#define）的区别（面试高频）


对比维度
内联函数（inline）
宏（#define）



类型检查
有（编译期校验参数类型）
无（文本替换，无类型校验）


调试支持
支持（可打断点、查看变量）
不支持（替换后无宏信息）


复杂逻辑支持
支持（循环、分支等）
不适合（易因优先级出错）


作用域
受作用域限制（如局部内联）
全局替换（无作用域）


副作用风险
低（参数仅计算一次）
高（参数可能多次计算）



六、默认参数核心规则
靠右原则：默认参数必须从右往左连续指定，不能跳过右侧参数省略左侧参数。

示例（正确 vs 错误）：
  void func(int a, int b=2, int c=3); // 正确（从右往左指定）func(1); // 等价于func(1,2,3)func(1,4); // 等价于func(1,4,3)// func(,4,5); // 错误（跳过左侧a，未指定默认值）

声明与定义一致性：默认参数仅需在声明或定义中指定一次（建议在声明中指定，方便外部调用者查看）。


]]></content>
      <categories>
        <category>C++</category>
        <category>2. 函数与指针</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>函数</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型与变量</title>
    <url>/posts/52c049c7.html</url>
    <content><![CDATA[核心要点速览
数据类型分类：基本类型、复合（派生）类型、自定义类型
核心复合类型：指针、引用、数组、结构体、联合体、枚举
变量关键特性：存储类别（auto&#x2F;static&#x2F;extern 等）、初始化要求、作用域与生命周期
常量核心：const（只读）、constexpr（编译期常量）
类型转换：隐式转换（编译器自动）、显式转换（四种强制转换）


一、数据类型1.1 基本类型基本类型是 C++ 内置的基础数据类型，具有固定内存大小（部分受平台影响）和明确取值范围。



类型
典型大小（32&#x2F;64 位系统）
含义 &#x2F; 范围
面试考点



bool
1 字节
布尔值：true（1）&#x2F;false（0）
sizeof(bool)恒为 1；不可用 0 &#x2F; 非 0 代替（语法允许但不规范）


char
1 字节
ASCII 码：-128127 或 0255
区分signed char（带符号）和unsigned char（无符号）；默认符号性由编译器决定


short
2 字节
短整数：-32768~32767
与short int等价；用于节省内存


int
4 字节（通用）
整数：-2³¹~2³¹-1
平台无关性（主流编译器统一 4 字节）；计数、返回值首选类型


long
4 字节（32 位）&#x2F;8 字节（64 位）
长整数：随平台变化
避免依赖其大小，优先用固定宽度类型（如int64_t）


long long
8 字节
超长整数：-2⁶³~2⁶³-1
C++11 标准，跨平台 8 字节，适合大整数


float
4 字节
单精度浮点：有效数字 6-7 位
精度低；避免直接比较（存在误差）


double
8 字节
双精度浮点：有效数字 15-17 位
默认浮点类型（如3.14是 double）；科学计算首选


void
无大小
无类型（表示 “空”）
用于无返回值函数、void*指针（可指向任意类型）


关键补充
跨平台一致性保证：使用 C++11 固定宽度类型（定义于&lt;cstdint&gt;），如int32_t（32 位带符号）、uint64_t（64 位无符号）。
sizeof计算规则：sizeof(char)恒为 1；sizeof(int)通常 4 字节；sizeof(void)编译报错；sizeof(bool)始终为 1。

1.2 复合类型（派生类型）基于基本类型或自定义类型扩展，核心用于组合、关联或间接访问数据。
指针
存储目标变量的内存地址，大小仅与系统位数相关（32 位 4 字节，64 位 8 字节，与指向类型无关）。
核心特性：
未初始化指针为野指针（指向随机地址，操作易崩溃），需避免。
nullptr（C++11）：空指针常量，替代NULL（NULL本质是 0，易引发歧义）。
指针运算：仅对数组指针有效（p++步长为指向类型的大小）。
数组名本质：指向数组首元素的常量指针（不可修改指向）。



引用
变量的 “别名”，语法：类型&amp; 引用名 = 变量名，必须初始化且绑定后不可更改。




对比项
指针
引用



定义
可空（nullptr）
不可空（必须绑定变量）


指向修改
可重新指向其他变量
绑定后不可更改


初始化
可延迟初始化（风险高）
必须定义时初始化


内存占用
占内存（存储地址）
不占额外内存（编译器优化）


核心用途
动态内存管理、多级间接访问
函数参数 &#x2F; 返回值（避免拷贝）、简化代码


结构体（Struct）
组合多个不同类型数据（成员）为一个整体，成员按顺序占用独立内存。
核心特性：结构体大小 &#x3D; 成员大小之和 + 内存对齐填充字节。
用途：存储关联数据（如个人信息：姓名、年龄、身高）。

联合体（Union）
所有成员共享同一块内存，同一时间仅能有效使用一个成员。




对比项
结构体（Struct）
联合体（Union）



内存分配
成员独立占用内存，总大小 &#x3D; 成员和 + 填充
成员共享内存，总大小 &#x3D; 最大成员大小（+ 对齐填充）


成员关系
成员并存（可同时访问）
成员互斥（同一时间仅能用一个）


核心用途
组合关联数据
节省内存、实现类型转换


枚举（Enum）
自定义整数类型，用于组合含义相关的命名常量。
分类：
传统枚举：enum E {A, B=5, C};，成员作用域全局（易冲突），可隐式转 int。
强类型枚举（C++11 推荐）：enum class E {A, B};，作用域受限（需E::A访问），不可隐式转 int（更安全）。


赋值规则：未手动赋值时，首个常量为 0，后续依次 + 1；中间赋值后，后续常量基于该值递增。

1.3 自定义类型
由用户通过class（类）、struct（结构体）、enum（枚举）等关键字定义的类型。
核心作用：封装数据与行为，提升代码可读性和复用性。


二、变量2.1 变量的定义与初始化
定义：编译器为变量分配内存空间。

初始化：定义时赋予初始值（避免 “垃圾值”，提升代码安全性）。

常见初始化方式：
  int a = 10;    // 拷贝初始化int b(20);     // 直接初始化（适合构造函数场景）int c&#123;30&#125;;     // 列表初始化（C++11，禁止窄化转换，如int&#123;3.14&#125;编译报错）int d = &#123;40&#125;;  // 拷贝列表初始化

2.2 存储类别（关键字修饰）存储类别决定变量的生命周期、作用域和存储位置。



关键字
核心特性与用途



auto（C++11）
编译器自动推导类型；不能用于函数参数（模板除外）、数组类型；推导引用需显式加&amp;


static
局部静态变量：生命周期为程序全程，首次调用初始化；全局静态变量：仅当前.cpp 可见（避免命名冲突）；类静态成员：属于类，所有对象共享


extern
声明变量 &#x2F; 函数在其他文件定义（跨文件共享）；仅声明不分配内存，带初始化则变为定义


register
提示编译器存于寄存器（C++17 后弃用，现代编译器优化足够）


mutable
仅用于类非静态成员；允许 const 成员函数修改该变量（突破 const 限制）


volatile
禁止编译器优化；变量值可能被外部因素修改（如硬件、多线程），每次访问直接读内存


2.3 常见问题解答
局部变量屏蔽全局变量时如何访问全局变量？用::（全局作用域解析符），如::global_var。
全局变量与局部static变量的初始化顺序？全局变量在main前初始化，局部static变量首次进入函数时初始化（C++11 后线程安全）；销毁顺序与初始化相反。
未初始化的局部变量和全局变量区别？局部非static变量是 “垃圾值”；全局变量和static变量会零初始化（数值为 0，指针为nullptr）。

2.4 常量常量是初始化后不可修改的变量，核心分为const和constexpr。
const（只读常量）
修饰变量：初始化后不可修改，作用域与变量一致。

修饰指针（三大场景）：
  const int* p;    // 常量指针：指向的内容不可改（*p不可改），p可改指向int* const p;    // 指针常量：p的指向不可改，*p可改const int* const p;  // 指向常量的指针常量：内容和指向均不可改

constexpr（编译期常量，C++11）
要求表达式在编译期可计算，比const更严格（const可运行期初始化）。
用途：定义数组大小、模板参数等依赖编译期常量的场景。

2.5 类型转换隐式转换（自动转换）
遵循 “安全优先” 原则，优先 “小范围→大范围”（类型提升），避免溢出。
转换顺序：bool→char→short→int→long→long long→float→double→long double。
注意：explicit关键字可禁止类的隐式类型转换。

显式转换（四种强制转换）


转换方式
核心用途
风险程度



static_cast
基本类型转换（int→double）、父类 &#x2F; 子类指针转换（无动态检查）
中等（父类→子类可能越界）


dynamic_cast
多态类型转换（仅用于含虚函数的类），运行期检查有效性
低（失败返回nullptr&#x2F; 抛异常）


const_cast
移除指针 &#x2F; 引用的const属性
高（修改原const变量会导致未定义行为）


reinterpret_cast
底层二进制重解释（如int*→char*）
极高（依赖平台，无移植性）


关键问题
何时用dynamic_cast？多态场景下，需将父类指针安全转为子类指针（需父类有虚函数，运行期校验合法性）。
为何避免reinterpret_cast？直接操作二进制，忽略类型安全，结果依赖平台，移植性极差。

]]></content>
      <categories>
        <category>C++</category>
        <category>1. 基础语法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>变量</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>指针与引用</title>
    <url>/posts/eed757dd.html</url>
    <content><![CDATA[核心要点速览
指针：存储内存地址的变量，支持空值（nullptr）、动态指向、多级访问，存在野指针风险
引用：变量的别名，必须初始化、不可改指向、无空引用，语法简洁安全
访问效率：两者基本一致
适用场景：需空值 &#x2F; 动态指向 &#x2F; 多级访问用指针；需简洁语法 &#x2F; 确保有效 &#x2F; 避免误操作引用


一、指针指针本质是 “存储内存地址的变量”，支持对内存的间接访问。
1. 关键类型与特性（1）野指针
定义：未初始化、已释放或越界访问的指针（指向随机 &#x2F; 无效内存）。

风险：访问野指针会导致内存错误（崩溃、数据错乱），是常见 bug 来源。

示例（错误）：
  int* p; // 未初始化，野指针*p = 10; // 未定义行为（访问随机内存）

规避：指针定义时立即初始化（如int* p = nullptr;），释放后及时置空（p = nullptr;）。


（2）空指针（nullptr）
定义：C++11 标准的空指针常量，替代旧版NULL（NULL本质是0，易引发歧义）。

用途：表示指针 “无指向”，避免野指针，可通过条件判断安全使用。

示例：
  int* p = nullptr;if (p == nullptr) &#123; // 安全判断空指针    // 避免无效访问&#125;

（3）函数指针
定义：指向函数的指针，语法：返回类型 (*指针名)(参数类型列表)。

核心用途：作为函数参数 &#x2F; 返回值，实现回调函数（如排序算法中的比较器）。

示例：
  // 目标函数：两数相加int add(int a, int b) &#123; return a + b; &#125;int main() &#123;    int (*func_ptr)(int, int) = add; // 函数指针指向add    int res = func_ptr(3, 5); // 调用：res=8（等价于(*func_ptr)(3,5)）    return 0;&#125;

（4）指针数组与数组指针（面试必考区分）核心原则：[]优先级高于*，()可提升*的优先级，需通过语法结构判断本质。



类型
语法格式
核心逻辑（优先级分析）
示例



指针数组
类型* 数组名[数组长度];
[]优先级高，先构成数组，元素是指针
int* arr[3];（3 个 int * 指针的数组）


数组指针
类型 (*指针名)[数组长度];
()提升*优先级，先是指针，指向 “固定长度的数组”
int (*p)[3];（指向含 3 个 int 的数组）



示例解析：
  int a[3] = &#123;1,2,3&#125;;int* arr[3]; // 指针数组：每个元素是int*，可指向不同int变量int (*p)[3] = &amp;a; // 数组指针：p指向整个数组a，*p等价于a（数组首地址）

2. 指针的核心操作
解引用：*p，访问指针指向的变量值。
取地址：&amp;变量，获取变量的内存地址，赋值给指针。
算术运算：仅对 “指向数组的指针” 有意义，步长 &#x3D; 指向类型的大小（如int* p，p++移动 4 字节）。


二、引用引用本质是 “变量的别名”，语法上无独立内存（编译器通常用指针实现，但对外隐藏细节），核心优势是简洁安全。
1. 核心特性
必须初始化：定义时必须绑定已存在的变量（无空引用），否则编译报错。
 int a = 10;int&amp; r = a; // 正确：绑定变量a// int&amp; r; // 错误：未初始化// int&amp; r = nullptr; // 错误：无空引用

不可改指向：绑定后无法切换到其他变量，赋值操作是修改 “绑定变量的值”。
 int b = 20;r = b; // 不是更改绑定，而是将a的值改为20（a=20，r仍绑定a）

内存特性：sizeof(r) = sizeof(原变量)（无额外内存开销）。
 cout &lt;&lt; sizeof(r); // 4字节（与int类型大小一致）

2. 核心应用（1）函数参数（避免拷贝 + 修改实参）
替代指针，语法更简洁，无野指针风险，适合大对象传递（无拷贝开销）。

示例：
  void update(int&amp; x) &#123; x *= 2; &#125;int a = 5;update(a); // a=10（直接修改实参）

（2）函数返回值（避免拷贝）
可返回 “全局变量、静态变量、类成员变量” 的引用（生命周期长于函数），避免返回对象的拷贝开销。

禁忌：禁止返回局部变量的引用（函数结束后局部变量销毁，引用变为悬垂引用）。

示例（正确）：
  int g_val = 10;int&amp; get_global() &#123; return g_val; &#125; // 返回全局变量引用，安全

示例（错误）：
  int&amp; get_local() &#123;    int x = 20;    return x; // 错误：x是局部变量，函数结束后销毁&#125;


三、本质区别
指针：独立的变量，存储目标变量的内存地址（占用 4&#x2F;8 字节内存，与系统位数相关）。
引用：非独立变量，是目标变量的 “别名”（语法层面无独立内存，编译器通常用指针实现，但对外隐藏指针操作）。


四、核心特性对比表


对比特性
指针（Pointer）
引用（Reference）



初始化
可延迟初始化（但未初始化是野指针）
必须定义时初始化，且绑定已存在变量


指向可修改性
可重新指向其他变量（p = &amp;b; 合法）
绑定后不可更改指向（r = b; 是修改原变量值）


空值支持
支持（int* p = nullptr;）
无空引用（必须绑定有效变量）


解引用操作
需显式用 *（*p = 10;）
无需解引用（r = 10; 直接修改绑定变量）


算术运算
支持（步长 &#x3D; 指向类型大小）
不支持（非独立对象，无地址可运算）


多级嵌套
支持（int** p 指向指针的指针）
不支持（int&amp;&amp; r 是右值引用，非 “引用的引用”）


语法复杂度
较高（需关注*&#x2F;&amp;&#x2F; 空指针 &#x2F; 野指针）
较低（简洁直观，无指针操作风险）



五、补充知识点1. 作为函数参数的传递机制（1）指针传参
本质：“值传递地址”—— 函数接收的是实参地址的拷贝，修改指针本身（如p = &amp;b;）不影响实参指针；但修改指针指向的内容（*p = 10;）会影响实参变量。

示例：
  void func(int* p) &#123;    *p = 20; // 影响实参变量（修改指向的内容）    p = nullptr; // 不影响实参指针（仅修改拷贝）&#125;int a = 10;int* ptr = &amp;a;func(ptr); // a=20，ptr仍指向a（未变）

（2）引用传参
本质：传递 “变量别名”—— 函数内修改引用（r = 20;）直接修改实参；且无法修改引用的指向（语法禁止）。

2. 返回值的 “悬垂问题”
指针与引用的共同禁忌：禁止返回局部变量（生命周期随函数结束而销毁）。
返回局部变量的指针：得到野指针（指向已释放内存），访问即未定义行为。
返回局部变量的引用：得到悬垂引用（绑定已销毁变量），访问即未定义行为。



3. const 修饰（面试高频）（1）const 修饰指针（左定值，右定向）
核心口诀：const 靠近谁，就限制谁 —— 左定值（限制指向的内容不可改），右定向（限制指针本身不可改）。
  const int* p; // 常量指针（左定值）：指向的内容不可改（*p不能赋值），指针可改指向int* const p; // 指针常量（右定向）：指针本身不可改指向，指向的内容可改（*p可赋值）const int* const p; // 指向常量的指针常量：内容和指向均不可改

（2）const 引用（const T&amp;）
核心特性：不可通过引用修改绑定变量，但变量本身可被其他方式修改。

关键用途：可绑定临时对象（字面量、表达式结果），常用于函数参数（接收任意类型参数，避免拷贝）。

示例：
  const int&amp; r1 = 10; // 合法：const引用绑定字面量（临时对象）const int&amp; r2 = 3 + 4; // 合法：绑定表达式结果int a = 5;const int&amp; r3 = a;// r3 = 10; // 错误：const引用不可修改绑定变量a = 10; // 合法：变量本身可通过其他方式修改（r3的值同步变为10）

]]></content>
      <categories>
        <category>C++</category>
        <category>2. 函数与指针</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>数组基础</title>
    <url>/posts/c24002d9.html</url>
    <content><![CDATA[核心要点速览
数组名：本质是首元素地址，仅 3 种场景不退化（sizeof、&amp; 数组名、decltype）
数组传参：一维退化为指针（丢失长度），二维必须指定第二维长度
C 风格字符串：以&#39;\0&#39;结尾的字符数组，strlen 与 sizeof 计算逻辑不同
数组 vs vector：数组编译期定长、手动管理内存；vector 动态扩容、自动管理


一、数组名与指针数组名的核心特性：通常等价于首元素地址，但以下 3 种场景不退化（保留数组类型特性）。
1. 数组名不退化的 3 种场景
sizeof(数组名)：计算整个数组的字节总大小（而非指针大小）。
&amp;数组名：获取指向 “整个数组” 的指针（类型为数组类型(*)[长度]，而非首元素指针）。
decltype(数组名)：推导为数组类型（如decltype(arr)为int[5]，而非int*）。

2. 易错点补充
区分&amp;数组名与&amp;数组首元素：
  int arr[5] = &#123;1,2,3,4,5&#125;;&amp;arr;    // 类型为int(*)[5]（指向整个数组的指针），+1偏移5个int（20字节）&amp;arr[0]; // 类型为int*（指向首元素的指针），+1偏移1个int（4字节）


二、数组作为函数参数数组传参时必然退化为指针，丢失原数组长度信息，需手动传递长度参数。
1. 一维数组传参（3 种写法）// 写法1：数组形式（[]内数字无意义，仅为语法兼容）void func1(int arr[5]) &#123; ... &#125;// 写法2：省略长度的数组形式（等价于int* arr）void func2(int arr[]) &#123; ... &#125;// 写法3：显式指针形式（最直观，推荐）void func3(int* arr) &#123; ... &#125;

2. 二维数组传参
核心规则：二维数组退化后是 “指向一维数组的指针”，编译器需通过第二维长度计算步长，因此第二维长度不可省略。

// 正确写法：第二维长度3必须指定void func(int mat[][3], int rows) &#123; ... &#125;// 错误写法：第二维长度省略（编译器无法确定元素访问步长）void func(int mat[][], int rows, int cols) &#123; ... &#125; // 编译报错

3. 关键提醒
函数内无法通过sizeof(arr)获取原数组长度（此时 arr 已退化为指针，sizeof(arr)为 4&#x2F;8 字节）。
必须显式传递长度参数（如func(arr, 5)），或通过其他方式（如数组结尾标记）获取长度。


三、字符串与字符数组（C 风格）
本质：以&#39;\0&#39;（空字符）结尾的字符数组，&#39;\0&#39;是字符串结束标记（编译器在字符串常量后自动填充）。

1. 核心区别：strlen vs sizeof
strlen(str)：计算&#39;\0&#39;之前的字符个数（不包含&#39;\0&#39;）。
sizeof(str)：计算整个字符数组的字节大小（包含&#39;\0&#39;和未使用的空间）。

2. 高频易错点补充
未手动添加&#39;\0&#39;会导致 strlen 越界：
  char str1[] = &quot;hello&quot;; // 自动添加&#x27;\0&#x27;，数组长度6（h e l l o \0）char str2[] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;; // 无&#x27;\0&#x27;，strlen(str2)结果不确定（越界查找）


四、数组和动态容器（vector）对比表


对比维度
数组（Array）
vector（动态数组）



大小特性
编译期固定，运行时不可修改
运行时动态调整，push_back自动扩容


内存管理
栈 &#x2F; 全局区存储，手动管理（无自动释放）
堆内存存储，自动管理（析构时释放资源）


长度获取
手动计算（sizeof(arr)/sizeof(arr[0])）
内置size()方法（直接获取元素个数）


传参方式
退化为指针，需额外传递长度参数
传引用（vector&lt;int&gt;&amp;），保留长度信息


越界安全性
无越界检查，访问越界为未定义行为
at()方法支持越界检查（抛异常），更安全


灵活性
低（不可扩容 &#x2F; 缩容）
高（支持插入、删除、扩容等操作）


]]></content>
      <categories>
        <category>C++</category>
        <category>3. 数组与字符串</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/posts/bbcf5ff7.html</url>
    <content><![CDATA[核心要点速览
语法：[捕获列表](参数) mutable -&gt; 返回类型 { 函数体 }，仅捕获列表和函数体为必填
捕获列表：控制外部变量访问（值捕获[=]、引用捕获[&amp;]、混合捕获[=, &amp;x]等）
类型：编译器生成的唯一匿名闭包类型，无捕获可转函数指针，有捕获需std::function包装
核心优势：匿名、就地定义、灵活访问外部变量，简化算法参数（如sort比较函数）


一、语法结构Lambda 由 5 部分组成，仅捕获列表和函数体不可省略：
[capture-list](parameter-list) mutable noexcept -&gt; return-type &#123; function-body &#125;


捕获列表（[]）：核心，指定外部变量的访问方式（值 &#x2F; 引用）。
参数列表（()）：与普通函数一致，无参数时可省略。
mutable：可选，允许修改值捕获的变量（默认值捕获为const）。
noexcept：可选，声明不抛出异常。
返回类型（-&gt; type）：可选，编译器可自动推导（函数体return类型唯一时）。
函数体（{}）：执行逻辑，可访问捕获的变量和参数。


二、捕获列表控制 Lambda 如何访问外部变量，需遵守明确的规则和禁忌。
1. 基础捕获方式（1）按值捕获（[var]）
特性：拷贝外部变量形成副本，修改副本不影响外部；默认副本为const，需修改加mutable。
关键：捕获时机为 Lambda 创建时，而非调用时。

（2）按引用捕获（[&amp;var]）
特性：捕获变量的引用，修改会影响外部；需确保 Lambda 调用时，变量仍有效（避免悬垂引用）。

（3）默认捕获（[=]&#x2F;[&amp;]）
[=]：默认按值捕获所有用到的外部变量（仅捕获实际使用的变量）。
[&amp;]：默认按引用捕获所有用到的外部变量。

（4）混合捕获（默认 + 显式）
规则：显式捕获需与默认捕获方式相反（避免冲突）。
合法：[=, &amp;x]（默认值捕获，仅x引用捕获）、[&amp;, y]（默认引用捕获，仅y值捕获）。
非法：[=, x]（重复值捕获）、[&amp;, &amp;y]（重复引用捕获）。



2. 捕获禁忌
不能捕获局部变量的地址或引用（除通过捕获列表显式引用捕获）。
函数参数不能被捕获（需通过参数列表传递）。
全局 &#x2F; 静态变量无需捕获，可直接访问。


三、类型与存储Lambda 的本质是编译器生成的匿名闭包类（重载operator()，即仿函数）。
1. 核心类型特性
每个 Lambda 的类型唯一（即使代码完全相同），无法直接声明，需用auto推导。
无捕获的 Lambda：可隐式转换为函数指针（如void(*func)() = [](){};）。
有捕获的 Lambda：不可转函数指针，需用std::function包装（通用函数包装器）。

2. std::function包装 Lambda
用途：存储有捕获的 Lambda，解决类型唯一化问题，适用于函数参数、返回值等场景。
示例：std::function&lt;int(int)&gt; func = [](int x){ return x*2; };


四、问答Lambda 与普通函数、仿函数的区别？


对比维度
普通函数
仿函数（函数对象）
Lambda 表达式



状态存储
无状态（不能访问外部变量）
可通过成员变量存储状态
可通过捕获列表灵活访问外部变量


定义方式
全局 &#x2F; 命名空间可见
需定义类，代码冗余
匿名、就地定义，简洁高效


类型特性
固定类型（可直接声明）
自定义类类型
编译器生成唯一匿名类型


适用场景
通用全局逻辑
需复用的带状态逻辑
短小、临时的局部逻辑（如算法参数）


]]></content>
      <categories>
        <category>C++</category>
        <category>7. 现代C++特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用和移动语义</title>
    <url>/posts/4d855a6b.html</url>
    <content><![CDATA[核心要点速览
左值 vs 右值：左值有持久地址（可 &amp; 取址），右值是临时对象 &#x2F; 字面量（不可 &amp; 取址）
右值引用（T&amp;&amp;）：绑定右值，延长其生命周期，支持修改绑定对象
移动语义：通过移动构造 &#x2F; 赋值转移资源（而非拷贝），提升性能（避免深拷贝）
std::move：将左值转为右值引用（仅转换，不移动资源），原对象不应再使用
完美转发：std::forward 保持参数左值 &#x2F; 右值属性，用于模板传递参数


一、左值与右值：值的核心分类核心区别：是否有持久内存地址、能否被取址。
1. 左值
定义：可放在赋值左侧，有持久内存地址，生命周期较长（如变量、函数返回的左值引用）。
特征：可被&amp;取址（&amp;a合法），可被赋值（a = 5合法）。
示例：int x = 10;（x 是左值）、int&amp; func()（返回左值引用，是左值）。

2. 右值
定义：只能放在赋值右侧，无持久内存地址（或地址无意义），生命周期短暂。
分类：
纯右值：字面量（5、&quot;hello&quot;）、表达式结果（x + y）、临时对象（func()返回非引用时）。
将亡值：即将被销毁的对象（如返回局部对象的函数返回值）。


特征：不可被&amp;取址（&amp;5编译报错），通常是临时结果。


二、右值引用（T&amp;&amp;）：绑定右值的引用类型专门用于绑定右值，是移动语义和完美转发的基础。
核心特性
绑定对象：仅能绑定右值（纯右值或将亡值），不能直接绑定左值（需通过std::move转换）。
生命周期延长：绑定临时对象后，临时对象生命周期延长至与右值引用相同（避免被立即销毁）。
可修改性：与const T&amp;（常量左值引用，只读）不同，T&amp;&amp;可修改绑定的右值（因右值即将销毁，修改无副作用）。

三种引用对比


引用类型
语法
可绑定对象
能否修改绑定值
典型用途



左值引用
T&amp;
左值
能（非 const）
传递参数、返回引用


常量左值引用
const T&amp;
左值、右值
不能
接收任意值（避免拷贝）


右值引用
T&amp;&amp;
右值（纯右值、将亡值）
能
实现移动语义、完美转发



三、移动语义：避免冗余拷贝核心是 “转移资源所有权” 而非复制资源，解决深拷贝的性能问题。
1. 移动构造函数与移动赋值运算符移动构造函数
语法：T(T&amp;&amp; other) noexcept;

作用：接管other的动态资源（如指针指向的内存），将other置为 “可安全销毁” 状态（如指针置空）。

示例核心逻辑：
  String(String&amp;&amp; other) noexcept : str(other.str) &#123;    other.str = nullptr; // 掏空原对象，避免析构时重复释放&#125;

移动赋值运算符
语法：T&amp; operator=(T&amp;&amp; other) noexcept;
作用：先释放当前对象资源，再接管other的资源，最后将other置空。

2. 核心优势
性能优化：将深拷贝（内存分配 + 数据复制）简化为指针赋值，大幅提升效率。
资源安全：针对将亡值（如临时对象），转移资源不影响其他对象。
支持不可拷贝对象的转移：某些资源（如文件句柄）不可拷贝，但可通过移动转移所有权。


四、std::move：左值转右值引用（非实际移动）
作用：强制将左值转换为右值引用（仅修改值的属性，不实际移动资源）。
关键特性：
转换后原对象仍 “有效但不应再使用”（资源可能已被转移）。
可用于任何对象（内置类型、自定义类型），无性能开销。


示例：String s1; String s2 = std::move(s1);（s1 转为右值引用，触发 s2 的移动构造）。


五、完美转发：保持参数值类别
核心问题：模板中传递参数时，左值 &#x2F; 右值属性可能丢失（如右值被转为左值引用）。

解决方案：std::forward&lt;T&gt;(t)，根据T的类型保持参数的左值 &#x2F; 右值属性。

典型场景：模板转发参数至内部函数，确保参数类型正确传递：
  template&lt;typename T&gt;void wrapper(T&amp;&amp; t) &#123;    func(std::forward&lt;T&gt;(t)); // 保持t的左值/右值属性&#125;


六、补充
noexcept 的作用：移动构造 &#x2F; 赋值若加noexcept，标准容器（如vector）扩容时会优先选择移动而非拷贝（避免异常导致数据丢失），否则可能 fallback 到拷贝，失去优化意义。
移动语义 vs 拷贝语义：拷贝是 “复制资源，原对象不变”；移动是 “转移资源，原对象失效”。
右值引用为何能提升性能：针对临时对象（右值），无需拷贝其资源，直接转移所有权，消除冗余的内存分配和复制。

]]></content>
      <categories>
        <category>C++</category>
        <category>7. 现代C++特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>右值引用</tag>
        <tag>移动语义</tag>
      </tags>
  </entry>
  <entry>
    <title>类型推导</title>
    <url>/posts/6d04aba6.html</url>
    <content><![CDATA[核心要点速览
auto：根据初始化表达式推导变量类型，忽略顶层 const 和引用，有明确使用限制（函数参数 &#x2F; 非静态成员 &#x2F; 数组）
decltype：推导表达式精确类型（不执行表达式），完全保留 const 和引用，无需变量初始化
模板类型推导：分按值、按引用、万能引用（T&amp;&amp;）三种场景，核心是处理 const 和引用的折叠规则
核心区别：auto 简化变量声明，decltype 获取精确类型，模板推导适配函数 &#x2F; 模板参数场景


一、auto：自动推导变量类型核心用途是简化长类型声明，推导规则聚焦 “忽略顶层修饰，保留底层约束”。
1. 核心推导规则
必须初始化：编译器依赖初始化表达式推导类型，未初始化编译报错。
顶层 const &#x2F; 引用忽略：变量本身的 const 和引用会被舍弃，底层 const（指向常量的约束）保留。
顶层 const 示例：const int x=10; auto a=x;（a 推导为 int，顶层 const 忽略）
引用示例：int&amp; ref=y; auto c=ref;（c 推导为 int，引用忽略）
底层 const 示例：const int* p=&amp;x; auto e=p;（e 推导为 const int*，底层 const 保留）


需保留引用 &#x2F;const：显式添加&amp;或const，如auto&amp; b=x;（b 推导为 const int&amp;）、const auto f=x;（f 推导为 const int）。

2. 面试高频限制
不能用于函数参数：void func(auto x)（编译报错，无法推导未初始化参数）。
不能用于非静态成员变量：类成员初始化时机与 auto 推导冲突。
不能推导数组类型：int arr[5]; auto p=arr;（p 推导为 int*，而非 int [5]）。


二、decltype：推导表达式精确类型核心优势是 “保留原始类型”，无需执行表达式，适配需精确类型的场景（如模板返回值）。
1. 核心推导规则
推导变量名：结果为变量的声明类型（完全保留 const 和引用）。
示例：const int&amp; ref=x; decltype(ref) r=ref;（r 推导为 const int&amp;）。


推导表达式：结果为表达式的返回类型（根据值类别判断，不执行表达式）。
示例：decltype(x+y)（x+y 是 int 类型，推导为 int）；decltype(*p)（*p 是左值，推导为 int&amp;）。


推导函数调用：结果为函数返回类型（不执行函数）。
示例：decltype(func(3))（推导为 func 的返回类型，无论 func 是否执行）。




三、auto 与 decltype 核心区别


对比维度
auto
decltype



推导依据
变量初始化表达式的类型
任意表达式的类型（不执行表达式）


const &#x2F; 引用处理
忽略顶层 const 和引用，保留底层 const
完全保留表达式的 const 和引用属性


初始化要求
必须初始化（否则无法推导）
无需初始化（推导表达式类型）


核心用途
简化变量声明（如迭代器、复杂模板类型）
获取精确类型（如模板返回值、表达式类型）



四、模板类型推导模板参数 T 的推导规则与 auto 类似，但需区分 “传递方式”，核心分三类场景。
1. 按值传递（模板参数为 T）
推导规则：忽略实参的顶层 const 和引用，底层 const 保留。
示例：template&lt;typename T&gt; void func(T x);
const int a=10; func(a);（T 推导为 int，顶层 const 忽略）
int&amp; b=20; func(b);（T 推导为 int，引用忽略）
const int* c=&amp;a; func(c);（T 推导为 const int*，底层 const 保留）





2. 按引用传递（模板参数为 T&amp;）
推导规则：保留实参的 const 和引用，T 推导为 “实参去掉引用后的类型”。
示例：template&lt;typename T&gt; void func(T&amp; x);
int a=10; func(a);（T 推导为 int，x 类型为 int&amp;）
const int b=20; func(b);（T 推导为 const int，x 类型为 const int&amp;）
禁止传递字面量：func(5);（编译报错，非 const 引用无法绑定字面量）





3. 万能引用（模板参数为 T&amp;&amp;）
核心场景：同时适配左值和右值实参，依赖 “引用折叠” 规则推导。
引用折叠规则（面试高频）：
左值引用 + 左值引用→左值引用（T&amp; + &amp; → T&amp;）
左值引用 + 右值引用→左值引用（T&amp; + &amp;&amp; → T&amp;）
右值引用 + 右值引用→右值引用（T&amp;&amp; + &amp;&amp; → T&amp;&amp;）


推导示例：template&lt;typename T&gt; void func(T&amp;&amp; x);
传递左值：int a=10; func(a);（T 推导为 int&amp;，x 类型为 int&amp;）
传递右值：func(20);（T 推导为 int，x 类型为 int&amp;&amp;）



]]></content>
      <categories>
        <category>C++</category>
        <category>7. 现代C++特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>类型推导</tag>
      </tags>
  </entry>
  <entry>
    <title>STL基础</title>
    <url>/posts/6e08d78f.html</url>
    <content><![CDATA[核心要点速览
核心组件：容器（存储数据）、算法（操作数据）、迭代器（容器与算法桥梁）、仿函数（自定义逻辑）、适配器（接口转换）
容器分类：序列式（vector&#x2F;list&#x2F;deque）、关联式（map&#x2F;set 等，红黑树 &#x2F; 哈希表实现）、适配器（stack&#x2F;queue&#x2F;priority_queue）
关键考点：容器底层实现、迭代器失效场景、容器选型对比、算法适用条件


一、STL 核心组件
容器（Containers）：类模板，封装数据结构（如 vector、map），用于存储数据。
算法（Algorithms）：函数模板，实现通用操作（如 sort、find），通过迭代器操作容器。
迭代器（Iterators）：类似指针的对象，提供容器元素访问接口，是容器与算法的桥梁。
仿函数（Functors）：重载operator()的类 &#x2F; 结构体（函数对象），用于算法自定义逻辑（如比较、谓词）。
适配器（Adapters）：转换已有组件接口（如 stack&#x2F;queue 基于 deque 适配，priority_queue 基于 vector 适配）。


二、容器：分类与核心特性容器按存储结构分为序列式、关联式、适配器三类，核心考察底层实现、操作效率、适用场景。
1. 序列式容器（元素有序，依赖位置）vector：动态数组
底层实现：连续动态数组，内存地址连续。
核心特性：
随机访问高效（[]&#x2F;at()，O(1)）；尾部增删高效（push_back()&#x2F;pop_back()，O(1)）。
动态扩容：容量不足时申请 1.5&#x2F;2 倍新内存，拷贝旧元素（扩容成本高）。
中间 &#x2F; 头部增删低效（需移动元素，O(n)）。


关键接口：reserve(n)（预分配内存，不改变 size）、resize(n, val)（调整 size，可能扩容）、erase(iter)（返回下一个有效迭代器）。
适用场景：频繁随机访问、尾部增删（如列表数据、缓存）。

list：双向链表
底层实现：双向链表（节点含数据、前驱 &#x2F; 后继指针），内存不连续。
核心特性：
随机访问低效（遍历，O(n)），不支持[]访问。
任意位置增删高效（修改指针，O(1)，需先定位）。
迭代器为双向迭代器（支持++&#x2F;--，不支持+n）。


适用场景：频繁中间增删（如链表、非 FIFO 队列）。

deque：双端队列
底层实现：分段连续动态数组（多个缓冲区 + 中控器指针数组）。
核心特性：
头尾增删高效（push_front()&#x2F;pop_front()，O(1)）。
随机访问效率：高于 list，低于 vector（O(1)，需中控器定位）。
扩容成本低于 vector（新增缓冲区，无需拷贝全部元素）。


适用场景：双端操作队列（如 BFS 队列）。

2. 关联式容器（元素无序，依赖键值）分为有序（红黑树）和无序（哈希表）两类，核心考察查找效率、有序性、内存占用。
有序关联容器（红黑树实现，O(logn)操作）
包含：set（唯一键）、multiset（键可重复）、map（键值对，键唯一）、multimap（键可重复）。
核心特性：
按键升序排列（默认less&lt;Key&gt;），支持范围查询（lower_bound&#x2F;upper_bound）。
迭代器为双向迭代器，遍历有序。
插入 &#x2F; 删除 &#x2F; 查找时间复杂度稳定O(logn)。



无序关联容器（哈希表实现，平均O(1)操作）
包含：unordered_set（唯一键）、unordered_multiset（键可重复）、unordered_map（键值对，键唯一）、unordered_multimap（键可重复）。
核心特性：
元素无序，迭代器为前向迭代器（仅支持++）。
平均插入 &#x2F; 删除 &#x2F; 查找O(1)，最坏O(n)（哈希冲突严重）。
自定义键需特化std::hash哈希函数。



map vs unordered_map


对比维度
map（红黑树）
unordered_map（哈希表）



查找效率
O(logn)（稳定）
平均O(1)，最坏O(n)


内存占用
较低（仅键值对 + 树结构）
较高（哈希表需额外空间解决冲突）


有序性
支持（按键升序）
不支持


迭代器类型
双向迭代器（++&#x2F;--）
前向迭代器（仅++）


适用场景
有序遍历、范围查询
频繁查找，不关心顺序


3. 容器适配器（接口转换）
stack：栈（LIFO），默认底层deque，接口：push()&#x2F;pop()&#x2F;top()。
queue：队列（FIFO），默认底层deque，接口：push()&#x2F;pop()&#x2F;front()&#x2F;back()。
priority_queue：优先队列（最大堆），底层vector+ 堆算法，接口：push()&#x2F;pop()&#x2F;top()。


三、迭代器：类型与失效1. 迭代器类型（按功能划分）


迭代器类型
支持操作（除++外）
对应容器示例



输入迭代器
*（读）、==&#x2F;!=
istream_iterator


输出迭代器
*（写）
ostream_iterator


前向迭代器
输入 + 输出功能，支持多遍访问
unordered_set&#x2F;unordered_map


双向迭代器
前向功能 +--
list、map、set


随机访问迭代器
双向功能 ++n&#x2F;-n&#x2F;[]
vector、deque、数组


2. 迭代器失效场景vector 迭代器失效
插入（push_back&#x2F;insert）：扩容则所有迭代器失效；未扩容则插入位置及之后失效。
删除（erase）：删除位置及之后失效，需用iter = vec.erase(iter)更新迭代器。

list 迭代器失效
插入：迭代器不失效（仅修改指针）。
删除：仅被删除元素的迭代器失效，其余有效。

map&#x2F;set 迭代器失效
插入：迭代器不失效（红黑树调整不改变节点地址）。
删除：仅被删除节点的迭代器失效，其余有效。


四、算法：常用算法与适用条件1. 核心算法
排序：sort(first, last)，需随机访问迭代器（vector&#x2F;deque），底层是 introsort（快排 + 堆排 + 插入排序）。
注意：list不支持std::sort，需用成员函数list::sort()。


查找：
find(first, last, val)：线性查找（O(n)），支持所有迭代器。
binary_search(first, last, val)：二分查找（O(logn)），需有序序列 + 随机访问 &#x2F; 双向迭代器。


遍历：for_each(first, last, func)，对元素执行func（函数 &#x2F; 仿函数）。
删除：remove(first, last, val)（逻辑删除，移动元素），需配合erase真正删除：container.erase(remove(...), container.end())。

2. 仿函数（函数对象）
定义：重载operator()的类 &#x2F; 结构体，可携带状态，比函数指针灵活。
用途：算法中传递自定义逻辑（如sort的比较规则、find_if的筛选条件）。

]]></content>
      <categories>
        <category>C++</category>
        <category>5. 模板与STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>友元与运算符重载</title>
    <url>/posts/6ea8b1ca.html</url>
    <content><![CDATA[核心要点速览
友元：打破封装，允许外部函数 &#x2F; 类访问类的私有 &#x2F; 保护成员（分友元函数、友元类、友元成员函数）
运算符重载：自定义类型的运算规则，不可重载 6 个运算符，支持成员函数 &#x2F; 友元函数两种形式
特殊重载：赋值运算符=只能作为成员函数；&lt;&lt;&#x2F;&gt;&gt;需作为友元函数


一、友元：打破封装的特殊访问机制友元的核心是 “让外部实体获得类的特殊访问权限”，可访问私有（private）和保护（protected）成员，代价是削弱封装性。
1. 友元的种类（1）友元函数
声明方式：类内用friend声明，定义可在类外（非成员函数，无this指针）。

示例：
  class A &#123;private:    int num = 10;    // 友元函数声明    friend void printA(A&amp; obj);&#125;;// 友元函数定义（类外），可直接访问私有成员void printA(A&amp; obj) &#123;    cout &lt;&lt; obj.num &lt;&lt; endl; // 合法：访问A的private成员&#125;

关键：访问类成员时需显式传递对象参数（无this指针）。


（2）友元类
声明方式：类内用friend class 类名;，目标类的所有成员函数均可访问当前类私有成员。

示例：
  class A &#123;private:    int num = 10;    friend class B; // 声明B为友元类&#125;;class B &#123;public:    void accessA(A&amp; obj) &#123;        cout &lt;&lt; obj.num &lt;&lt; endl; // 合法：B的成员函数访问A的private成员    &#125;&#125;;

（3）友元成员函数
声明方式：指定类的某个成员函数作为友元，更精准控制访问权限。

示例：
  class B; // 前置声明class A &#123;private:    int num = 10;    // 声明B的show()函数为友元    friend void B::show(A&amp; obj);&#125;;class B &#123;public:    void show(A&amp; obj); // 成员函数声明&#125;;// B的show()函数定义，可访问A的private成员void B::show(A&amp; obj) &#123;    cout &lt;&lt; obj.num &lt;&lt; endl;&#125;

2. 友元的关键特性
不可传递性：A 是 B 的友元，B 是 C 的友元，不代表 A 是 C 的友元。
单向性：A 声明 B 为友元，仅 B 能访问 A，A 不能访问 B。
声明位置无关：友元声明可放在类的 public&#x2F;private&#x2F;protected 任意区域，效果一致。


二、运算符重载：自定义类型的运算规则运算符重载是赋予自定义类型（类 &#x2F; 结构体）运算符（如+、==）的运算能力，语法为返回类型 operator运算符(参数列表)。
1. 重载核心规则
不可重载的 6 个运算符（固定，面试高频）：
.（成员访问）、.*（成员指针访问）、::（作用域解析）、sizeof（大小计算）、?:（三目运算符）、typeid（类型信息）。


不可改变的特性：运算符的优先级、结合性、操作数个数。
必须包含至少一个自定义类型操作数（避免重载内置类型运算）。

2. 两种重载形式（1）成员函数重载
核心：左侧操作数为当前类对象（隐含this指针），参数列表只需传入右侧操作数。

适用场景：左侧操作数是当前类对象（如a + b，a 是当前类对象）。

示例（重载+）：
  class Point &#123;private:    int x, y;public:    Point(int x=0, int y=0) : x(x), y(y) &#123;&#125;    // 成员函数重载+：this指向左侧操作数    Point operator+(const Point&amp; rhs) &#123;        return Point(x + rhs.x, y + rhs.y);    &#125;&#125;;// 调用：左侧a是this指针指向的对象Point a(1,2), b(3,4);Point c = a + b; // 等价于a.operator+(b)

（2）友元函数重载
核心：无this指针，需显式传入所有操作数（左侧 + 右侧）。

适用场景：左侧操作数不是当前类对象（如cout &lt;&lt; a，左侧是ostream对象）。

示例（重载&lt;&lt;，输出自定义类型）：
  class Point &#123;private:    int x, y;public:    Point(int x=0, int y=0) : x(x), y(y) &#123;&#125;    // 友元函数重载&lt;&lt;：需访问私有成员，且左侧是ostream    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Point&amp; p) &#123;        os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;        return os; // 支持链式输出（cout &lt;&lt; a &lt;&lt; b）    &#125;&#125;;// 调用：os=cout，p=aPoint a(1,2);cout &lt;&lt; a; // 等价于operator&lt;&lt;(cout, a)，输出(1,2)

3. 特殊重载：赋值运算符=
核心规则：只能作为成员函数（编译器默认生成，执行浅拷贝）。

深拷贝需求：当类包含动态资源（如指针）时，需手动重写，避免双重释放。

示例（深拷贝赋值运算符）：
  class String &#123;private:    char* str;public:    // 赋值运算符重载（成员函数）    String&amp; operator=(const String&amp; other) &#123;        if (this == &amp;other) return *this; // 处理自我赋值        delete[] str; // 释放当前资源        // 深拷贝：重新分配内存        str = new char[strlen(other.str) + 1];        strcpy(str, other.str);        return *this; // 支持链式赋值（a = b = c）    &#125;&#125;;

]]></content>
      <categories>
        <category>C++</category>
        <category>4. 面向对象编程OOP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>友元</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>模板基础</title>
    <url>/posts/6bd4602e.html</url>
    <content><![CDATA[核心要点速览
核心意义：将类型作为参数，实现通用逻辑，编译期生成具体类型代码
分类：函数模板（可隐式实例化）、类模板（需显式实例化）
模板参数：类型参数（typename T）、非类型参数（编译期常量）
特化：全特化（所有参数指定类型）、偏特化（仅类模板支持，部分参数指定类型）
关键区别：模板有类型检查，宏无；模板支持特化 &#x2F; 重载，宏不支持


一、模板的核心意义通过 “类型作为参数” 脱离具体类型约束，让通用逻辑适配多种类型，编译器自动生成对应版本代码（无重复编写成本，类型安全）。

二、函数模板核心定义生成具体函数的 “模板”，编译器根据实参类型自动实例化对应版本。
关键规则
语法：template&lt;模板参数列表&gt; 返回类型 函数名(参数列表) { ... }
实例化：
隐式实例化：编译器根据实参推导类型（如max(1,2)推导T=int）。
显式实例化：手动指定类型（如max&lt;int&gt;(1.5,2.5)强制T=int）。


重载：支持模板间重载（参数列表 &#x2F; 模板参数不同），非模板函数优先级高于模板函数。


三、类模板核心定义生成具体类的 “模板”，用于创建与类型相关的通用类（如vector、map）。
关键规则
语法：template&lt;模板参数列表&gt; class 类名 { ... };
实例化：必须显式指定模板参数（编译器无法推导），格式类名&lt;类型&gt;（如Vector&lt;int&gt;）。
成员函数：类外定义时需保留模板参数（如template&lt;typename T&gt; void Vector&lt;T&gt;::push_back(T val) { ... }）。


四、模板参数：类型参数与非类型参数1. 类型参数
声明：typename或class修饰（两者等价），代表任意类型（如int、string、自定义类）。
用途：最常用，适配不同数据类型。

2. 非类型参数
定义：代表编译期常量（值在编译期可确定）。
支持类型：整数类型（int、size_t）、全局变量 &#x2F; 函数的指针 &#x2F; 引用。
限制：不支持浮点数、类对象（编译期无法确定值）。
示例语法：template&lt;int N&gt; class Array { ... };（N为编译期常量）。


五、模板特化：定制特定类型实现为特定类型提供定制化实现，覆盖泛化版本（解决泛化模板对某些类型不适用的问题）。
1. 全特化
定义：为模板所有参数指定具体类型，完全覆盖泛化版本。
语法：template&lt;&gt; 类名/函数名&lt;具体类型&gt; { ... };（如template&lt;&gt; class Vector&lt;char&gt; { ... };）。

2. 偏特化（仅类模板支持）
定义：为模板部分参数指定具体类型，函数模板不支持偏特化。
语法：template&lt;剩余参数列表&gt; class 类名&lt;部分指定类型&gt; { ... };（如template&lt;typename T&gt; class Vector&lt;T*&gt; { ... };对指针类型特化）。


六、补充关键特性1. 惰性实例化模板仅实例化被使用的成员，未使用的成员不会生成代码（减少冗余）。
2. 模板与宏的核心区别


对比维度
模板（Template）
宏（#define）



类型检查
编译期强类型检查（安全）
无类型检查（文本替换，易错）


调试支持
支持（可见具体实例化类型）
不支持（替换后无宏信息）


灵活性
支持复杂逻辑、重载、特化
仅简单文本替换（复杂逻辑易出错）


代码生成
编译期生成具体类型代码
预编译期替换，不生成新代码


]]></content>
      <categories>
        <category>C++</category>
        <category>5. 模板与STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>程序结构与预处理</title>
    <url>/posts/43ae7cb1.html</url>
    <content><![CDATA[核心要点速览
程序入口：main 函数（返回值 int，return 0 表示正常退出）
核心预处理指令：#include（头文件包含）、#define（宏定义）、条件编译（#ifdef&#x2F;#ifndef&#x2F;endif）、#pragma once（头文件防重复包含）
核心流程：预处理→编译→汇编→链接→执行


一、程序结构
执行流程：预处理→编译→汇编→链接→执行
预处理是编译的第一个阶段，由预处理器处理所有以 #开头的指令，生成 “预处理后的源代码”
预处理核心操作：消除注释、展开宏、处理条件编译、引入头文件内容


二、预处理指令详解2.1 #include：头文件包含
#include &lt;header&gt;：优先搜索系统标准头文件目录（如/usr/include），用于引入标准库（如&lt;iostream&gt;、&lt;vector&gt;）
#include &quot;header&quot;：优先搜索当前源文件所在目录，再搜索系统目录，用于引入自定义头文件（如&quot;myfunc.h&quot;）

2.2 #define：宏定义宏定义在预处理阶段执行，本质是 “文本替换”，语法格式为：#define 宏名 替换文本
宏的分类
常量宏定义：直接进行文本替换（如#define PI 3.14159）
函数宏定义：带参数的文本替换（如#define MUL(a,b) a*b），非真正函数调用
#undef：用于取消已定义的宏，缩小作用域（如#undef PI）

宏与相关概念的区别
与函数的区别：
宏：无类型检查、无调用栈开销、可操作类型（如#define SWAP(T,a,b) {T t=a;a=b;b=t;}）
函数：有类型检查、有调用开销、参数类型固定


与const的区别：
宏：无类型、全局替换、不可调试、无作用域限制
const变量：有类型、有作用域、可调试、编译阶段检查



宏定义的优缺点
优点：
提升可读性：为常量或复杂表达式赋予有意义名称
便于修改：统一更新宏定义，无需逐个替换
增强可移植性：配合条件编译适配不同平台 &#x2F; 编译器


缺点：
无类型检查：仅文本替换，不校验参数类型，易藏错误
可能代码膨胀：大量使用函数宏会增大目标代码体积
作用域风险：从定义到文件结束（或#undef），易引发命名冲突



2.3 条件编译条件编译在预处理阶段执行，根据条件决定部分代码是否进入编译，核心用于跨平台适配、调试 &#x2F; 发布版本区分、头文件防重复包含。
核心指令
#ifdef MACRO：若MACRO已定义，则编译后续代码
#ifndef MACRO：若MACRO未定义，则编译后续代码（常用）
#if 表达式：表达式为真则编译（支持defined(MACRO)判断宏是否定义）
#else&#x2F;#elif：分支控制
#endif：结束条件编译块（必须配对）
#error：预处理阶段报错，终止编译（可用于版本 &#x2F; 系统检查）
#pragma pack(n)：设置结构体对齐字节数（面试高频），如#pragma pack(1)强制 1 字节对齐

常用场景
头文件防重复包含：#ifndef HEADER_NAME_H #define HEADER_NAME_H ... #endif
跨平台适配：#if defined(WIN32) ... #elif defined(LINUX) ... #endif
调试模式控制：#ifdef DEBUG printf(&quot;调试信息&quot;); #endif

2.4 #pragma once
功能：替代#ifndef实现头文件防重复包含
特点：非 C++ 标准，但几乎所有主流编译器都支持
优势：语法简洁，无需定义头文件保护宏，预处理效率更高


三、带参数宏陷阱及解决方案3.1 运算符优先级错乱
问题：宏替换直接插入代码，不自动加括号，运算符优先级冲突导致逻辑错误
示例：#define MUL(a, b) a * b，调用MUL(2+3, 4)会替换为2+3*4=14（预期 16）
解决方案：给每个参数和整个替换体都加括号，如#define MUL(a, b) ((a) * (b))

3.2 参数副作用（多次计算）
问题：参数为副作用表达式（如i++、x+=1）时，宏替换会让参数多次计算，放大副作用
示例：#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))，调用MAX(i++, j++)会导致i和j多次自增
解决方案：
避免将带副作用的表达式作为宏参数
先将参数值存入临时变量，再传入宏（如int a_val = i++; int b_val = j++; MAX(a_val, b_val)）



3.3 重复计算（性能 + 逻辑风险）
问题：参数为复杂表达式（如函数调用、耗时计算）时，宏替换会导致表达式多次执行
影响：浪费性能，若表达式有状态依赖（如获取系统时间）会引发逻辑错误
解决方案：
避免将复杂表达式直接作为宏参数
先计算表达式结果存入临时变量，再传入宏



3.4 缺少分号导致逻辑断裂
问题：多行宏体未用{}包裹，开发者习惯加;会导致语法逻辑破坏
示例：#define PRINT() printf(&quot;a&quot;); printf(&quot;b&quot;)，在if(1) PRINT(); else ...中会提前结束 if 逻辑
解决方案：用do{...}while(0)包裹多行宏体，如#define PRINT() do{printf(&quot;a&quot;); printf(&quot;b&quot;);}while(0)

3.5 命名冲突
问题：宏作用域广（定义到文件结束），无差别替换所有匹配标识符，易与变量 &#x2F; 函数同名冲突
解决方案：
宏名采用 “全大写 + 下划线” 规范（如MAX_VALUE）
用#undef及时取消无用宏，缩小作用域
避免使用库函数名、关键字作为宏名



]]></content>
      <categories>
        <category>C++</category>
        <category>1. 基础语法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>程序结构</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步</title>
    <url>/posts/895e9db.html</url>
    <content><![CDATA[核心要点速览
数据竞争：多线程并发读写共享资源（至少一个写操作）的未定义行为
互斥锁：std::mutex（基础）、lock_guard（RAII 推荐）、unique_lock（灵活，配条件变量）
条件变量：wait()（阻塞 + 释锁）、notify_one()&#x2F;notify_all()，需配互斥锁 + 谓词（解虚假唤醒）
原子操作：std::atomic（硬件级原子性，无锁），核心内存序（relaxed&#x2F;acquire&#x2F;release&#x2F;seq_cst）
读写锁：std::shared_mutex（读共享、写独占），优化读多写少场景
常见问题：死锁（固定加锁顺序避免）、虚假唤醒（谓词检查解决）、活锁 &#x2F; 饥饿（延迟 &#x2F; 公平锁缓解）


一、线程同步的目标
保证数据一致性：避免多线程读写共享资源导致的结果不可预测。
控制执行顺序：确保线程按业务逻辑要求的顺序执行（如生产者先生产，消费者后消费）。


二、核心同步机制1. 互斥锁：独占式临界区访问
核心原理：通过 “加锁 - 操作 - 解锁”，保证同一时间仅一个线程进入临界区（访问共享资源的代码段）。

关键锁类型与特性


锁类型
核心特性
适用场景



std::mutex
基础互斥锁，不可递归加锁
简单独占访问，配合 RAII 锁使用


std::lock_guard
RAII 自动管理（构造加锁、析构解锁）
无需手动控制锁，避免漏解锁 &#x2F; 异常


std::unique_lock
灵活控制（可延迟加锁、手动解锁）
配合条件变量，需动态控制锁状态


std::recursive_mutex
允许同一线程重复加锁
递归函数访问临界区（不推荐，易藏错）


std::timed_mutex
支持超时尝试加锁（try_lock_for）
避免无限阻塞，需限时获取锁场景


注意事项
std::mutex的lock()&#x2F;unlock()必须成对出现，否则引发死锁；优先用lock_guard&#x2F;unique_lock（RAII 安全）。
不可递归加锁普通std::mutex（同一线程多次lock()会死锁）。

2. 条件变量：线程间等待 - 通知
核心原理：实现线程协作，让线程在条件不满足时阻塞（释放 CPU，避免忙等），条件满足时被唤醒。

核心接口与规则
wait(lock, predicate)：先释放锁→阻塞等待→被唤醒后重新加锁→检查谓词，为true则继续，否则再次阻塞（解决虚假唤醒）。
notify_one()：唤醒一个等待线程（避免资源浪费，优先使用）。
notify_all()：唤醒所有等待线程（适合多个线程需响应条件变化）。

核心要点
必须与std::unique_lock配合：wait()需手动控制锁的释放与重获取。
必须用谓词检查条件：避免操作系统虚假唤醒（无notify时的唤醒）。
依赖互斥锁的原因：保证条件判断和修改的原子性（防止检查期间条件被篡改）。

3. 原子变量：无锁同步
核心原理：基于硬件级原子操作（如 CPULOCK指令），保证读写操作不可分割，无需加锁即可避免数据竞争。

核心特性
非阻塞：不会导致线程挂起，性能远高于互斥锁（高并发场景优先）。
支持操作：仅简单操作（++&#x2F;--&#x2F;load&#x2F;store&#x2F;exchange），复杂逻辑仍需锁。
内存序（面试高频）：
memory_order_relaxed：仅保证操作原子性，不保证内存可见性 &#x2F; 顺序。
memory_order_acquire&#x2F;release：读（acquire）后可见所有写（release）操作，保证顺序。
memory_order_seq_cst：默认，最强保证（全局顺序一致），性能略低。



关键区别
std::atomic vs volatile：
volatile：仅禁止编译器优化（每次从内存读取），不保证原子性（多线程读写仍竞争）。
atomic：保证原子性 + 内存可见性，是线程安全的。



4. 读写锁：读多写少优化
核心原理：区分读 &#x2F; 写操作，允许多线程同时读（共享锁），仅允许单线程写（独占锁）。
标准库实现：std::shared_mutex（C++17+），配合std::shared_lock（读锁）、std::unique_lock（写锁）。
适用场景：读操作远多于写操作（如缓存、配置读取），避免读操作互相阻塞。


三、同步机制对比表


机制
核心原理
优点
缺点
适用场景



互斥锁
独占临界区
适用所有场景，实现简单
阻塞，高并发性能损耗大
复杂临界区（多步操作）


条件变量
等待 - 通知机制
解决执行顺序，避免忙等
需配互斥锁，逻辑复杂
生产者 - 消费者、线程协作


原子变量
硬件级原子操作
非阻塞，性能极高
仅支持简单操作
计数器、标记位、简单共享数据


读写锁
读共享、写独占
优化读多写少场景性能
写操作可能饥饿，实现复杂
缓存、配置等读多写少场景



四、同步常见问题与解决方案1. 死锁
定义：多个线程互相等待对方释放锁，导致永久阻塞。
避免方案：
固定加锁顺序：所有线程按相同顺序加锁（如先mtx1后mtx2）。
批量加锁：用std::lock(mtx1, mtx2)一次性加锁所有需要的锁。
限时等待：用try_lock_for&#x2F;try_lock_until，超时则释放已持锁。
减少锁粒度：缩小临界区范围，缩短持有锁的时间。



2. 活锁
定义：线程不断释放 &#x2F; 重试获取锁，因相互冲突始终无法推进（看似活跃实则无进展）。
解决方案：重试前随机延迟（降低冲突概率），或引入优先级机制。

3. 饥饿
定义：部分线程长期无法获取资源（如低优先级线程被高优先级线程抢占）。
避免方案：使用公平锁（按请求顺序分配锁），限制高优先级线程执行时长。


五、问答1. 条件变量为什么必须配合互斥锁使用？
检查条件时加锁，防止检查期间条件被其他线程修改（保证条件判断原子性）。
wait()阻塞前释放锁，允许其他线程修改条件（避免线程间互相阻塞）。
唤醒后重新加锁，确保后续操作基于最新的条件状态（保证数据一致性）。

2. 如何解决条件变量的虚假唤醒？在wait()的第二个参数传入条件谓词（如wait(lock, []{ return flag; })），唤醒后再次检查条件，只有条件为true才继续执行，否则重新阻塞。
3. std::atomic和volatile的核心区别？volatile仅禁止编译器优化，保证变量每次从内存读取，但不保证原子性（多线程读写仍会竞争）；std::atomic既保证原子性（操作不可分割），又保证内存可见性（一个线程的修改对其他线程立即可见），是线程安全的。
]]></content>
      <categories>
        <category>C++</category>
        <category>8. 多线程编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符与表达式</title>
    <url>/posts/dc2fae3c.html</url>
    <content><![CDATA[核心要点速览
逻辑运算符（&amp;&amp;&#x2F;||）：支持短路求值，右操作数可能不执行（面试高频陷阱）
逗号运算符（,）：按左到右执行多个表达式，返回最后一个值，优先级最低
右结合运算符：赋值运算符（=）、条件运算符（?:）、单目运算符，优先级相同时从右到左执行


一、逻辑运算符的短路求值（&amp;&amp; &#x2F; ||）核心规则短路求值是逻辑运算符的优化特性，仅在必要时计算右操作数，直接影响代码执行结果。

&amp;&amp;（逻辑与）：左操作数为false时，直接返回false，右操作数不执行。
||（逻辑或）：左操作数为true时，直接返回true，右操作数不执行。

常见场景（含副作用表达式）
&amp;&amp;短路示例：
  int i = 0;bool res = (i == 1) &amp;&amp; (++i); // 左为false，右++i不执行// 结果：res=false，i=0（而非1）

||短路示例：
  int j = 0;bool res = (j == 0) || (++j); // 左为true，右++j不执行// 结果：res=true，j=0（而非1）

易错点
禁止将 “必须执行的代码”（如变量更新、数据写入）放在短路运算符右侧，可能因短路导致逻辑失效。
区分&amp;&amp;&#x2F;||（有短路特性）与&amp;&#x2F;|（按位运算，无短路，左右操作数均执行）。


二、逗号运算符（,）核心规则
执行顺序：按从左到右依次执行所有表达式。
返回值：最终返回最后一个表达式的值。
优先级：C++ 中优先级最低（低于赋值运算符），需用括号明确执行逻辑。

典型场景（含陷阱）
优先级陷阱（与赋值结合）：

int a = 1, 2; // 错误：等价于(a=1),2，赋值语句不合法int a = (1, 2); // 正确：返回最后一个表达式，a=2


for 循环多操作场景：

for (int i=0, j=5; i&lt;5; i++, j--) &#123; ... &#125;// 初始化：i=0和j=5同时执行；更新：i++和j--按顺序执行

核心考点
核心考察 “返回最后一个表达式值”，常结合赋值语句预判结果。
区分 “变量声明中的逗号”（非运算符），如int a, b;是声明两个变量，并非逗号运算符。


三、右结合运算符（优先级相同时的执行顺序）核心概念结合性指 “多个优先级相同的运算符连续出现时的执行顺序”，C++ 中多数运算符为左结合，仅以下三类为右结合（面试必考）。
三类核心右结合运算符1. 赋值运算符（&#x3D;）
规则：从右到左执行，支持链式赋值。

示例：
  int a, b, c;a = b = c = 5; // 右结合：先c=5 → 再b=c → 最后a=b，结果a=b=c=5

易错点：a = 3, 4等价于(a=3),4，a 的值为 3（非 4），因逗号运算符优先级更低。


2. 条件运算符（?:）
规则：唯一的右结合双目运算符，嵌套时从右向左解析。

嵌套示例：
  int x=1, y=2, z=3;int res = x&gt;y ? x : y&gt;z ? y : z; // 等价于x&gt;y ? x : (y&gt;z ? y : z)// 结果：res=3（y&gt;z为false，取z=3）

3. 单目运算符
包含：前缀++、前缀--、*（解引用）、&amp;（取地址）、!、~、+（正）、-（负）、sizeof等。

规则：从右到左执行，常结合指针操作考察。

指针示例：
  int a=5;int* p=&amp;a;++*p; // 右结合：先*p（取a=5）→ 再++，结果a=6

易错点：区分前缀（右结合）和后缀++&#x2F;--（左结合），如*p++是左结合，先*p再p++。


]]></content>
      <categories>
        <category>C++</category>
        <category>1. 基础语法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>运算符</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/posts/3a517f26.html</url>
    <content><![CDATA[核心要点速览
访问控制：public（接口）、private（实现）、protected（继承）
const 成员：const 成员变量需初始化列表初始化；const 成员函数不可修改成员变量
static 成员：静态成员变量类共享、类外初始化；静态成员函数无 this 指针、仅访问静态成员
构造函数：可重载、非虚函数；含默认 &#x2F; 带参 &#x2F; 拷贝 &#x2F; 移动构造
析构函数：不可重载；基类需设为虚函数避免资源泄漏
类大小：仅取决于非静态数据成员，遵循内存对齐


一、基本概念
类：抽象的数据类型模板，定义对象的属性（数据成员）和行为（成员函数）。
对象：类的具体实例，占用实际内存，拥有类定义的属性和行为。


二、核心特性：封装核心是 “隐藏实现细节，暴露公共接口”，通过访问控制符实现。



访问控制符
可访问范围
作用



public
类内、类外、派生类
暴露接口，供外部调用


private
仅类内和友元
隐藏数据成员和内部实现


protected
类内、友元、派生类（类外不可访问）
为继承预留访问权限



封装意义：保障数据安全、提升代码维护性、降低使用复杂度。


三、构造函数：对象的初始化
核心特点：函数名与类名相同，无返回值，对象创建时自动调用，可重载，不能为虚函数。

常见类型1. 默认构造函数
定义：无参数，或所有参数都有默认值。
编译器行为：未定义任何构造函数时自动生成；定义其他构造函数后需手动定义。

2. 带参构造函数
用途：通过参数灵活初始化对象。

3. 拷贝构造函数
定义：参数必须为 “同类对象的 const 引用”（避免无限递归）。
调用时机：对象初始化、函数按值传参、函数返回值为对象（非引用）。
浅拷贝 vs 深拷贝：
浅拷贝：仅复制表层数据，指针成员共享内存，可能导致双重释放。

深拷贝：为指针成员重新分配内存并复制数据，示例：
class String &#123;private:    char* str;public:    String(const String&amp; other) &#123;        str = new char[strlen(other.str) + 1];        strcpy(str, other.str);    &#125;    ~String() &#123; delete[] str; &#125;&#125;;





4. 移动构造函数
核心：接管原对象动态资源，避免拷贝，提升效率。

示例：
  class String &#123;private:    char* str;public:    String(String&amp;&amp; other) noexcept &#123;        str = other.str;        other.str = nullptr; // 掏空原对象    &#125;&#125;;String s2 = std::move(s1); // 接管s1资源

初始化列表
用途：优先初始化成员变量，推荐使用。

必须使用的场景：const 成员、引用成员、无默认构造函数的类成员，示例：
  class A &#123;private:    const int a;    int&amp; b;public:    A(int x, int&amp; y) : a(x), b(y) &#123;&#125; // 初始化列表&#125;;


四、析构函数：对象的清理
核心特点：函数名~类名，无参数、无返回值，不可重载，对象生命周期结束时自动调用。

必须手动定义的场景：类包含动态分配资源（如 new 的内存）。

虚析构函数（基类必备，避免资源泄漏）：
  class Base &#123;public:    virtual ~Base() &#123; delete[] data; &#125; // 虚析构&#125;;class Derived : public Base &#123;public:    ~Derived() &#123; delete[] derivedData; &#125;&#125;;


五、this 指针
本质：非静态成员函数中隐式传递的指针，指向当前调用对象（类型类名* const）。

用途：
  void setName(string name) &#123; this-&gt;name = name; &#125; // 区分成员与参数Person&amp; setAge(int age) &#123; return *this; &#125; // 链式调用


六、静态成员（属于类）1. 静态成员变量
特点：所有对象共享，存储在全局数据区，类内声明、类外初始化：
  class Counter &#123;public:    static int count; // 类内声明&#125;;int Counter::count = 0; // 类外初始化

2. 静态成员函数
特点：无 this 指针，无需创建对象即可调用，仅能访问静态成员：
  static void increment() &#123; count++; &#125; // 仅访问静态成员Counter::increment(); // 直接调用


七、类的大小计算
核心规则：仅取决于非静态数据成员，遵循内存对齐，与成员函数、静态成员无关。

示例：
  class Empty &#123;&#125;;sizeof(Empty); // 1字节（占位）class A &#123; char c; int i; &#125;;sizeof(A); // 8字节（1+3填充+4，对齐系数4）


八、问答
构造函数和析构函数的调用顺序？
构造：先定义先构造；析构：后构造先析构。


拷贝构造函数的参数为什么必须是引用？
避免值传递引发的无限递归（形参初始化需再次调用拷贝构造）。



]]></content>
      <categories>
        <category>C++</category>
        <category>4. 面向对象编程OOP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>继承与多态</title>
    <url>/posts/3a088510.html</url>
    <content><![CDATA[核心要点速览
继承：解决代码复用与扩展，核心是派生类获取基类成员；继承方式分 public&#x2F;protected&#x2F;private，构造先父后子、析构先子后父
多态：解决接口统一与动态行为，核心是基类指针 &#x2F; 引用指向派生类对象，调用虚函数触发动态绑定
关键机制：虚函数（virtual）、纯虚函数（抽象类）、虚函数表（vtable）+ 虚指针（vptr）、虚析构（避免资源泄漏）
易混淆点：重写（Override）vs 重载（Overload）vs 隐藏（Hide）


一、继承：代码复用与层次化设计继承是派生类从基类获取成员（属性 + 行为）的机制，核心是 “基于已有类扩展功能”。
1. 继承方式与成员访问权限继承方式决定基类成员在派生类中的访问权限，常用public继承（其他方式极少用）。



基类成员权限
public 继承（常用）
protected 继承
private 继承



public
派生类 public
派生类 protected
派生类 private


protected
派生类 protected
派生类 protected
派生类 private


private
派生类不可访问
派生类不可访问
派生类不可访问


2. 派生类的构造与析构构造函数
执行顺序：先调用基类构造函数（初始化基类部分）→ 再调用派生类构造函数（初始化新增部分）。
关键规则：若基类无默认构造函数（无参 &#x2F; 全默认参数），派生类必须在初始化列表中显式调用基类带参构造（否则编译报错）。

析构函数
执行顺序：先调用派生类析构函数（清理派生类资源）→ 再调用基类析构函数（清理基类资源）。
核心考点：基类析构函数必须加virtual（虚析构），否则通过基类指针删除派生类对象时，仅调用基类析构，导致派生类资源泄漏。

3. 菱形继承与虚继承菱形继承问题
场景：派生类间接继承同一基类多次（如 D 继承 B 和 C，B 和 C 均继承 A）。
后果：基类成员在派生类中存在多份拷贝，导致数据冗余和访问二义性（如d.a无法确定访问哪个 A 的成员）。

解决方案：虚继承
语法：在间接继承路径中加virtual关键字（如class B : virtual public A）。
原理：虚继承的派生类通过虚基类表指针（vbptr） 间接访问基类成员，确保基类在最终派生类中仅存一份实例。
关键规则：虚基类的构造函数由最终派生类负责初始化（而非直接派生类）。


二、多态：接口复用与动态行为多态是 “同一接口，不同实现”，按绑定时机分静态多态和动态多态，核心考察动态多态。
1. 静态多态（编译期多态）
绑定时机：编译阶段确定调用哪个函数。
实现方式：
函数重载：同一作用域内同名函数，参数列表（类型 &#x2F; 个数 &#x2F; 顺序）不同。
模板：参数类型不同时，编译器生成不同版本的函数 &#x2F; 类。



2. 动态多态（运行期多态，面试核心）
绑定时机：运行阶段根据对象实际类型确定调用的函数。
实现条件（缺一不可）：
基类声明虚函数（加virtual关键字）。
派生类重写（override显式标注）该虚函数。
通过基类指针或引用指向派生类对象，调用虚函数。



（1）虚函数重写规则
派生类函数与基类函数的函数名、参数列表、返回类型完全一致（返回类型可协变：基类返回Base*，派生类可返回Derived*）。
基类函数必须带virtual（派生类可省略virtual，但不推荐，显式标注更清晰）。
访问权限可不同（如基类public，派生类protected），但通过基类指针调用时需满足基类访问权限。

（2）底层实现：虚函数表（vtable）+ 虚指针（vptr）
虚函数表（vtable）：每个含虚函数的类（基类 &#x2F; 派生类）有一个全局唯一的 vtable，存储该类所有虚函数的地址。
虚指针（vptr）：每个对象包含一个 vptr 成员（64 位系统占 8 字节），指向所属类的 vtable。
动态绑定流程：
基类声明虚函数，编译器为基类生成 vtable，存入基类虚函数地址。
派生类重写虚函数，编译器为派生类生成 vtable，重写函数地址替换为派生类版本，未重写的仍指向基类版本。
对象创建时，vptr 初始化指向所属类的 vtable。
调用虚函数（如base_ptr-&gt;func()），通过 vptr 找到 vtable，调用对应函数地址（运行时确定）。



（3）纯虚函数与抽象类
纯虚函数：未实现的虚函数，语法virtual void func() = 0;，用于定义接口。
抽象类：含纯虚函数的类，不能实例化对象（仅作为基类）。
派生类规则：必须实现基类所有纯虚函数，否则仍是抽象类（无法实例化）。


三、核心概念区分重写（Override）vs 重载（Overload）vs 隐藏（Hide）


对比维度
重写（Override）
重载（Overload）
隐藏（Hide）



作用域
不同作用域（基类 vs 派生类）
同一作用域（如同一类 &#x2F; 命名空间）
不同作用域（基类 vs 派生类）


函数关系
基类虚函数与派生类同名函数
同名函数
派生类函数与基类同名，但不满足重写


关键条件
函数名、参数、返回值完全一致
参数列表不同（类型 &#x2F; 个数 &#x2F; 顺序）
不满足重写条件（如基类非虚函数）


多态类型
动态多态（运行期绑定）
静态多态（编译期绑定）
无多态（直接调用派生类函数）


访问基类函数
直接调用（基类指针 &#x2F; 引用触发）
按实参类型匹配
需用基类名限定（Base::func()）


虚函数的限制
静态成员函数不能是虚函数（无this指针，无法访问 vptr，无法动态绑定）。
构造函数不能是虚函数（对象构造时 vptr 尚未初始化，无法访问 vtable）。
内联函数可以是虚函数，但触发动态绑定时，内联优化失效（内联是编译期，动态绑定是运行期）。
友元函数不能是虚函数（友元不是类成员，无this指针，无法关联 vtable）。

]]></content>
      <categories>
        <category>C++</category>
        <category>4. 面向对象编程OOP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型与高并发</title>
    <url>/posts/567736fd.html</url>
    <content><![CDATA[核心要点速览
五大 IO 模型：阻塞 IO（低并发）、非阻塞 IO（忙等）、IO 多路复用（高并发核心）、信号驱动 IO（极少用）、异步 IO（理想模型）
IO 多路复用：select（位图，FD 上限 1024）、poll（动态数组，轮询）、epoll（Linux 首选，O (1) 事件驱动）
同步 vs 异步：同步需等待 IO 就绪 &#x2F; 完成（阻塞 &#x2F; 非阻塞 &#x2F; IO 多路复用），异步无需等待（内核回调通知）
高并发模型：Reactor（事件驱动）、多线程 Reactor（主线程 epoll + 子线程池处理任务）
核心选择：百万级并发选「epoll + 线程池 + ET 模式」，中高并发选「epoll&#x2F;poll + 有限线程」，低并发选「BIO + 线程池」


一、同步 IO 与异步 IO核心定义
同步 IO：线程发起 IO 请求后，必须等待 IO 操作（就绪或数据拷贝）完成才能继续执行，线程主动参与等待过程。
典型：阻塞 IO、非阻塞 IO、IO 多路复用（select&#x2F;poll&#x2F;epoll）。


异步 IO：线程发起 IO 请求后，无需等待，可直接执行其他任务；内核完成 “数据拷贝” 后，通过回调 &#x2F; 信号通知线程处理结果。
典型：POSIX AIO、Windows IOCP。



关键差异
同步 IO 的核心是 “线程等待 IO 就绪 &#x2F; 完成”，即使非阻塞 IO 的轮询，线程仍在主动消耗 CPU；
异步 IO 的核心是 “线程不参与 IO 等待和数据拷贝”，完全由内核处理，效率最高但兼容性差。
易错点：IO 多路复用是同步 IO（需线程主动读取就绪数据，并非内核自动推送）。


二、五大 IO 模型详解IO 操作核心流程：「发起 IO 请求→等待 IO 就绪→数据拷贝」，模型差异集中在 “等待就绪” 和 “数据拷贝” 的实现方式。
1. 阻塞 IO（BIO）：最简单的低并发模型
原理：线程发起 IO 请求（如recv&#x2F;accept）后，内核阻塞线程，直到数据拷贝完成（从网卡→用户缓冲区）才唤醒线程。
流程：发起请求→内核阻塞线程→数据拷贝完成→线程唤醒返回。
优点：实现简单，无需处理非阻塞逻辑，开发成本低。
缺点：1 线程只能处理 1 连接，并发能力极差（线程阻塞期间无法做其他事）。
适用场景：连接数少（千级以下）、逻辑简单的场景（如本地工具、小规模服务）。

2. 非阻塞 IO（NIO）：轮询式低效模型
原理：通过fcntl设置 Socket 为非阻塞，线程发起 IO 请求后，内核立即返回（无论数据是否就绪）；数据未就绪时返回EAGAIN，线程需主动轮询重试。
流程：发起请求→数据未就绪→返回EAGAIN→轮询重试→数据就绪→数据拷贝→返回结果。
优点：线程不阻塞，理论可处理多个连接。
缺点：轮询导致 CPU 空转，资源利用率极低，极少单独使用。
适用场景：配合 IO 多路复用使用（避免单独轮询的 CPU 浪费）。

3. IO 多路复用：高并发核心模型
原理：通过 “中间组件”（select&#x2F;poll&#x2F;epoll）管理多个 Socket（FD），线程阻塞在中间组件上，而非单个 IO 请求；任一 FD 就绪时，中间组件通知线程处理该 FD 的 IO。
流程：注册 FD 到中间组件→线程阻塞在epoll_wait&#x2F;select→FD 就绪→中间组件返回就绪 FD→线程处理 IO（recv&#x2F;send）。
核心优势：单线程 &#x2F; 少量线程处理大量连接（避免线程阻塞在单个 IO），CPU 利用率高。

三种实现对比


实现
底层结构
最大 FD 限制
效率
核心缺陷



select
位图（bitmask）
1024（固定）
O (n)（轮询）
FD 上限低、轮询开销大（高并发卡顿）


poll
动态数组（fdset）
无（理论）
O (n)（轮询）
轮询开销大，无 FD 上限但高并发低效


epoll
红黑树 + 就绪链表
无（系统限制）
O (1)（事件驱动）
仅支持 Linux（平台依赖）


epoll 核心优化
事件驱动而非轮询：内核通过回调机制记录就绪 FD，无需遍历所有注册 FD，效率 O (1)。
共享内存：FD 注册信息存储在内核态，避免用户态与内核态频繁数据拷贝。
支持两种触发模式：
水平触发（LT，默认）：FD 缓冲区有数据则持续通知，易用不易漏数据（适合大多数场景）。
边缘触发（ET）：仅数据 “首次到来” 时通知一次，需一次性读完缓冲区数据，效率更高（适合高并发）。



4. 信号驱动 IO：极少使用的模型
原理：线程通过sigaction注册SIGIO信号回调，发起 IO 请求后不阻塞；IO 就绪时，内核发送信号，线程在回调中处理 IO。
优点：无需轮询，CPU 利用率高。
缺点：信号处理逻辑复杂（竞态、嵌套），调试困难，实际场景极少使用。

5. 异步 IO：理想但难用的模型
原理：线程发起 IO 请求时指定回调函数，立即返回执行其他任务；内核完成 “数据拷贝” 后，调用回调函数通知线程。
流程：发起aio_read（指定回调）→线程执行其他任务→内核完成数据拷贝→触发回调。
优点：线程完全不参与 IO 等待和数据拷贝，并发效率最高。
缺点：跨平台支持差（Linux AIO 不成熟，Windows IOCP 常用），开发复杂度高。
适用场景：Windows 高并发服务（如游戏服务器），Linux 场景下极少用。


三、高并发核心模型：Reactor 模式1. 核心原理
事件驱动架构：通过epoll监控所有 IO 事件（连接、读、写），事件就绪后分发到对应的处理器（连接处理器、读处理器、写处理器）。
核心组件：
事件多路分发器：epoll，负责监控 FD 事件。
事件处理器：处理具体事件（如accept新连接、recv数据、send响应）。
事件队列：存储就绪事件，供分发器调度。



2. 多线程 Reactor（生产环境首选）
架构：主线程负责epoll事件监控和连接建立（accept），新连接分配给子线程池；子线程处理 IO 读写和业务逻辑。
优势：
主线程不处理业务，避免 IO 阻塞影响事件监控。
线程池复用线程，降低线程创建 &#x2F; 切换开销。
支持百万级并发（epoll管理 FD + 线程池处理业务）。




四、高并发瓶颈与 IO 模型选择1. 核心瓶颈
线程阻塞：BIO 模型中线程阻塞在 IO，限制并发数。
线程切换开销：多线程模型中，大量线程切换消耗 CPU 资源。
内核态 &#x2F; 用户态拷贝：频繁数据拷贝（如 select 的 FD 集合拷贝）降低效率。

2. 分场景 IO 模型选择


并发量级
推荐模型
核心原因



百万级（如 Web&#x2F;IM）
epoll（ET 模式）+ 多线程 Reactor + 线程池
epoll O (1) 效率，ET 模式减少通知，线程池处理业务


万级（中高并发）
epoll&#x2F;poll + 有限线程
平衡资源开销与并发能力，无需复杂架构


千级以下（低并发）
BIO + 线程池
开发简单，无需复杂 IO 管理


3. 高并发优化策略
采用 epoll ET 模式：减少事件通知次数，需一次性读完缓冲区数据。
非阻塞 IO 配合 ET 模式：避免 IO 操作阻塞线程。
线程池隔离业务逻辑：主线程仅处理 IO 事件，业务逻辑交给子线程。
减少数据拷贝：使用内存池、零拷贝技术（如sendfile）。


五、问答1. epoll 的 LT 和 ET 模式有什么区别？
LT（水平触发）：FD 缓冲区有数据则持续通知，直到数据读完；易用，不会漏数据，默认模式。
ET（边缘触发）：仅数据 “首次到来” 时通知一次，需一次性读完缓冲区；效率高，减少通知次数，适合高并发，但需处理非阻塞 IO 避免漏读。

2. 为什么 IO 多路复用是同步 IO 而非异步 IO？因为 IO 多路复用仅解决 “等待 IO 就绪” 的阻塞问题，线程仍需主动调用recv&#x2F;send完成数据拷贝（IO 操作的核心步骤）；异步 IO 的核心是内核自动完成数据拷贝并通知线程，线程无需参与 IO 操作。
3. epoll 比 select&#x2F;poll 高效的原因是什么？
事件驱动而非轮询：无需遍历所有注册 FD，仅处理就绪事件。
共享内存：FD 注册信息存储在内核，避免用户态与内核态频繁拷贝。
无 FD 上限：红黑树存储 FD，支持海量连接（仅受系统资源限制）。

]]></content>
      <categories>
        <category>C++</category>
        <category>9. 网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络</tag>
        <tag>IO模型</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分区</title>
    <url>/posts/b5d386b7.html</url>
    <content><![CDATA[核心要点速览
五大核心分区：栈（临时空间，自动管理）、堆（动态空间，手动管理）、全局 &#x2F; 静态区（持久空间）、常量存储区（只读）、代码区（指令存储）
关键考点：各分区存储内容 &#x2F; 生命周期 &#x2F; 分配方式、栈与堆的区别、const 变量存储位置、线程局部存储特性
高频问答：全局 &#x2F; 局部 &#x2F; 静态局部变量的存储与生命周期


一、五大核心内存分区1. 栈（stack）：函数调用的临时空间
存储内容：局部变量、函数参数、返回地址、寄存器上下文
生命周期：函数调用时创建，函数返回时自动释放
关键特点：
分配方式：编译器自动分配，仅移动栈顶指针（效率极高）
内存特性：地址连续，生长方向向下（高地址→低地址）
大小限制：固定（通常几 MB），超出则栈溢出（递归过深、局部数组过大）



2. 堆（heap）：动态分配的手动管理空间
存储内容：new&#x2F;malloc 动态分配的内存
生命周期：手动分配（new&#x2F;malloc）→ 手动释放（delete&#x2F;free），未释放则程序结束后由 OS 回收
关键特点：
分配方式：程序员手动调用，需查找空闲内存块（效率低于栈）
内存特性：地址不连续，生长方向向上（低地址→高地址）
潜在问题：频繁分配 &#x2F; 释放产生内存碎片，未释放导致内存泄漏



3. 全局 &#x2F; 静态存储区
存储内容：全局变量（函数外定义）、静态变量（static 修饰，含全局静态 &#x2F; 局部静态）
生命周期：程序启动（main 前）→ 程序结束（main 后），OS 自动释放
关键特点：
分配方式：编译期确定大小，程序加载时 OS 分配
默认初始化：未初始化的变量自动置 0（区别于栈的 “垃圾值”）
作用域差异：全局变量作用域为整个程序，静态变量作用域限于定义位置



4. 常量存储区
存储内容：字符串常量（如&quot;hello&quot;）、全局 const 常量
生命周期：程序全程（加载→结束）
关键特点（面试易错）：
内存只读（修改触发未定义行为，如崩溃）
字符串常量可能被编译器优化共享（如多个&quot;hello&quot;指向同一地址）
区分：const 局部变量存储在栈上（仅不可修改，生命周期同局部变量）；char arr[] = &quot;hello&quot;的内容存储在栈上（拷贝常量区字符串）



5. 代码区
存储内容：程序机器指令（二进制代码）、只读数据（常量表达式）
生命周期：程序全程（加载→结束）
关键特点：
内存只读（防止指令被篡改）
可共享：多线程运行同一程序时，共享同一份代码区（节省内存）




二、核心对比表


分区
存储内容
生命周期
分配方式
管理方式



栈
局部变量、参数、返回地址
函数调用期间
编译器自动
自动释放


堆
动态分配内存（new&#x2F;malloc）
手动分配→手动释放
程序员手动
手动释放（delete&#x2F;free）


全局 &#x2F; 静态存储区
全局变量、静态变量
程序全程
编译期分配
程序结束自动释放


常量存储区
字符串常量、全局 const 常量
程序全程
编译期分配
程序结束自动释放


代码区
机器指令、只读数据
程序全程
程序加载时
只读不修改



三、线程局部存储（thread_local）
存储内容：thread_local修饰的变量（线程私有变量）
生命周期：线程创建→线程结束（与线程绑定）
关键特点：
每个线程拥有独立副本，互不干扰（解决多线程全局变量竞争问题）
作用域：同普通变量（局部 &#x2F; 全局），但仅当前线程可见




四、问答全局变量、局部变量、静态局部变量的存储分区与生命周期？
全局变量：全局 &#x2F; 静态存储区，生命周期为程序全程。
局部变量：栈，生命周期为函数调用期间。
静态局部变量：全局 &#x2F; 静态存储区，生命周期为程序全程（作用域限于函数内）。

]]></content>
      <categories>
        <category>C++</category>
        <category>6. 内存管理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存</tag>
        <tag>分区</tag>
      </tags>
  </entry>
  <entry>
    <title>RAII</title>
    <url>/posts/1fa3f2ba.html</url>
    <content><![CDATA[核心要点速览
核心思想：资源获取与对象初始化绑定，资源释放与对象析构绑定（构造拿资源，析构放资源）
实现：封装资源为类成员，构造获取、析构释放，可选禁止拷贝
典型应用：智能指针、互斥锁、文件句柄、网络连接
核心优势：自动释放资源、异常安全、简化代码、保障资源独占


一、核心思想RAII（Resource Acquisition Is Initialization）的本质是用对象生命周期管理资源：

对象构造时：自动获取资源（如分配内存、打开文件、加锁），确保资源获取成功后对象才有效；
对象析构时：自动释放资源（如释放内存、关闭文件、解锁），无论对象正常退出还是因异常销毁，析构函数都会执行。


二、实现原理（四步核心）
封装资源：定义类，将资源（指针、句柄、锁等）作为私有成员；
获取资源：在构造函数中获取资源，确保资源获取成功后对象才完成初始化；
释放资源：在析构函数中释放资源，覆盖所有退出场景（正常 &#x2F; 异常 &#x2F; 提前返回）；
禁止拷贝（可选）：资源不可共享时（如独占锁），删除拷贝构造和赋值运算符，避免资源重复释放。


三、典型应用场景
动态内存管理：智能指针（unique_ptr&#x2F;shared_ptr），构造接收动态内存，析构自动delete；
互斥锁管理：多线程中封装锁，构造加锁、析构解锁，避免忘记解锁导致死锁；
文件句柄管理：fstream&#x2F; 自定义文件类，构造fopen、析构fclose，避免文件描述符泄漏；
网络连接管理：对象创建时建立连接，析构时自动断开，简化连接生命周期管理。


四、核心优势
自动释放资源：无需手动调用释放函数（delete&#x2F;unlock等），避免疏忽导致的资源泄漏；
异常安全：C++ 标准保证异常抛出时，当前作用域已构造对象会自动析构，资源仍能正常释放；
简化代码：资源管理逻辑封装在类中，业务代码无需关注释放细节，提升可读性和可维护性；
资源独占性：通过禁止拷贝，确保资源不被意外共享（如unique_ptr、独占锁）。


五、资源管理方式对比表


管理方式
缺点
RAII 的优势



手动释放
易遗漏、异常下失效（释放代码未执行）
自动释放，覆盖所有退出场景


goto 跳转释放
代码混乱，多出口难维护（C 语言常用）
无需显式控制流程，依赖对象生命周期


函数末尾释放
提前返回时失效（return 前未释放）
无论退出方式，均自动执行释放逻辑



六、问答RAII 如何保证异常安全？C++ 标准规定：当异常抛出时，程序会销毁当前作用域内已构造完成的所有对象（自动调用析构函数）。RAII 将资源释放逻辑封装在析构函数中，因此即使发生异常，对象析构仍会执行，资源被正确释放，避免异常导致的资源泄漏。
]]></content>
      <categories>
        <category>C++</category>
        <category>6. 内存管理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存</tag>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/posts/91149a63.html</url>
    <content><![CDATA[核心要点速览
协议栈：TCP&#x2F;IP 四层模型（应用层→传输层→网络层→数据链路层）
TCP vs UDP：TCP 面向连接、可靠流式；UDP 无连接、高效数据报
三次握手：建立 TCP 连接，确保双方收发能力正常；四次挥手：断开连接，释放全双工通道
TIME_WAIT：客户端第四次挥手后停留 2MSL，确保 ACK 送达、旧报文失效
Socket：网络编程接口，由 “IP + 端口” 唯一标识，TCP 需按固定流程（绑定 - 监听 - 连接 - 收发）编程


一、TCP&#x2F;IP 四层模型
应用层：提供具体业务协议（HTTP、FTP、DNS），定义数据格式和交互逻辑
传输层：TCP&#x2F;UDP，负责端到端（进程间）数据传输（可靠 &#x2F; 高效）
网络层：IP 协议，负责跨网络路由转发（寻址）
数据链路层：处理物理介质上的帧传输（如以太网帧）


二、TCP 与 UDP 核心对比


对比维度
TCP（传输控制协议）
UDP（用户数据报协议）



连接性
面向连接（三次握手建连，四次挥手断连）
无连接（直接发送，无需建连）


可靠性
可靠（重传、序列号、确认、滑动窗口、拥塞控制）
不可靠（无重传，可能丢包 &#x2F; 乱序）


传输速率
低（含确认、重传等额外开销）
高（无额外开销，仅传输数据）


数据形式
字节流（无边界，需应用层定义分割）
数据报（有边界，一次收发一个完整报文）


拥塞控制
有（避免网络过载）
无（可能导致网络拥塞）


适用场景
文件传输、HTTP、邮件（需可靠性）
实时通信（视频 &#x2F; 语音）、DNS（需实时性）


1. TCP：面向连接的可靠传输
核心特性：
面向连接：通信前必须通过三次握手建立连接，结束后通过四次挥手断开。
可靠保障：通过序列号（保证有序）、确认应答（ACK，确保接收）、重传机制（丢失重发）、滑动窗口（流量控制）、拥塞控制（避免网络过载）实现数据不丢、不重、有序。
字节流：数据无天然边界，需应用层自行处理粘包 &#x2F; 半包问题。


典型协议：HTTP、FTP、SMTP、SSH。

2. UDP：无连接的高效传输
核心特性：
无连接：无需建连 &#x2F; 断连，直接发送数据，开销极低。
不可靠：不保证数据到达、有序，无重传机制（丢包需应用层处理）。
数据报：每个报文是独立单元（有边界），接收方一次接收一个完整报文（无粘包）。


典型协议：RTP（实时音视频）、DNS、DHCP、游戏数据传输。


三、三次握手与四次挥手1. 三次握手（建立 TCP 连接）
目的：确认双方 “发送” 和 “接收” 能力正常，协商初始序列号（避免历史报文干扰）。
流程（客户端→服务器）：
第一次握手：客户端发SYN报文（同步请求），携带初始序列号seq = x。
第二次握手：服务器回SYN+ACK报文（同步 + 确认），携带自身初始序列号seq = y、确认号ack = x + 1（表示已接收客户端x）。
第三次握手：客户端回ACK报文，确认号ack = y + 1（表示已接收服务器y）。


关键问答：为什么需要三次握手？
避免 “过期连接请求” 浪费服务器资源。若客户端旧SYN报文延迟到达，服务器二次握手后，客户端会因识别为无效请求而不发第三次ACK，服务器超时后释放资源（二次握手会导致服务器误建连）。



2. 四次挥手（断开 TCP 连接）
目的：TCP 是全双工通信（双方可同时发数据），需分别关闭各自的发送通道。
流程（客户端先发起关闭）：
第一次挥手：客户端发FIN报文（终止请求），seq = u，表示不再发送数据。
第二次挥手：服务器回ACK报文，ack = u + 1，表示确认关闭请求（此时服务器→客户端通道仍可发数据）。
第三次挥手：服务器数据发送完毕，发FIN报文，seq = v，表示不再发送数据。
第四次挥手：客户端回ACK报文，ack = v + 1，表示确认关闭（此时客户端→服务器通道关闭）。


关键问答：为什么需要四次挥手？
全双工特性导致：第二次挥手仅确认客户端的关闭请求，服务器可能仍有未发送完的数据，需等数据发完后，再通过第三次挥手关闭自身发送通道，因此需四次交互。



3. TIME_WAIT 状态
触发场景：客户端发送第四次挥手的ACK后进入该状态。
停留时间：默认 2MSL（MSL 是报文最大生存时间，通常 1 分钟）。
核心目的：
确保服务器能收到第四次挥手的ACK（若服务器未收到，会重发FIN，客户端可在TIME_WAIT内重传）。
避免客户端新连接收到旧连接的残留报文（2MSL 足够让网络中旧报文失效）。




四、Socket：网络编程接口1. Socket 本质
操作系统提供的网络通信接口，封装了 TCP&#x2F;UDP 底层协议细节。
唯一标识：IP地址 + 端口号（如(192.168.1.1, 8080)），对应进程间通信的端点。

2. TCP Socket 编程流程（极简示例）服务器端（被动连接）#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;int main() &#123;    // 1. 创建TCP Socket    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);    // 2. 绑定IP和端口    sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;         // IPv4    serv_addr.sin_addr.s_addr = INADDR_ANY; // 绑定所有网卡IP    serv_addr.sin_port = htons(8080);       // 端口转换为网络序    bind(listen_fd, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));    // 3. 监听（最大等待连接数10）    listen(listen_fd, 10);    // 4. 阻塞等待客户端连接（返回与该客户端通信的新Socket）    sockaddr_in client_addr;    socklen_t client_len = sizeof(client_addr);    int conn_fd = accept(listen_fd, (sockaddr*)&amp;client_addr, &amp;client_len);    // 5. 收发数据    char buf[1024] = &#123;0&#125;;    recv(conn_fd, buf, sizeof(buf), 0);     // 接收客户端数据    send(conn_fd, &quot;Hello Client&quot;, 12, 0);   // 发送响应    // 6. 关闭Socket    close(conn_fd);    close(listen_fd);    return 0;&#125;

客户端（主动连接）#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;int main() &#123;    // 1. 创建TCP Socket    int client_fd = socket(AF_INET, SOCK_STREAM, 0);    // 2. 连接服务器    sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); // 服务器IP    serv_addr.sin_port = htons(8080);                  // 服务器端口    connect(client_fd, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));    // 3. 收发数据    send(client_fd, &quot;Hello Server&quot;, 12, 0);           // 发送数据    char buf[1024] = &#123;0&#125;;    recv(client_fd, buf, sizeof(buf), 0);             // 接收响应    // 4. 关闭Socket    close(client_fd);    return 0;&#125;

3. UDP Socket 收发示例// UDP服务器端（接收数据）#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;int main() &#123;    int sock_fd = socket(AF_INET, SOCK_DGRAM, 0); // SOCK_DGRAM指定UDP    sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = INADDR_ANY;    serv_addr.sin_port = htons(8080);    bind(sock_fd, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));    char buf[1024] = &#123;0&#125;;    sockaddr_in client_addr;    socklen_t client_len = sizeof(client_addr);    // 接收数据并获取客户端地址    recvfrom(sock_fd, buf, sizeof(buf), 0, (sockaddr*)&amp;client_addr, &amp;client_len);    // 回复客户端    sendto(sock_fd, &quot;Hello UDP Client&quot;, 15, 0, (sockaddr*)&amp;client_addr, client_len);    close(sock_fd);    return 0;&#125;

4. TCP 粘包解决方案示例（消息头 + 消息体，最常用）// 发送端：打包消息（4字节长度+消息体）void send_msg(int sock_fd, const std::string&amp; data) &#123;    int len = data.size();    len = htonl(len); // 长度转换为网络序    // 先发送消息长度（4字节）    send(sock_fd, &amp;len, sizeof(len), 0);    // 再发送消息体    send(sock_fd, data.c_str(), data.size(), 0);&#125;// 接收端：解析消息（先读长度，再读对应长度的消息体）std::string recv_msg(int sock_fd) &#123;    int len = 0;    // 先接收消息长度（4字节）    recv(sock_fd, &amp;len, sizeof(len), 0);    len = ntohl(len); // 转换为主机序    // 再接收消息体    char* buf = new char[len + 1];    recv(sock_fd, buf, len, 0);    buf[len] = &#x27;\0&#x27;;    std::string data(buf);    delete[] buf;    return data;&#125;
]]></content>
      <categories>
        <category>C++</category>
        <category>9. 网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>线程基础</title>
    <url>/posts/b9f6280b.html</url>
    <content><![CDATA[核心要点速览
线程 vs 进程：进程是资源分配单位（独立内存），线程是调度单位（共享进程内存），线程通信成本更低
线程创建：std::thread支持函数、Lambda、函数对象三种方式
线程管理：join()等待回收、detach()分离（慎用）、joinable()检查状态
线程标识：std::this_thread::get_id()获取 ID，std::thread::id判断唯一性
线程状态：就绪、运行、阻塞、终止


一、线程的基本概念1. 线程与进程
进程：程序的一次执行实例，拥有独立内存空间（代码、数据、堆栈），是资源分配的最小单位。
线程：进程内的执行单元，共享进程的代码、全局数据等资源，拥有独立的栈和寄存器，是调度的最小单位。
核心区别：
资源隔离：进程间地址空间独立，线程间共享进程内存。
通信成本：进程间通信（IPC）需跨地址空间（成本高），线程间直接共享数据（成本低）。
轻量化：线程比进程更轻量，创建、切换、销毁开销更小。



2. 线程的优势
并发执行多个任务，提升程序响应速度。
充分利用多核 CPU 资源，提高 CPU 利用率。
比进程更轻量，资源消耗少、调度效率高。

3. 用户线程 vs 内核线程
用户线程：用户空间管理，不依赖内核，创建销毁快，但内核无法感知，调度需用户实现。
内核线程：内核空间管理，内核直接调度，支持真正并行，但创建销毁开销比用户线程高。
常见映射：1:1（内核线程对应用户线程）、M:N（多个用户线程映射到多个内核线程）。


二、线程创建（std::thread）C++11 std::thread标准化线程操作，跨平台兼容，无需依赖平台 API。
核心创建方式
函数 &#x2F; 函数指针：传递函数地址及参数。
Lambda 表达式：简洁高效，推荐用于短小逻辑。
类成员函数：传递成员函数指针、对象指针及参数。

关键注意事项
线程创建后需立即管理（join()或detach()），否则析构时抛出std::terminate异常。
传递参数时，默认按值拷贝，需传递引用时用std::ref&#x2F;std::cref（避免拷贝开销或悬垂引用）。


三、线程生命周期与管理1. 线程状态
就绪：已创建，等待 CPU 调度（具备运行条件）。
运行：占用 CPU，执行线程逻辑。
阻塞：因等待资源（如锁、IO）暂停执行，释放 CPU。
终止：线程执行完毕或被强制终止，资源等待回收。

2. 线程管理函数（1）join()
功能：主线程阻塞，等待子线程执行完毕后再继续，回收子线程资源（避免 “僵尸线程”）。
限制：一个线程只能调用一次join()，调用后joinable()返回false。

（2）detach()
功能：主线程与子线程分离，子线程后台运行，主线程不等待。
风险：子线程依赖的主线程资源（如局部变量）可能提前释放，导致悬垂引用（崩溃风险）。
适用场景：子线程逻辑独立，不依赖主线程局部资源，且无需主线程等待。

（3）joinable()
功能：检查线程是否可join（未调用join()&#x2F;detach()，且线程未终止）。
用途：避免重复join或detach导致的未定义行为（如join()已调用的线程）。


四、线程标识
线程 ID：std::thread::id类型，每个线程有唯一标识（可通过==&#x2F;!=判断唯一性）。
获取方式：
子线程 ID：std::thread t(func); t.get_id();
当前线程 ID：std::this_thread::get_id();


特殊 ID：默认构造的std::thread::id表示 “无关联线程”（可判断线程是否有效）。


五、易错点
未管理std::thread：创建后未调用join()&#x2F;detach()，析构时抛异常。
detach()后访问主线程局部资源：子线程可能在主线程局部变量销毁后执行，导致悬垂引用。
重复join()：对已join的线程再次调用join()，引发未定义行为（需用joinable()检查）。
线程参数按值传递：需传递引用时未用std::ref，导致拷贝开销或修改无效。

]]></content>
      <categories>
        <category>C++</category>
        <category>8. 多线程编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>动态内存</title>
    <url>/posts/58a84bc7.html</url>
    <content><![CDATA[核心要点速览
动态内存：运行时手动分配，需手动释放（否则泄漏）；new&#x2F;delete 自动调用构造 &#x2F; 析构，需与 new []&#x2F;delete [] 严格匹配
智能指针（C++11+，&lt;memory&gt;）：RAII 机制自动管理内存，unique_ptr（独占）、shared_ptr（共享，引用计数）、weak_ptr（解循环引用）
常见问题：内存泄漏（未释放）、野指针（未初始化）、悬空指针（指向已释放内存）


一、动态内存的分配与释放核心是 “分配 - 使用 - 释放” 闭环，C++ 推荐用 new&#x2F;delete，需严格匹配使用。
1. C vs C++ 分配释放方式对比


对比维度
C（malloc&#x2F;free）
C++（new&#x2F;delete）



类型安全
返回void*，需手动强转（不安全）
返回对应类型指针（无需转换，安全）


构造 &#x2F; 析构
不调用（仅操作内存）
自动调用构造（new）&#x2F; 析构（delete）


数组支持
需手动计算总大小（n*sizeof(T)）
直接new T[n]（自动计算大小）


分配失败
返回NULL
默认抛bad_alloc，可指定nothrow返回NULL


重载扩展
不可重载
可重载operator new&#x2F;operator delete定制分配


2. 关键匹配规则
单个对象：new T → delete ptr（匹配单个构造 &#x2F; 析构）
数组对象：new T[n] → delete[] ptr（匹配 n 次构造 &#x2F; 析构）
不匹配后果：
delete释放new[]：仅第一个元素析构，其余资源泄漏，可能崩溃
delete[]释放new：错误读取数组长度，多次析构，破坏内存状态



3. 底层执行流程new 的核心步骤
调用operator new(sizeof(T))：分配原始内存（底层通常调用 malloc）
调用构造函数：new(p) T(args)（placement new，在指定内存构造对象）
返回对象指针

delete 的核心步骤
调用析构函数：p-&gt;~T()（清理对象资源）
调用operator delete(p)：释放内存（底层通常调用 free）


二、常见动态内存问题1. 内存泄漏
定义：动态内存不再使用但未释放，永久占用内存
核心原因：忘记释放、指针被重赋值（地址丢失）、异常导致释放代码未执行
解决方案：用智能指针、遵循 “谁分配谁释放”、RAII 机制（对象析构自动释放）

2. 野指针
定义：未初始化的指针（指向随机内存）
危害：解引用导致未定义行为（崩溃、数据错乱）
避免方案：定义时初始化（int* p = nullptr;），释放后置为nullptr

3. 悬空指针
定义：指向已释放内存的指针（地址未置空）
危害：解引用访问无效内存（逻辑错误或崩溃）
避免方案：释放后立即置nullptr，避免重复释放


三、智能指针（C++11+，自动内存管理）基于 RAII 机制，析构时自动释放内存，彻底解决手动管理的缺陷。
1. unique_ptr：独占所有权
核心特性：同一时间仅一个unique_ptr指向内存，不可复制（禁用拷贝构造 &#x2F; 赋值），可通过std::move转移所有权
适用场景：单一所有者的动态内存（如局部动态对象、函数返回动态对象）
关键：无额外内存开销（仅封装原始指针）

2. shared_ptr：共享所有权
核心特性：多个shared_ptr共享同一内存，通过控制块维护引用计数（计数为 0 时自动释放）
控制块内容：引用计数、弱引用计数、删除器、分配器
适用场景：多所有者的动态内存（如共享资源、容器中存储动态对象）
注意：线程安全（引用计数的增减是原子操作），但对象读写需额外同步

3. weak_ptr：解决循环引用
核心特性：弱引用（不增加引用计数），仅观测shared_ptr管理的内存，不影响生命周期
核心用途：解决shared_ptr的循环引用问题（如 A 和 B 互相持有shared_ptr，导致计数无法归零）
关键操作：lock()方法获取shared_ptr（有效则返回非空，无效则返回空）

4. 循环引用示例class A &#123; public: shared_ptr&lt;B&gt; b; &#125;;class B &#123; public: shared_ptr&lt;A&gt; a; &#125;;// 循环引用：a和b的引用计数均为2，析构时无法归零，内存泄漏shared_ptr&lt;A&gt; a = make_shared&lt;A&gt;();shared_ptr&lt;B&gt; b = make_shared&lt;B&gt;();a-&gt;b = b;b-&gt;a = a;// 解决方案：将其中一个改为weak_ptr（如B的a改为weak_ptr&lt;A&gt;）


四、问答
智能指针的底层实现原理？
  智能指针是类模板，封装原始指针，通过 RAII 机制在析构时自动释放内存。unique_ptr禁用拷贝实现独占；shared_ptr通过控制块存储引用计数，计数为 0 时释放；weak_ptr指向控制块，不增减计数，用于解循环引用。


]]></content>
      <categories>
        <category>C++</category>
        <category>6. 内存管理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态内存</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>核心问题与机制</title>
    <url>/posts/739aa5fc.html</url>
    <content><![CDATA[核心要点速览
字节序：主机序（小端 &#x2F; 大端）→ 网络序（大端），转换函数htons()&#x2F;ntohs()、htonl()&#x2F;ntohl()
TCP 核心问题：粘包 &#x2F; 半包（流式无边界），解决方案：固定长度、分隔符、消息头 + 消息体（最常用）
UDP 特性：无粘包、可能丢包、数据报大小受限，读写用sendto()&#x2F;recvfrom()
并发模型：多线程 &#x2F; 多进程（简单低并发）、I&#x2F;O 多路复用（epoll 核心，高并发）、线程池 &#x2F; 进程池（平衡开销）
可靠性保障：超时（SO_RCVTIMEO）、心跳（应用层 &#x2F; TCP keepalive）、重连（指数退避）
序列化：Protobuf&#x2F;FlatBuffers（高性能）、JSON&#x2F;XML（可读性）、自定义二进制（紧凑）
安全防护：SYN 洪水（SYN Cookie）、数据加密（SSL&#x2F;TLS）、限流（防火墙 &#x2F; 应用层）


一、字节序转换（跨平台通信基础）
主机字节序：CPU 存储数据的方式，分小端（低字节存低地址，主流架构）和大端（低字节存高地址）。
网络字节序：统一为大端（避免跨平台差异），所有网络传输数据需转换为此格式。
核心转换函数：
短整型（2 字节）：htons()（主机→网络）、ntohs()（网络→主机）
长整型（4 字节）：htonl()（主机→网络）、ntohl()（网络→主机）




二、TCP 粘包与半包问题TCP 是字节流协议（无消息边界），导致接收方无法直接区分完整消息。
1. 问题成因
粘包：Nagle 算法合并小数据包、接收方缓冲区未及时读取，多个消息合并为一个 TCP 报文。
半包：消息超过 MSS（最大报文段长度）被拆分、接收方缓冲区不足，一个消息仅读取部分数据。

2. 解决方案（应用层定义消息边界）


方案类型
核心逻辑
优点
缺点



固定长度消息
约定每个消息长度固定，接收方按固定长度读取
实现简单
灵活性差，消息长度不确定时浪费带宽


分隔符标记
用特殊字符（如\r\n）作为消息结束标记
灵活，无需预设长度
需处理消息内容包含分隔符的情况


消息头 + 消息体
4 字节消息头存储消息体长度，先读头再读体
通用、灵活，无冗余
需额外解析消息头，逻辑稍复杂



最常用：消息头 + 消息体（兼顾灵活性和效率）。


三、UDP 数据报（无连接传输）1. 核心特性
无连接、无粘包（数据报独立传输）、不可靠（可能丢包、乱序）。
数据报大小受限（通常不超过 MTU，约 1500 字节），超出会被分片或丢弃。

2. 关键读写函数
sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen)：指定目标地址发送数据。
recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen)：接收数据并获取源地址。


四、并发连接处理（服务器高并发核心）1. 常见并发模型对比


模型类型
核心原理
优点
缺点
适用场景



多线程 &#x2F; 多进程（每连接一个）
为每个连接创建独立线程 &#x2F; 进程处理
实现简单，无共享状态问题
资源开销大，支持并发数有限（几千）
连接数少、逻辑复杂（如数据库连接）


I&#x2F;O 多路复用（select&#x2F;poll&#x2F;epoll）
单线程管理多个连接，仅处理有事件的连接
资源开销低，支持高并发（百万级）
逻辑复杂，需处理非阻塞 I&#x2F;O
Web 服务器、即时通讯等高并发场景


线程池 &#x2F; 进程池
预先创建固定线程 &#x2F; 进程，分配连接处理
平衡资源开销与并发能力
线程数固定，极端情况可能瓶颈
中等并发、连接生命周期短的场景


2. epoll 核心优势（Linux 高并发首选）
事件驱动而非轮询：仅通知就绪连接，效率 O (1)（select&#x2F;poll 为 O (n)）。
共享内存：fd 集合存储在内核，避免用户态与内核态频繁拷贝。
支持两种触发模式：
水平触发（LT，默认）：缓冲区有数据则持续通知，易用不易漏。
边缘触发（ET）：仅数据到来时通知一次，需一次性读完缓冲区，效率更高。




五、连接可靠性保障（避免 “假死” 连接）1. 超时处理
问题：recv()&#x2F;send()默认阻塞，连接异常时可能永久阻塞。
解决方案：用setsockopt()设置超时参数（SO_RCVTIMEO接收超时、SO_SNDTIMEO发送超时），或结合epoll_wait()的超时参数。

2. 心跳机制（检测连接存活）
原理：定期发送心跳包，未收到回应则判定连接失效。
实现方式：
应用层心跳：业务协议中加入固定格式心跳包（如每 30 秒发送，5 秒未回应断连）。
TCP keepalive：内核层定期发送探测包，默认超时较长（需调整参数）。



3. 断连重连（客户端）
核心策略：指数退避（重连间隔 1s→2s→4s→…→上限 60s），避免频繁重试冲击服务器。
限制：超过最大重试次数后报警（如网络彻底故障）。


六、数据序列化与反序列化（跨平台传输）核心要求：跨平台兼容、效率、可读性


方案类型
核心特点
优点
缺点
适用场景



自定义二进制格式
手动打包 &#x2F; 解析，处理大小端
紧凑高效，字节流小
开发复杂，兼容性差
对效率要求极高、协议固定的场景


JSON&#x2F;XML（文本格式）
文本标记数据结构
可读性好，跨平台性强
冗余大，解析效率低
调试友好、数据量小的场景


Protobuf&#x2F;FlatBuffers
IDL 定义结构，自动生成代码（二进制）
效率高，支持版本兼容
可读性差，需工具解析
高性能场景（游戏、分布式系统）



七、网络安全与攻击防护（面试高频）1. SYN 洪水攻击
原理：攻击者发送大量SYN报文但不完成三次握手，耗尽服务器半连接队列资源。
防护：开启 SYN Cookie（服务器用 Cookie 验证请求合法性，不维护半连接队列）。

2. 数据传输加密
方案：用 SSL&#x2F;TLS 协议（如 HTTPS）对传输数据加密，避免明文被窃听或篡改。

3. 端口扫描与限流
防护：防火墙限制异常 IP 连接频率，或应用层实现限流（如单 IP 每秒最多 10 次连接）。

]]></content>
      <categories>
        <category>C++</category>
        <category>9. 网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络</tag>
        <tag>问题</tag>
        <tag>机制</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串基础</title>
    <url>/posts/5f08cd61.html</url>
    <content><![CDATA[核心要点速览
C 风格字符串：以&#39;\0&#39;结尾的字符数组，依赖cstring库函数，无安全检查（易溢出）
C++ std::string：动态管理、安全便捷，支持 SSO（小字符串优化），提供丰富成员方法
拷贝关键：C 语言strcpy不安全、strncpy需补&#39;\0&#39;、strlcpy安全非标准；C++ 直接用拷贝构造 &#x2F; 赋值 &#x2F;assign


一、C 风格字符串（char[]）本质是以&#39;\0&#39;（空字符）为结束标记的字符数组，&#39;\0&#39;是字符串终止的核心标识。
1. 初始化（高频易错点）// 正确写法char str1[] = &quot;hello&quot;;  // 自动添加&#x27;\0&#x27;，数组长度6（h e l l o \0）char str2[] = &#123;&#x27;h&#x27;,&#x27;i&#x27;,&#x27;\0&#x27;&#125;;  // 手动添加&#x27;\0&#x27;，长度3char str3[10] = &quot;hi&quot;;  // 未初始化部分自动填&#x27;\0&#x27;，长度10// 错误写法char str4[] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;  // 无&#x27;\0&#x27;，strlen会越界扫描（未定义行为）

2. 核心操作函数（cstring库）


函数
功能
陷阱与注意事项



strlen(s)
计算&#39;\0&#39;前的字符数（不含&#39;\0&#39;）
无&#39;\0&#39;时越界扫描；返回值是size_t（无符号），避免与 int 比较


strcpy(dst, src)
拷贝src到dst（含&#39;\0&#39;）
dst容量不足会溢出；无长度检查，不安全


strcat(dst, src)
拼接src到dst末尾
需dst已含&#39;\0&#39;；总长度超dst容量会溢出


strcmp(s1, s2)
字典序比较
返回 0 表示相等，正数s1&gt;s2、负数s1&lt;s2；不可用==比较字符串



二、C++ std::string动态管理的字符串类，无需手动处理&#39;\0&#39;，安全便捷，是 C++ 开发首选。
1. 核心特性
动态大小：自动扩容，支持push_back、append等操作
安全保障：at()方法越界抛异常，[]无检查（需自行确保合法）
便捷操作：重载+（拼接）、==（比较）等运算符
内存优化：小字符串优化（SSO），短字符串存栈上（无需堆分配）

2. 常用方法


方法
功能
注意事项



size()&#x2F;length()
返回字符数（不含&#39;\0&#39;）
功能完全一致，仅历史原因并存


c_str()&#x2F;data()
转为 C 风格字符串（const char*）
指针有效期与string绑定，修改string后可能失效


substr(pos, len)
提取子串（从pos开始，长度len）
pos越界抛异常；len超范围则取到字符串末尾


find(sub, pos)
从pos查找sub，返回起始索引
未找到返回string::npos（需用该常量判断，而非 - 1）


reserve(n)
预分配n个字符内存
提升扩容效率，不改变size（实际字符数）


resize(n, c)
调整字符数为n，不足补字符c
可能截断长字符串或填充短字符串


3. 深入特性（1）小字符串优化（SSO）
短字符串（通常长度≤15）：直接存储在std::string对象内部（栈内存），无堆分配开销。
长字符串：存储在堆内存，string对象仅保存指针、长度、容量信息。

（2）迭代器失效
触发场景：push_back、append、resize等可能导致扩容的操作，底层内存重分配。
后果：原有迭代器、指针、引用失效（访问即未定义行为）。

（3）C 风格字符串转换
std::string → C 风格：c_str()（返回const char*，不可修改）。
C 风格 → std::string：直接赋值（string s = c_style_str;），自动识别&#39;\0&#39;。


三、字符串拷贝1. C 语言拷贝函数（cstring库）（1）strcpy（基础，不安全）
核心逻辑：拷贝src到dst，直到&#39;\0&#39;（含&#39;\0&#39;），无长度检查。
特点：支持链式操作；dst容量不足会缓冲区溢出（高危）。

（2）strncpy（带长度限制，需补&#39;\0&#39;）
核心逻辑：最多拷贝n个字节；src长度≤n时补&#39;\0&#39;，&gt;n 时不补&#39;\0&#39;。
特点：降低溢出风险，但需手动确保dst以&#39;\0&#39;结尾（否则不是合法字符串）。

（3）strlcpy（安全首选，非标准）
核心逻辑：目标缓冲区大小dest_size，最多拷贝dest_size-1字节，强制补&#39;\0&#39;。
特点：完全避免溢出；返回src长度（不含&#39;\0&#39;）；非 ISO C 标准，广泛支持（Linux&#x2F;BSD）。

（4）memcpy（按字节拷贝，通用）
核心逻辑：拷贝n个字节，不依赖&#39;\0&#39;，适用于任意数据（字符串、数组、结构体）。
字符串场景注意：需手动计算src长度（含&#39;\0&#39;），避免遗漏终止符。

2. C++ std::string拷贝方式
拷贝构造：string dest(src);
赋值运算符：string dest = src;
assign方法：dest.assign(src, pos, len);（从src第pos位拷贝len个字符）

]]></content>
      <categories>
        <category>C++</category>
        <category>3. 数组与字符串</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/custom.css</url>
    <content><![CDATA[/* 分类页面描述样式 */
.category-description {
  margin: 20px 0;
  padding: 15px;
  background-color: #f8f8f8;
  border-radius: 8px;
  border-left: 4px solid #49b1f5;
}

.category-description p {
  margin: 0;
  color: #666;
  line-height: 1.6;
}]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/comments/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
