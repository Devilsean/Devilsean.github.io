<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>共白头</title>
    <url>/posts/9a70fb8f.html</url>
    <content><![CDATA[     共白头  忽有故人心上过，回首山河已入冬。 他朝若是同淋雪，此生也算共白头。 白头若是雪可替，世间何来伤心人。 此时若有君在侧，何须淋雪作白头。   
]]></content>
      <categories>
        <category>诗词歌赋</category>
      </categories>
      <tags>
        <tag>诗词歌赋</tag>
        <tag>抒情</tag>
      </tags>
  </entry>
  <entry>
    <title>滕王阁序</title>
    <url>/posts/5c7e22c2.html</url>
    <content><![CDATA[引言《滕王阁序》是初唐诗人王勃的千古名篇，作于上元二年（675年）洪州滕王阁宴会上。文章辞藻华丽、意境壮阔，融写景、抒情、议论于一体，被誉为“千古第一骈文”。


  


原文正文&emsp;&emsp;豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰，台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电清霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。
&emsp;&emsp;时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。
&emsp;&emsp;披绣闼，俯雕甍。山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。
&emsp;&emsp;遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人；萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年。
&emsp;&emsp;嗟乎！时运不齐，命途多舛；冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！
&emsp;&emsp;勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？
&emsp;&emsp;呜呼！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔。
附：滕王阁诗
  滕王高阁临江渚，佩玉鸣鸾罢歌舞。
  画栋朝飞南浦云，珠帘暮卷西山雨。
  闲云潭影日悠悠，物换星移几度秋。
  阁中帝子今何在？槛外长江空自流。

]]></content>
      <categories>
        <category>诗词歌赋</category>
      </categories>
      <tags>
        <tag>滕王阁序</tag>
        <tag>王勃</tag>
        <tag>古典文学</tag>
      </tags>
  </entry>
  <entry>
    <title>基础与语法与数据结构：数据类型与变量</title>
    <url>/posts/52c049c7.html</url>
    <content><![CDATA[核心要点速览
数据类型分类：基本类型、复合（派生）类型、自定义类型
核心复合类型：指针、引用、数组、结构体、联合体、枚举
变量关键特性：存储类别（auto&#x2F;static&#x2F;extern 等）、初始化要求、作用域与生命周期
常量核心：const（只读）、constexpr（编译期常量）
类型转换：隐式转换（编译器自动）、显式转换（四种强制转换）


一、数据类型1.1 基本类型基本类型是 C++ 内置的基础数据类型，具有固定内存大小（部分受平台影响）和明确取值范围。



类型
典型大小（32&#x2F;64 位系统）
含义 &#x2F; 范围
面试考点



bool
1 字节
布尔值：true（1）&#x2F;false（0）
sizeof(bool)恒为 1；不可用 0 &#x2F; 非 0 代替（语法允许但不规范）


char
1 字节
ASCII 码：-128127 或 0255
区分signed char（带符号）和unsigned char（无符号）；默认符号性由编译器决定


short
2 字节
短整数：-32768~32767
与short int等价；用于节省内存


int
4 字节（通用）
整数：-2³¹~2³¹-1
平台无关性（主流编译器统一 4 字节）；计数、返回值首选类型


long
4 字节（32 位）&#x2F;8 字节（64 位）
长整数：随平台变化
避免依赖其大小，优先用固定宽度类型（如int64_t）


long long
8 字节
超长整数：-2⁶³~2⁶³-1
C++11 标准，跨平台 8 字节，适合大整数


float
4 字节
单精度浮点：有效数字 6-7 位
精度低；避免直接比较（存在误差）


double
8 字节
双精度浮点：有效数字 15-17 位
默认浮点类型（如3.14是 double）；科学计算首选


void
无大小
无类型（表示 “空”）
用于无返回值函数、void*指针（可指向任意类型）


关键补充
跨平台一致性保证：使用 C++11 固定宽度类型（定义于&lt;cstdint&gt;），如int32_t（32 位带符号）、uint64_t（64 位无符号）。
sizeof计算规则：sizeof(char)恒为 1；sizeof(int)通常 4 字节；sizeof(void)编译报错；sizeof(bool)始终为 1。

1.2 复合类型（派生类型）基于基本类型或自定义类型扩展，核心用于组合、关联或间接访问数据。
指针
存储目标变量的内存地址，大小仅与系统位数相关（32 位 4 字节，64 位 8 字节，与指向类型无关）。
核心特性：
未初始化指针为野指针（指向随机地址，操作易崩溃），需避免。
nullptr（C++11）：空指针常量，替代NULL（NULL本质是 0，易引发歧义）。
指针运算：仅对数组指针有效（p++步长为指向类型的大小）。
数组名本质：指向数组首元素的常量指针（不可修改指向）。



引用
变量的 “别名”，语法：类型&amp; 引用名 = 变量名，必须初始化且绑定后不可更改。




对比项
指针
引用



定义
可空（nullptr）
不可空（必须绑定变量）


指向修改
可重新指向其他变量
绑定后不可更改


初始化
可延迟初始化（风险高）
必须定义时初始化


内存占用
占内存（存储地址）
不占额外内存（编译器优化）


核心用途
动态内存管理、多级间接访问
函数参数 &#x2F; 返回值（避免拷贝）、简化代码


结构体（Struct）
组合多个不同类型数据（成员）为一个整体，成员按顺序占用独立内存。
核心特性：结构体大小 &#x3D; 成员大小之和 + 内存对齐填充字节。
用途：存储关联数据（如个人信息：姓名、年龄、身高）。

联合体（Union）
所有成员共享同一块内存，同一时间仅能有效使用一个成员。




对比项
结构体（Struct）
联合体（Union）



内存分配
成员独立占用内存，总大小 &#x3D; 成员和 + 填充
成员共享内存，总大小 &#x3D; 最大成员大小（+ 对齐填充）


成员关系
成员并存（可同时访问）
成员互斥（同一时间仅能用一个）


核心用途
组合关联数据
节省内存、实现类型转换


枚举（Enum）
自定义整数类型，用于组合含义相关的命名常量。
分类：
传统枚举：enum E {A, B=5, C};，成员作用域全局（易冲突），可隐式转 int。
强类型枚举（C++11 推荐）：enum class E {A, B};，作用域受限（需E::A访问），不可隐式转 int（更安全）。


赋值规则：未手动赋值时，首个常量为 0，后续依次 + 1；中间赋值后，后续常量基于该值递增。

1.3 自定义类型
由用户通过class（类）、struct（结构体）、enum（枚举）等关键字定义的类型。
核心作用：封装数据与行为，提升代码可读性和复用性。


二、变量2.1 变量的定义与初始化
定义：编译器为变量分配内存空间。

初始化：定义时赋予初始值（避免 “垃圾值”，提升代码安全性）。

常见初始化方式：
  int a = 10;    // 拷贝初始化int b(20);     // 直接初始化（适合构造函数场景）int c&#123;30&#125;;     // 列表初始化（C++11，禁止窄化转换，如int&#123;3.14&#125;编译报错）int d = &#123;40&#125;;  // 拷贝列表初始化

2.2 存储类别（关键字修饰）存储类别决定变量的生命周期、作用域和存储位置。



关键字
核心特性与用途



auto（C++11）
编译器自动推导类型；不能用于函数参数（模板除外）、数组类型；推导引用需显式加&amp;


static
局部静态变量：生命周期为程序全程，首次调用初始化；全局静态变量：仅当前.cpp 可见（避免命名冲突）；类静态成员：属于类，所有对象共享


extern
声明变量 &#x2F; 函数在其他文件定义（跨文件共享）；仅声明不分配内存，带初始化则变为定义


register
提示编译器存于寄存器（C++17 后弃用，现代编译器优化足够）


mutable
仅用于类非静态成员；允许 const 成员函数修改该变量（突破 const 限制）


volatile
禁止编译器优化；变量值可能被外部因素修改（如硬件、多线程），每次访问直接读内存


2.3 常见问题解答
局部变量屏蔽全局变量时如何访问全局变量？用::（全局作用域解析符），如::global_var。
全局变量与局部static变量的初始化顺序？全局变量在main前初始化，局部static变量首次进入函数时初始化（C++11 后线程安全）；销毁顺序与初始化相反。
未初始化的局部变量和全局变量区别？局部非static变量是 “垃圾值”；全局变量和static变量会零初始化（数值为 0，指针为nullptr）。

2.4 常量常量是初始化后不可修改的变量，核心分为const和constexpr。
const（只读常量）
修饰变量：初始化后不可修改，作用域与变量一致。

修饰指针（三大场景）：
  const int* p;    // 常量指针：指向的内容不可改（*p不可改），p可改指向int* const p;    // 指针常量：p的指向不可改，*p可改const int* const p;  // 指向常量的指针常量：内容和指向均不可改

constexpr（编译期常量，C++11）
要求表达式在编译期可计算，比const更严格（const可运行期初始化）。
用途：定义数组大小、模板参数等依赖编译期常量的场景。

2.5 类型转换隐式转换（自动转换）
遵循 “安全优先” 原则，优先 “小范围→大范围”（类型提升），避免溢出。
转换顺序：bool→char→short→int→long→long long→float→double→long double。
注意：explicit关键字可禁止类的隐式类型转换。

显式转换（四种强制转换）


转换方式
核心用途
风险程度



static_cast
基本类型转换（int→double）、父类 &#x2F; 子类指针转换（无动态检查）
中等（父类→子类可能越界）


dynamic_cast
多态类型转换（仅用于含虚函数的类），运行期检查有效性
低（失败返回nullptr&#x2F; 抛异常）


const_cast
移除指针 &#x2F; 引用的const属性
高（修改原const变量会导致未定义行为）


reinterpret_cast
底层二进制重解释（如int*→char*）
极高（依赖平台，无移植性）


问答
何时用dynamic_cast？多态场景下，需将父类指针安全转为子类指针（需父类有虚函数，运行期校验合法性）。
为何避免reinterpret_cast？直接操作二进制，忽略类型安全，结果依赖平台，移植性极差。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据类型</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>基础与语法与数据结构：程序结构与预处理</title>
    <url>/posts/43ae7cb1.html</url>
    <content><![CDATA[核心要点速览
流程：预处理→编译→汇编→链接→执行
程序入口：main 函数（返回值 int，return 0 表示正常退出）
核心预处理指令：#include（头文件包含）、#define（宏定义）、条件编译（#ifdef&#x2F;#ifndef&#x2F;endif）、#pragma once（头文件防重复包含）


核心要点速览
流程：预处理→编译→汇编→链接→执行
程序入口：main 函数（返回值 int，return 0 表示正常退出）
核心预处理指令：#include（头文件包含）、#define（宏定义）、条件编译（#ifdef&#x2F;#ifndef&#x2F;endif）、#pragma once（头文件防重复包含）


一、程序结构
执行流程：预处理→编译→汇编→链接→执行
预处理是编译的第一个阶段，由预处理器处理所有以 #开头的指令，生成 “预处理后的源代码”
预处理核心操作：消除注释、展开宏、处理条件编译、引入头文件内容




阶段
核心操作
产出物
关键工具



预处理
处理 # 指令、展开宏、引入头文件
预处理后的源代码
预处理器（cpp）


编译
语法分析、语义分析、生成汇编代码
汇编文件（.s）
编译器（g++&#x2F;clang）


汇编
汇编指令转机器码
目标文件（.o&#x2F;.obj）
汇编器（as&#x2F;ML）


链接
合并目标文件、解析符号、重定位
可执行文件
链接器（ld&#x2F;Link）


二、预处理指令详解2.1 #include：头文件包含
#include &lt;header&gt;：优先搜索系统标准头文件目录（如/usr/include），用于引入标准库（如&lt;iostream&gt;、&lt;vector&gt;）
#include &quot;header&quot;：优先搜索当前源文件所在目录，再搜索系统目录，用于引入自定义头文件（如&quot;myfunc.h&quot;）

2.2 #define：宏定义宏定义在预处理阶段执行，本质是 “文本替换”，语法格式为：#define 宏名 替换文本
宏的分类
常量宏定义：直接进行文本替换（如#define PI 3.14159）
函数宏定义：带参数的文本替换（如#define MUL(a,b) a*b），非真正函数调用
#undef：用于取消已定义的宏，缩小作用域（如#undef PI）

宏与相关概念的区别
与函数的区别：
宏：无类型检查、无调用栈开销、可操作类型（如#define SWAP(T,a,b) {T t=a;a=b;b=t;}）
函数：有类型检查、有调用开销、参数类型固定


与const的区别：
宏：无类型、全局替换、不可调试、无作用域限制
const变量：有类型、有作用域、可调试、编译阶段检查



宏定义的优缺点
优点：
提升可读性：为常量或复杂表达式赋予有意义名称
便于修改：统一更新宏定义，无需逐个替换
增强可移植性：配合条件编译适配不同平台 &#x2F; 编译器


缺点：
无类型检查：仅文本替换，不校验参数类型，易藏错误
可能代码膨胀：大量使用函数宏会增大目标代码体积
作用域风险：从定义到文件结束（或#undef），易引发命名冲突



带参数宏陷阱及解决方案
运算符优先级错乱

问题：宏替换直接插入代码，不自动加括号，运算符优先级冲突导致逻辑错误
示例：#define MUL(a, b) a * b，调用MUL(2+3, 4)会替换为2+3*4=14（预期 16）
解决方案：给每个参数和整个替换体都加括号，如#define MUL(a, b) ((a) * (b))


参数副作用（多次计算）

问题：参数为副作用表达式（如i++、x+=1）时，宏替换会让参数多次计算，放大副作用
示例：#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))，调用MAX(i++, j++)会导致i和j多次自增
解决方案：
避免将带副作用的表达式作为宏参数
先将参数值存入临时变量，再传入宏（如int a_val = i++; int b_val = j++; MAX(a_val, b_val)）




重复计算（性能 + 逻辑风险）

问题：参数为复杂表达式（如函数调用、耗时计算）时，宏替换会导致表达式多次执行
影响：浪费性能，若表达式有状态依赖（如获取系统时间）会引发逻辑错误
解决方案：
避免将复杂表达式直接作为宏参数
先计算表达式结果存入临时变量，再传入宏




缺少分号导致逻辑断裂

问题：多行宏体未用{}包裹，开发者习惯加;会导致语法逻辑破坏
示例：#define PRINT() printf(&quot;a&quot;); printf(&quot;b&quot;)，在if(1) PRINT(); else ...中会提前结束 if 逻辑
解决方案：用do{...}while(0)包裹多行宏体，如#define PRINT() do{printf(&quot;a&quot;); printf(&quot;b&quot;);}while(0)


命名冲突

问题：宏作用域广（定义到文件结束），无差别替换所有匹配标识符，易与变量 &#x2F; 函数同名冲突
解决方案：
宏名采用 “全大写 + 下划线” 规范（如MAX_VALUE）
用#undef及时取消无用宏，缩小作用域
避免使用库函数名、关键字作为宏名





2.3 条件编译条件编译在预处理阶段执行，根据条件决定部分代码是否进入编译，核心用于跨平台适配、调试 &#x2F; 发布版本区分、头文件防重复包含。
核心指令
#ifdef MACRO：若MACRO已定义，则编译后续代码
#ifndef MACRO：若MACRO未定义，则编译后续代码（常用）
#if 表达式：表达式为真则编译（支持defined(MACRO)判断宏是否定义）
#else&#x2F;#elif：分支控制
#endif：结束条件编译块（必须配对）
#error：预处理阶段报错，终止编译（可用于版本 &#x2F; 系统检查）
#pragma pack(n)：设置结构体对齐字节数，如#pragma pack(1)强制 1 字节对齐

常用场景
头文件防重复包含：#ifndef HEADER_NAME_H #define HEADER_NAME_H ... #endif
跨平台适配：#if defined(WIN32) ... #elif defined(LINUX) ... #endif
调试模式控制：#ifdef DEBUG printf(&quot;调试信息&quot;); #endif

2.4 #pragma once
功能：替代#ifndef实现头文件防重复包含
特点：非 C++ 标准，但几乎所有主流编译器都支持
优势：语法简洁，无需定义头文件保护宏，预处理效率更高

三、编译：从预处理代码到汇编指令作用：对预处理后的源代码进行语法检查、语义分析、代码优化，最终生成汇编代码（.s 文件）。

关键操作：
词法分析：将代码拆分为标识符、关键字、常量、运算符等 “词法单元”。
语法分析：根据语法规则构建抽象语法树（AST），检查语法合法性（如括号不匹配、缺少分号）。
语义分析：检查语义合法性（如类型不匹配、未定义变量），并进行中间代码生成。
代码优化：对中间代码或目标代码进行优化（如常量折叠、循环展开），提升执行效率。


产出物：汇编语言文件（.s），是文本文件但可读性差。
常见工具 &#x2F; 选项：
编译器：GCC（g++）、Clang 等。
编译选项：-S（仅生成汇编代码，不进行后续步骤）、-g（生成调试信息）、-O2（开启二级优化）。



四、汇编：从汇编代码到目标文件作用：将汇编代码翻译成机器指令，生成目标文件（.o&#x2F;.obj 文件）。

关键操作：
把汇编指令映射为对应的机器码（二进制指令）。
生成符号表（记录函数、变量的名称与地址映射）。
生成重定位表（记录需要后续链接阶段修正的地址）。


产出物：目标文件（.o&#x2F;.obj），是二进制文件但不可直接执行（缺少符号解析和地址重定位）。
常见工具：汇编器（如 GNU as、Microsoft ML）。

五、链接：从目标文件到可执行程序作用：将多个目标文件和库文件（静态 &#x2F; 动态）合并，解析符号引用、重定位地址，最终生成可执行文件。

核心概念：
符号：函数、变量的名称（如main、global_var）。
符号解析：将 “符号引用”（如调用其他文件的函数）与 “符号定义”（函数实现的地址）关联。
重定位：修正目标文件中未确定的地址（如函数调用的跳转地址）。


链接类型：




类型
静态链接
动态链接



链接时机
编译阶段
运行阶段（或加载阶段）


库文件形式
静态库（.a&#x2F;.lib）
动态库（.so&#x2F;.dll）


最终体积
可执行文件包含库代码，体积大
可执行文件仅包含库引用，体积小


更新维护
库更新需重新编译可执行文件
库更新后可直接替换，无需重编译



产出物：可执行文件（如 Linux 下的 ELF 格式、Windows 下的 PE 格式）。
常见链接错误：
undefined reference：符号未定义（如函数声明了但没实现、忘记链接库文件）。
multiple definition：符号重复定义（如同一变量在多个文件中定义）。


常见工具：链接器（如 GNU ld、Microsoft Link）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>程序结构</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>基础与语法与数据结构：运算符与表达式</title>
    <url>/posts/dc2fae3c.html</url>
    <content><![CDATA[核心要点速览
逻辑运算符（&amp;&amp;&#x2F;||）：支持短路求值，右操作数可能不执行
逗号运算符（,）：按左到右执行多个表达式，返回最后一个值，优先级最低
右结合运算符：赋值运算符（&#x3D;）、条件运算符（?:）、单目运算符，优先级相同时从右到左执行


一、逻辑运算符的短路求值（&amp;&amp; &#x2F; ||）核心规则短路求值是逻辑运算符的优化特性，仅在必要时计算右操作数，直接影响代码执行结果。

&amp;&amp;（逻辑与）：左操作数为false时，直接返回false，右操作数不执行。
||（逻辑或）：左操作数为true时，直接返回true，右操作数不执行。

常见场景（含副作用表达式）
&amp;&amp;短路示例：
  int i = 0;bool res = (i == 1) &amp;&amp; (++i); // 左为false，右++i不执行// 结果：res=false，i=0（而非1）

||短路示例：
  int j = 0;bool res = (j == 0) || (++j); // 左为true，右++j不执行// 结果：res=true，j=0（而非1）

易错点
禁止将 “必须执行的代码”（如变量更新、数据写入）放在短路运算符右侧，可能因短路导致逻辑失效。
区分&amp;&amp;&#x2F;||（有短路特性）与&amp;&#x2F;|（按位运算，无短路，左右操作数均执行）。

二、逗号运算符（,）核心规则
执行顺序：按从左到右依次执行所有表达式。
返回值：最终返回最后一个表达式的值。
优先级：C++ 中优先级最低（低于赋值运算符），需用括号明确执行逻辑。

典型场景（含陷阱）
优先级陷阱（与赋值结合）：

int a = 1, 2; // 错误：等价于(a=1),2，赋值语句不合法int a = (1, 2); // 正确：返回最后一个表达式，a=2


for 循环多操作场景：

for (int i=0, j=5; i&lt;5; i++, j--) &#123; ... &#125;// 初始化：i=0和j=5同时执行；更新：i++和j--按顺序执行

考察点
考察 “返回最后一个表达式值”，常结合赋值语句预判结果。
区分 “变量声明中的逗号”（非运算符），如int a, b;是声明两个变量，并非逗号运算符。

三、右结合运算符（优先级相同时的执行顺序）核心概念结合性指 “多个优先级相同的运算符连续出现时的执行顺序”，C++ 中多数运算符为左结合，仅以下三类为右结合（面试必考）。
三类核心右结合运算符1. 赋值运算符（&#x3D;）
规则：从右到左执行，支持链式赋值。

示例：
  int a, b, c;a = b = c = 5; // 右结合：先c=5 → 再b=c → 最后a=b，结果a=b=c=5

易错点：a = 3, 4等价于(a=3),4，a 的值为 3（非 4），因逗号运算符优先级更低。


2. 条件运算符（?:）
规则：唯一的右结合双目运算符，嵌套时从右向左解析。

嵌套示例：
  int x=1, y=2, z=3;int res = x&gt;y ? x : y&gt;z ? y : z; // 等价于x&gt;y ? x : (y&gt;z ? y : z)// 结果：res=3（y&gt;z为false，取z=3）

3. 单目运算符
包含：前缀++、前缀--、*（解引用）、&amp;（取地址）、!、~、+（正）、-（负）、sizeof等。

规则：从右到左执行，常结合指针操作考察。

指针示例：
  int a=5;int* p=&amp;a;++*p; // 右结合：先*p（取a=5）→ 再++，结果a=6

易错点：区分前缀（右结合）和后缀++&#x2F;--（左结合），如*p++是左结合，先*p再p++。


四、表达式求值的核心规则表达式的求值结果由两大因素决定，这也是理解复杂表达式的关键：

运算符优先级：决定不同运算符的执行顺序（如*优先级高于+）。
结合性：当多个优先级相同的运算符连续出现时，决定执行顺序（左结合 &#x2F; 右结合，如前文的右结合运算符）。

示例：综合优先级与结合性
int a = 2, b = 3, c = 4;int res = a + b * c / 2; // 优先级：*、/ 高于 +，且 * 和 / 左结合 → 先算 b*c=12，再 12/2=6，最后 a+6=8 → res=8

int x = 10, y = 20;bool flag = x &gt; 5 || y++ &gt; 15; // 优先级：&gt; 高于 ||；|| 短路求值 → 左操作数x&gt;5为true，右操作数y++不执行 → flag=true，y=20

五、表达式的 “副作用”表达式在求值过程中，若修改了操作数的值（如++、--、赋值），则产生 “副作用”。副作用可能导致表达式求值结果依赖执行顺序，需特别注意：
int i = 1;int res = i++ + i++; // 未定义行为！C++标准未规定两个i++的执行顺序，不同编译器可能返回2（先算左再右）或3（先右再左）

规则：避免在同一表达式中对同一变量进行多次修改（如i++ + i++），此类代码行为未定义。
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>运算符</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程：线程同步</title>
    <url>/posts/895e9db.html</url>
    <content><![CDATA[核心要点速览
数据竞争：多线程并发读写共享资源（至少一个写操作）的未定义行为
互斥锁：std::mutex（基础）、lock_guard（RAII 推荐）、unique_lock（灵活，配条件变量）
条件变量：wait()（阻塞 + 释锁）、notify_one()&#x2F;notify_all()，需配互斥锁 + 谓词（解虚假唤醒）
原子操作：std::atomic（硬件级原子性，无锁），核心内存序（relaxed&#x2F;acquire&#x2F;release&#x2F;seq_cst）
读写锁：std::shared_mutex（读共享、写独占），优化读多写少场景
常见问题：死锁（固定加锁顺序避免）、虚假唤醒（谓词检查解决）、活锁 &#x2F; 饥饿（延迟 &#x2F; 公平锁缓解）


一、线程同步的目标
保证数据一致性：避免多线程读写共享资源导致的结果不可预测。
控制执行顺序：确保线程按业务逻辑要求的顺序执行（如生产者先生产，消费者后消费）。


二、核心同步机制1. 互斥锁：独占式临界区访问
核心原理：通过 “加锁 - 操作 - 解锁”，保证同一时间仅一个线程进入临界区（访问共享资源的代码段）。

关键锁类型与特性


锁类型
核心特性
适用场景



std::mutex
基础互斥锁，不可递归加锁
简单独占访问，配合 RAII 锁使用


std::lock_guard
RAII 自动管理（构造加锁、析构解锁）
无需手动控制锁，避免漏解锁 &#x2F; 异常


std::unique_lock
灵活控制（可延迟加锁、手动解锁）
配合条件变量，需动态控制锁状态


std::recursive_mutex
允许同一线程重复加锁
递归函数访问临界区（不推荐，易藏错）


std::timed_mutex
支持超时尝试加锁（try_lock_for）
避免无限阻塞，需限时获取锁场景


注意事项
std::mutex的lock()&#x2F;unlock()必须成对出现，否则引发死锁；优先用lock_guard&#x2F;unique_lock（RAII 安全）。
不可递归加锁普通std::mutex（同一线程多次lock()会死锁）。

2. 条件变量：线程间等待 - 通知
核心原理：实现线程协作，让线程在条件不满足时阻塞（释放 CPU，避免忙等），条件满足时被唤醒。

核心接口与规则
wait(lock, predicate)：先释放锁→阻塞等待→被唤醒后重新加锁→检查谓词，为true则继续，否则再次阻塞（解决虚假唤醒）。
notify_one()：唤醒一个等待线程（避免资源浪费，优先使用）。
notify_all()：唤醒所有等待线程（适合多个线程需响应条件变化）。

核心要点
必须与std::unique_lock配合：wait()需手动控制锁的释放与重获取。
必须用谓词检查条件：避免操作系统虚假唤醒（无notify时的唤醒）。
依赖互斥锁的原因：保证条件判断和修改的原子性（防止检查期间条件被篡改）。

3. 原子变量：无锁同步
核心原理：基于硬件级原子操作（如 CPULOCK指令），保证读写操作不可分割，无需加锁即可避免数据竞争。

核心特性
非阻塞：不会导致线程挂起，性能远高于互斥锁（高并发场景优先）。
支持操作：仅简单操作（++&#x2F;--&#x2F;load&#x2F;store&#x2F;exchange），复杂逻辑仍需锁。
内存序（面试高频）：
memory_order_relaxed：仅保证操作原子性，不保证内存可见性 &#x2F; 顺序。
memory_order_acquire&#x2F;release：读（acquire）后可见所有写（release）操作，保证顺序。
memory_order_seq_cst：默认，最强保证（全局顺序一致），性能略低。



关键区别
std::atomic vs volatile：
volatile：仅禁止编译器优化（每次从内存读取），不保证原子性（多线程读写仍竞争）。
atomic：保证原子性 + 内存可见性，是线程安全的。



4. 读写锁：读多写少优化
核心原理：区分读 &#x2F; 写操作，允许多线程同时读（共享锁），仅允许单线程写（独占锁）。
标准库实现：std::shared_mutex（C++17+），配合std::shared_lock（读锁）、std::unique_lock（写锁）。
适用场景：读操作远多于写操作（如缓存、配置读取），避免读操作互相阻塞。


三、同步机制对比表


机制
核心原理
优点
缺点
适用场景



互斥锁
独占临界区
适用所有场景，实现简单
阻塞，高并发性能损耗大
复杂临界区（多步操作）


条件变量
等待 - 通知机制
解决执行顺序，避免忙等
需配互斥锁，逻辑复杂
生产者 - 消费者、线程协作


原子变量
硬件级原子操作
非阻塞，性能极高
仅支持简单操作
计数器、标记位、简单共享数据


读写锁
读共享、写独占
优化读多写少场景性能
写操作可能饥饿，实现复杂
缓存、配置等读多写少场景



四、同步常见问题与解决方案1. 死锁
定义：多个线程互相等待对方释放锁，导致永久阻塞。
避免方案：
固定加锁顺序：所有线程按相同顺序加锁（如先mtx1后mtx2）。
批量加锁：用std::lock(mtx1, mtx2)一次性加锁所有需要的锁。
限时等待：用try_lock_for&#x2F;try_lock_until，超时则释放已持锁。
减少锁粒度：缩小临界区范围，缩短持有锁的时间。



2. 活锁
定义：线程不断释放 &#x2F; 重试获取锁，因相互冲突始终无法推进（看似活跃实则无进展）。
解决方案：重试前随机延迟（降低冲突概率），或引入优先级机制。

3. 饥饿
定义：部分线程长期无法获取资源（如低优先级线程被高优先级线程抢占）。
避免方案：使用公平锁（按请求顺序分配锁），限制高优先级线程执行时长。


五、问答1. 条件变量为什么必须配合互斥锁使用？
检查条件时加锁，防止检查期间条件被其他线程修改（保证条件判断原子性）。
wait()阻塞前释放锁，允许其他线程修改条件（避免线程间互相阻塞）。
唤醒后重新加锁，确保后续操作基于最新的条件状态（保证数据一致性）。

2. 如何解决条件变量的虚假唤醒？在wait()的第二个参数传入条件谓词（如wait(lock, []{ return flag; })），唤醒后再次检查条件，只有条件为true才继续执行，否则重新阻塞。
3. std::atomic和volatile的核心区别？volatile仅禁止编译器优化，保证变量每次从内存读取，但不保证原子性（多线程读写仍会竞争）；std::atomic既保证原子性（操作不可分割），又保证内存可见性（一个线程的修改对其他线程立即可见），是线程安全的。
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程：线程</title>
    <url>/posts/b9f6280b.html</url>
    <content><![CDATA[核心要点速览
线程 vs 进程：进程是资源分配单位（独立内存），线程是调度单位（共享进程内存），线程通信成本更低
线程创建：std::thread支持函数、Lambda、函数对象三种方式
线程管理：join()等待回收、detach()分离（慎用）、joinable()检查状态
线程标识：std::this_thread::get_id()获取 ID，std::thread::id判断唯一性
线程状态：就绪、运行、阻塞、终止


一、线程的基本概念1. 线程与进程
进程：程序的一次执行实例，拥有独立内存空间（代码、数据、堆栈），是资源分配的最小单位。
线程：进程内的执行单元，共享进程的代码、全局数据等资源，拥有独立的栈和寄存器，是调度的最小单位。
核心区别：
资源隔离：进程间地址空间独立，线程间共享进程内存。
通信成本：进程间通信（IPC）需跨地址空间（成本高），线程间直接共享数据（成本低）。
轻量化：线程比进程更轻量，创建、切换、销毁开销更小。



2. 线程的优势
并发执行多个任务，提升程序响应速度。
充分利用多核 CPU 资源，提高 CPU 利用率。
比进程更轻量，资源消耗少、调度效率高。

3. 用户线程 vs 内核线程
用户线程：用户空间管理，不依赖内核，创建销毁快，但内核无法感知，调度需用户实现。
内核线程：内核空间管理，内核直接调度，支持真正并行，但创建销毁开销比用户线程高。
常见映射：1:1（内核线程对应用户线程）、M:N（多个用户线程映射到多个内核线程）。


二、线程创建（std::thread）C++11 std::thread标准化线程操作，跨平台兼容，无需依赖平台 API。
核心创建方式
函数 &#x2F; 函数指针：传递函数地址及参数。
Lambda 表达式：简洁高效，推荐用于短小逻辑。
类成员函数：传递成员函数指针、对象指针及参数。

关键注意事项
线程创建后需立即管理（join()或detach()），否则析构时抛出std::terminate异常。
传递参数时，默认按值拷贝，需传递引用时用std::ref&#x2F;std::cref（避免拷贝开销或悬垂引用）。


三、线程生命周期与管理1. 线程状态
就绪：已创建，等待 CPU 调度（具备运行条件）。
运行：占用 CPU，执行线程逻辑。
阻塞：因等待资源（如锁、IO）暂停执行，释放 CPU。
终止：线程执行完毕或被强制终止，资源等待回收。

2. 线程管理函数（1）join()
功能：主线程阻塞，等待子线程执行完毕后再继续，回收子线程资源（避免 “僵尸线程”）。
限制：一个线程只能调用一次join()，调用后joinable()返回false。

（2）detach()
功能：主线程与子线程分离，子线程后台运行，主线程不等待。
风险：子线程依赖的主线程资源（如局部变量）可能提前释放，导致悬垂引用（崩溃风险）。
适用场景：子线程逻辑独立，不依赖主线程局部资源，且无需主线程等待。

（3）joinable()
功能：检查线程是否可join（未调用join()&#x2F;detach()，且线程未终止）。
用途：避免重复join或detach导致的未定义行为（如join()已调用的线程）。


四、线程标识
线程 ID：std::thread::id类型，每个线程有唯一标识（可通过==&#x2F;!=判断唯一性）。
获取方式：
子线程 ID：std::thread t(func); t.get_id();
当前线程 ID：std::this_thread::get_id();


特殊 ID：默认构造的std::thread::id表示 “无关联线程”（可判断线程是否有效）。


五、易错点
未管理std::thread：创建后未调用join()&#x2F;detach()，析构时抛异常。
detach()后访问主线程局部资源：子线程可能在主线程局部变量销毁后执行，导致悬垂引用。
重复join()：对已join的线程再次调用join()，引发未定义行为（需用joinable()检查）。
线程参数按值传递：需传递引用时未用std::ref，导致拷贝开销或修改无效。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程：IO模型与高并发</title>
    <url>/posts/567736fd.html</url>
    <content><![CDATA[核心要点速览
五大 IO 模型：阻塞 IO（低并发）、非阻塞 IO（忙等）、IO 多路复用（高并发核心）、信号驱动 IO（极少用）、异步 IO（理想模型）
IO 多路复用：select（位图，FD 上限 1024）、poll（动态数组，轮询）、epoll（Linux 首选，O (1) 事件驱动）
同步 vs 异步：同步需等待 IO 就绪 &#x2F; 完成（阻塞 &#x2F; 非阻塞 &#x2F; IO 多路复用），异步无需等待（内核回调通知）
高并发模型：Reactor（事件驱动）、多线程 Reactor（主线程 epoll + 子线程池处理任务）
核心选择：百万级并发选「epoll + 线程池 + ET 模式」，中高并发选「epoll&#x2F;poll + 有限线程」，低并发选「BIO + 线程池」


一、同步 IO 与异步 IO核心定义
同步 IO：线程发起 IO 请求后，必须等待 IO 操作（就绪或数据拷贝）完成才能继续执行，线程主动参与等待过程。
典型：阻塞 IO、非阻塞 IO、IO 多路复用（select&#x2F;poll&#x2F;epoll）。


异步 IO：线程发起 IO 请求后，无需等待，可直接执行其他任务；内核完成 “数据拷贝” 后，通过回调 &#x2F; 信号通知线程处理结果。
典型：POSIX AIO、Windows IOCP。



关键差异
同步 IO 的核心是 “线程等待 IO 就绪 &#x2F; 完成”，即使非阻塞 IO 的轮询，线程仍在主动消耗 CPU；
异步 IO 的核心是 “线程不参与 IO 等待和数据拷贝”，完全由内核处理，效率最高但兼容性差。
易错点：IO 多路复用是同步 IO（需线程主动读取就绪数据，并非内核自动推送）。


二、五大 IO 模型详解IO 操作核心流程：「发起 IO 请求→等待 IO 就绪→数据拷贝」，模型差异集中在 “等待就绪” 和 “数据拷贝” 的实现方式。
1. 阻塞 IO（BIO）：最简单的低并发模型
原理：线程发起 IO 请求（如recv&#x2F;accept）后，内核阻塞线程，直到数据拷贝完成（从网卡→用户缓冲区）才唤醒线程。
流程：发起请求→内核阻塞线程→数据拷贝完成→线程唤醒返回。
优点：实现简单，无需处理非阻塞逻辑，开发成本低。
缺点：1 线程只能处理 1 连接，并发能力极差（线程阻塞期间无法做其他事）。
适用场景：连接数少（千级以下）、逻辑简单的场景（如本地工具、小规模服务）。

2. 非阻塞 IO（NIO）：轮询式低效模型
原理：通过fcntl设置 Socket 为非阻塞，线程发起 IO 请求后，内核立即返回（无论数据是否就绪）；数据未就绪时返回EAGAIN，线程需主动轮询重试。
流程：发起请求→数据未就绪→返回EAGAIN→轮询重试→数据就绪→数据拷贝→返回结果。
优点：线程不阻塞，理论可处理多个连接。
缺点：轮询导致 CPU 空转，资源利用率极低，极少单独使用。
适用场景：配合 IO 多路复用使用（避免单独轮询的 CPU 浪费）。

3. IO 多路复用：高并发核心模型
原理：通过 “中间组件”（select&#x2F;poll&#x2F;epoll）管理多个 Socket（FD），线程阻塞在中间组件上，而非单个 IO 请求；任一 FD 就绪时，中间组件通知线程处理该 FD 的 IO。
流程：注册 FD 到中间组件→线程阻塞在epoll_wait&#x2F;select→FD 就绪→中间组件返回就绪 FD→线程处理 IO（recv&#x2F;send）。
核心优势：单线程 &#x2F; 少量线程处理大量连接（避免线程阻塞在单个 IO），CPU 利用率高。

三种实现对比


实现
底层结构
最大 FD 限制
效率
核心缺陷



select
位图（bitmask）
1024（固定）
O (n)（轮询）
FD 上限低、轮询开销大（高并发卡顿）


poll
动态数组（fdset）
无（理论）
O (n)（轮询）
轮询开销大，无 FD 上限但高并发低效


epoll
红黑树 + 就绪链表
无（系统限制）
O (1)（事件驱动）
仅支持 Linux（平台依赖）


epoll 核心优化
事件驱动而非轮询：内核通过回调机制记录就绪 FD，无需遍历所有注册 FD，效率 O (1)。
共享内存：FD 注册信息存储在内核态，避免用户态与内核态频繁数据拷贝。
支持两种触发模式：
水平触发（LT，默认）：FD 缓冲区有数据则持续通知，易用不易漏数据（适合大多数场景）。
边缘触发（ET）：仅数据 “首次到来” 时通知一次，需一次性读完缓冲区数据，效率更高（适合高并发）。



4. 信号驱动 IO：极少使用的模型
原理：线程通过sigaction注册SIGIO信号回调，发起 IO 请求后不阻塞；IO 就绪时，内核发送信号，线程在回调中处理 IO。
优点：无需轮询，CPU 利用率高。
缺点：信号处理逻辑复杂（竞态、嵌套），调试困难，实际场景极少使用。

5. 异步 IO：理想但难用的模型
原理：线程发起 IO 请求时指定回调函数，立即返回执行其他任务；内核完成 “数据拷贝” 后，调用回调函数通知线程。
流程：发起aio_read（指定回调）→线程执行其他任务→内核完成数据拷贝→触发回调。
优点：线程完全不参与 IO 等待和数据拷贝，并发效率最高。
缺点：跨平台支持差（Linux AIO 不成熟，Windows IOCP 常用），开发复杂度高。
适用场景：Windows 高并发服务（如游戏服务器），Linux 场景下极少用。


三、高并发核心模型：Reactor 模式1. 核心原理
事件驱动架构：通过epoll监控所有 IO 事件（连接、读、写），事件就绪后分发到对应的处理器（连接处理器、读处理器、写处理器）。
核心组件：
事件多路分发器：epoll，负责监控 FD 事件。
事件处理器：处理具体事件（如accept新连接、recv数据、send响应）。
事件队列：存储就绪事件，供分发器调度。



2. 多线程 Reactor（生产环境首选）
架构：主线程负责epoll事件监控和连接建立（accept），新连接分配给子线程池；子线程处理 IO 读写和业务逻辑。
优势：
主线程不处理业务，避免 IO 阻塞影响事件监控。
线程池复用线程，降低线程创建 &#x2F; 切换开销。
支持百万级并发（epoll管理 FD + 线程池处理业务）。




四、高并发瓶颈与 IO 模型选择1. 核心瓶颈
线程阻塞：BIO 模型中线程阻塞在 IO，限制并发数。
线程切换开销：多线程模型中，大量线程切换消耗 CPU 资源。
内核态 &#x2F; 用户态拷贝：频繁数据拷贝（如 select 的 FD 集合拷贝）降低效率。

2. 分场景 IO 模型选择


并发量级
推荐模型
核心原因



百万级（如 Web&#x2F;IM）
epoll（ET 模式）+ 多线程 Reactor + 线程池
epoll O (1) 效率，ET 模式减少通知，线程池处理业务


万级（中高并发）
epoll&#x2F;poll + 有限线程
平衡资源开销与并发能力，无需复杂架构


千级以下（低并发）
BIO + 线程池
开发简单，无需复杂 IO 管理


3. 高并发优化策略
采用 epoll ET 模式：减少事件通知次数，需一次性读完缓冲区数据。
非阻塞 IO 配合 ET 模式：避免 IO 操作阻塞线程。
线程池隔离业务逻辑：主线程仅处理 IO 事件，业务逻辑交给子线程。
减少数据拷贝：使用内存池、零拷贝技术（如sendfile）。


五、问答1. epoll 的 LT 和 ET 模式有什么区别？
LT（水平触发）：FD 缓冲区有数据则持续通知，直到数据读完；易用，不会漏数据，默认模式。
ET（边缘触发）：仅数据 “首次到来” 时通知一次，需一次性读完缓冲区；效率高，减少通知次数，适合高并发，但需处理非阻塞 IO 避免漏读。

2. 为什么 IO 多路复用是同步 IO 而非异步 IO？因为 IO 多路复用仅解决 “等待 IO 就绪” 的阻塞问题，线程仍需主动调用recv&#x2F;send完成数据拷贝（IO 操作的核心步骤）；异步 IO 的核心是内核自动完成数据拷贝并通知线程，线程无需参与 IO 操作。
3. epoll 比 select&#x2F;poll 高效的原因是什么？
事件驱动而非轮询：无需遍历所有注册 FD，仅处理就绪事件。
共享内存：FD 注册信息存储在内核，避免用户态与内核态频繁拷贝。
无 FD 上限：红黑树存储 FD，支持海量连接（仅受系统资源限制）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络</tag>
        <tag>IO模型</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>函数与指针：函数</title>
    <url>/posts/1111c3f5.html</url>
    <content><![CDATA[核心要点速览
声明与定义：可多次声明，仅能一次定义；原型需匹配参数类型 &#x2F; 个数（返回类型不影响）
参数传递：值传递（拷贝，不影响实参）、引用传递（别名，无拷贝）、指针传递（地址，支持 nullptr）
函数重载：同名 + 参数列表不同（类型 &#x2F; 个数 &#x2F; 顺序），返回类型不参与重载
内联函数：inline 修饰，建议编译器嵌入调用处（适合短函数，无循环 &#x2F; 递归）
默认参数：遵循 “靠右原则”，不可跳过右侧参数省略左侧
返回值：禁止返回局部变量引用；大型对象返回有 RVO&#x2F;NRVO 优化


一、函数的声明与定义概念
声明：告知编译器函数的 “存在及原型”（返回类型、函数名、参数类型 &#x2F; 个数），不包含实现；参数名可选（仅声明时）。
用途：解决 “调用在前、定义在后” 的编译错误，如int add(int, int);


定义：包含声明 + 函数体（具体实现），编译器会分配内存生成指令。

规则
单定义原则（ODR）：一个函数可在多个文件中声明，但仅能在一个文件中定义（否则链接报错 “重复定义”）。
原型匹配：声明与定义的参数类型、个数必须一致；返回类型可省略（默认 int，不推荐），但建议显式声明。

二、参数传递参数传递决定函数与实参的交互方式，核心分三类，重点考察适用场景与区别。
1. 值传递
规则：形参是实参的拷贝，函数内修改形参不影响实参。

优点：安全（隔离实参）、逻辑简单。

缺点：大对象拷贝开销大（如大型结构体、类对象）。

示例：
  void swap(int a, int b) &#123; int t=a; a=b; b=t; &#125; // 仅交换拷贝，实参不变int x=1, y=2; swap(x,y); // x=1, y=2（实参未变）

2. 引用传递（int&amp;）
规则：形参是实参的别名，无拷贝开销；函数内修改形参直接影响实参。

优点：效率高（无拷贝）、语法简洁、可修改实参。

约束：引用必须绑定实参（不能传字面量，如func(5)报错），绑定后不可更改指向。

示例：
  void swap(int&amp; a, int&amp; b) &#123; int t=a; a=b; b=t; &#125;int x=1, y=2; swap(x,y); // x=2, y=1（实参已交换）

3. 指针传递（int*）
规则：形参是实参的地址拷贝，通过解引用（*p）间接修改实参。

优点：可修改实参，支持传递nullptr（空值语义）。

缺点：需显式解引用（易漏写*），可能出现野指针（未初始化指针）。

示例：
  void swap(int* a, int* b) &#123; int t=*a; *a=*b; *b=t; &#125;int x=1, y=2; swap(&amp;x,&amp;y); // x=2, y=1（通过地址修改）

三类传递方式对比表


对比维度
值传递
引用传递
指针传递



内存开销
拷贝实参（大对象开销大）
无拷贝（仅别名）
拷贝地址（4&#x2F;8 字节，固定）


实参修改
不可修改
可直接修改
可修改（需解引用）


空值传递
不支持
不支持（必须绑定对象）
支持（传nullptr）


适用场景
小对象、无需修改实参
大对象、需修改实参
需 “空值” 语义的场景


语法复杂度
简单（直接传值）
简洁（传变量名）
复杂（传地址 + 解引用）


三、返回值1. 返回值类型与规则
基本类型（int&#x2F;double等）：直接返回值拷贝，无额外风险。
自定义类型（类 &#x2F; 结构体）：返回对象副本，编译器可能触发返回值优化（RVO&#x2F;NRVO） ，避免临时对象拷贝。
引用返回（&amp;）：
优点：无拷贝，效率高（适合大对象）。

禁忌：禁止返回局部变量的引用（局部变量生命周期随函数结束，引用变为 “悬垂引用”，访问即未定义行为）。

示例（错误）：
int&amp; func() &#123; int x=10; return x; &#125; // x是局部变量，函数结束后销毁int&amp; res = func(); // 悬垂引用，访问res可能崩溃





2. 特殊返回值：void
表示 “无返回值”，函数体中可省略return，或用return;提前结束。
限制：不能定义void类型变量（void x;报错）；可定义void*指针（指向任意类型，需强转后使用）。

3. 返回值优化（RVO&#x2F;NRVO）
概念：编译器对 “返回大型对象” 的优化，直接在调用处构造对象，避免函数返回时的临时对象拷贝。
特点：无需手动修改代码，编译器自动触发（主流编译器均支持），显著提升大型对象返回效率。

四、函数重载核心定义同一作用域中，函数名相同但参数列表不同，用于实现 “同一功能的不同参数版本”。
重载的条件（缺一不可）
同一作用域（如同一命名空间、同一类）。
函数名完全相同。
参数列表不同（满足任一即可）：
参数类型不同（如add(int, int) vs add(double, double)）；
参数个数不同（如add(int) vs add(int, int)）；
参数顺序不同（如func(int, double) vs func(double, int)）。


补充场景（易忽略）：
参数为引用 &#x2F; 指针时，const修饰可形成重载（如func(int&amp;) vs func(const int&amp;)）；
类的成员函数中，const修饰this指针可形成重载（如void show() vs void show() const）。



重载的排除条件
返回类型不同不能形成重载（如int add(int) vs double add(int)，编译报错）；
参数名不同不能形成重载（如add(int a) vs add(int b)，视为同一函数）。

重载决议（编译器匹配逻辑）编译器按 “实参与形参的匹配度” 选择最佳函数，匹配度从高到低：

精确匹配（类型完全一致，含const匹配）；
提升转换（如char→int、float→double）；
标准转换（如int→double、int*→void*）；
用户定义转换（如类的构造函数、运算符重载）。


若匹配度相同（歧义），编译报错（需显式类型转换解决）。

五、内联函数（inline）特性
作用：建议编译器将函数体 “嵌入” 调用处（而非生成函数调用指令），减少栈帧创建 &#x2F; 销毁的开销。
建议性：inline是编译器 “建议”，非强制 —— 若函数含循环、递归、复杂分支，编译器会忽略inline，按普通函数处理。
定义即声明：内联函数需在调用前定义（不能仅声明），通常放在头文件中（方便多个编译单元包含）。
避免重复定义：允许在多个编译单元中定义，但所有定义必须完全一致（否则链接报错）。

与宏（#define）的区别


对比维度
内联函数（inline）
宏（#define）



类型检查
有（编译期校验参数类型）
无（文本替换，无类型校验）


调试支持
支持（可打断点、查看变量）
不支持（替换后无宏信息）


复杂逻辑支持
支持（循环、分支等）
不适合（易因优先级出错）


作用域
受作用域限制（如局部内联）
全局替换（无作用域）


副作用风险
低（参数仅计算一次）
高（参数可能多次计算）


六、默认参数规则
靠右原则：默认参数必须从右往左连续指定，不能跳过右侧参数省略左侧参数。

示例（正确 vs 错误）：
  void func(int a, int b=2, int c=3); // 正确（从右往左指定）func(1); // 等价于func(1,2,3)func(1,4); // 等价于func(1,4,3)// func(,4,5); // 错误（跳过左侧a，未指定默认值）

声明与定义一致性：默认参数仅需在声明或定义中指定一次（建议在声明中指定，方便外部调用者查看）。


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程：问题与机制</title>
    <url>/posts/739aa5fc.html</url>
    <content><![CDATA[核心要点速览
字节序：主机序（小端 &#x2F; 大端）→ 网络序（大端），转换函数htons()&#x2F;ntohs()、htonl()&#x2F;ntohl()
TCP 核心问题：粘包 &#x2F; 半包（流式无边界），解决方案：固定长度、分隔符、消息头 + 消息体（最常用）
UDP 特性：无粘包、可能丢包、数据报大小受限，读写用sendto()&#x2F;recvfrom()
并发模型：多线程 &#x2F; 多进程（简单低并发）、I&#x2F;O 多路复用（epoll 核心，高并发）、线程池 &#x2F; 进程池（平衡开销）
可靠性保障：超时（SO_RCVTIMEO）、心跳（应用层 &#x2F; TCP keepalive）、重连（指数退避）
序列化：Protobuf&#x2F;FlatBuffers（高性能）、JSON&#x2F;XML（可读性）、自定义二进制（紧凑）
安全防护：SYN 洪水（SYN Cookie）、数据加密（SSL&#x2F;TLS）、限流（防火墙 &#x2F; 应用层）


一、字节序转换（跨平台通信基础）
主机字节序：CPU 存储数据的方式，分小端（低字节存低地址，主流架构）和大端（低字节存高地址）。
网络字节序：统一为大端（避免跨平台差异），所有网络传输数据需转换为此格式。
核心转换函数：
短整型（2 字节）：htons()（主机→网络）、ntohs()（网络→主机）
长整型（4 字节）：htonl()（主机→网络）、ntohl()（网络→主机）




二、TCP 粘包与半包问题TCP 是字节流协议（无消息边界），导致接收方无法直接区分完整消息。
1. 问题成因
粘包：Nagle 算法合并小数据包、接收方缓冲区未及时读取，多个消息合并为一个 TCP 报文。
半包：消息超过 MSS（最大报文段长度）被拆分、接收方缓冲区不足，一个消息仅读取部分数据。

2. 解决方案（应用层定义消息边界）


方案类型
核心逻辑
优点
缺点



固定长度消息
约定每个消息长度固定，接收方按固定长度读取
实现简单
灵活性差，消息长度不确定时浪费带宽


分隔符标记
用特殊字符（如\r\n）作为消息结束标记
灵活，无需预设长度
需处理消息内容包含分隔符的情况


消息头 + 消息体
4 字节消息头存储消息体长度，先读头再读体
通用、灵活，无冗余
需额外解析消息头，逻辑稍复杂



最常用：消息头 + 消息体（兼顾灵活性和效率）。


三、UDP 数据报（无连接传输）1. 核心特性
无连接、无粘包（数据报独立传输）、不可靠（可能丢包、乱序）。
数据报大小受限（通常不超过 MTU，约 1500 字节），超出会被分片或丢弃。

2. 关键读写函数
sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen)：指定目标地址发送数据。
recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen)：接收数据并获取源地址。


四、并发连接处理（服务器高并发核心）1. 常见并发模型对比


模型类型
核心原理
优点
缺点
适用场景



多线程 &#x2F; 多进程（每连接一个）
为每个连接创建独立线程 &#x2F; 进程处理
实现简单，无共享状态问题
资源开销大，支持并发数有限（几千）
连接数少、逻辑复杂（如数据库连接）


I&#x2F;O 多路复用（select&#x2F;poll&#x2F;epoll）
单线程管理多个连接，仅处理有事件的连接
资源开销低，支持高并发（百万级）
逻辑复杂，需处理非阻塞 I&#x2F;O
Web 服务器、即时通讯等高并发场景


线程池 &#x2F; 进程池
预先创建固定线程 &#x2F; 进程，分配连接处理
平衡资源开销与并发能力
线程数固定，极端情况可能瓶颈
中等并发、连接生命周期短的场景


2. epoll 核心优势（Linux 高并发首选）
事件驱动而非轮询：仅通知就绪连接，效率 O (1)（select&#x2F;poll 为 O (n)）。
共享内存：fd 集合存储在内核，避免用户态与内核态频繁拷贝。
支持两种触发模式：
水平触发（LT，默认）：缓冲区有数据则持续通知，易用不易漏。
边缘触发（ET）：仅数据到来时通知一次，需一次性读完缓冲区，效率更高。




五、连接可靠性保障（避免 “假死” 连接）1. 超时处理
问题：recv()&#x2F;send()默认阻塞，连接异常时可能永久阻塞。
解决方案：用setsockopt()设置超时参数（SO_RCVTIMEO接收超时、SO_SNDTIMEO发送超时），或结合epoll_wait()的超时参数。

2. 心跳机制（检测连接存活）
原理：定期发送心跳包，未收到回应则判定连接失效。
实现方式：
应用层心跳：业务协议中加入固定格式心跳包（如每 30 秒发送，5 秒未回应断连）。
TCP keepalive：内核层定期发送探测包，默认超时较长（需调整参数）。



3. 断连重连（客户端）
核心策略：指数退避（重连间隔 1s→2s→4s→…→上限 60s），避免频繁重试冲击服务器。
限制：超过最大重试次数后报警（如网络彻底故障）。


六、数据序列化与反序列化（跨平台传输）核心要求：跨平台兼容、效率、可读性


方案类型
核心特点
优点
缺点
适用场景



自定义二进制格式
手动打包 &#x2F; 解析，处理大小端
紧凑高效，字节流小
开发复杂，兼容性差
对效率要求极高、协议固定的场景


JSON&#x2F;XML（文本格式）
文本标记数据结构
可读性好，跨平台性强
冗余大，解析效率低
调试友好、数据量小的场景


Protobuf&#x2F;FlatBuffers
IDL 定义结构，自动生成代码（二进制）
效率高，支持版本兼容
可读性差，需工具解析
高性能场景（游戏、分布式系统）



七、网络安全与攻击防护（面试高频）1. SYN 洪水攻击
原理：攻击者发送大量SYN报文但不完成三次握手，耗尽服务器半连接队列资源。
防护：开启 SYN Cookie（服务器用 Cookie 验证请求合法性，不维护半连接队列）。

2. 数据传输加密
方案：用 SSL&#x2F;TLS 协议（如 HTTPS）对传输数据加密，避免明文被窃听或篡改。

3. 端口扫描与限流
防护：防火墙限制异常 IP 连接频率，或应用层实现限流（如单 IP 每秒最多 10 次连接）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络</tag>
        <tag>问题</tag>
        <tag>机制</tag>
      </tags>
  </entry>
  <entry>
    <title>函数与指针：指针与引用</title>
    <url>/posts/eed757dd.html</url>
    <content><![CDATA[核心要点速览
指针：存储内存地址的变量，支持空值（nullptr）、动态指向、多级访问，存在野指针风险
引用：变量的别名，必须初始化、不可改指向、无空引用，语法简洁安全
访问效率：两者基本一致
适用场景：需空值 &#x2F; 动态指向 &#x2F; 多级访问用指针；需简洁语法 &#x2F; 确保有效 &#x2F; 避免误操作引用


一、指针指针本质是 “存储内存地址的变量”，支持对内存的间接访问。
1. 类型与特性（1）野指针
定义：未初始化、已释放或越界访问的指针（指向随机 &#x2F; 无效内存）。
风险：访问野指针会导致内存错误（崩溃、数据错乱），是常见 bug 来源。
示例（错误）：

int* p; // 未初始化，野指针*p = 10; // 未定义行为（访问随机内存）


规避：指针定义时立即初始化（如int* p = nullptr;），释放后及时置空（p = nullptr;）。

（2）空指针（nullptr）
定义：C++11 标准的空指针常量，替代旧版NULL（NULL本质是0，易引发歧义）。
用途：表示指针 “无指向”，避免野指针，可通过条件判断安全使用。
示例：

int* p = nullptr;if (p == nullptr) &#123; // 安全判断空指针    // 避免无效访问&#125;

（3）函数指针
定义：指向函数的指针，语法：返回类型 (*指针名)(参数类型列表)。
用途：作为函数参数 &#x2F; 返回值，实现回调函数（如排序算法中的比较器）。
示例：

// 目标函数：两数相加int add(int a, int b) &#123; return a + b; &#125;int main() &#123;    int (*func_ptr)(int, int) = add; // 函数指针指向add    int res = func_ptr(3, 5); // 调用：res=8（等价于(*func_ptr)(3,5)）    return 0;&#125;

（4）指针数组与数组指针原则：[]优先级高于*，()可提升*的优先级，需通过语法结构判断本质。



类型
语法格式
逻辑（优先级分析）
示例



指针数组
类型* 数组名[数组长度];
[]优先级高，先构成数组，元素是指针
int* arr[3];（3 个 int * 指针的数组）


数组指针
类型 (*指针名)[数组长度];
()提升*优先级，先是指针，指向 “固定长度的数组”
int (*p)[3];（指向含 3 个 int 的数组）



示例解析：

int a[3] = &#123;1,2,3&#125;;int* arr[3]; // 指针数组：每个元素是int*，可指向不同int变量int (*p)[3] = &amp;a; // 数组指针：p指向整个数组a，*p等价于a（数组首地址）

2. 指针的操作
解引用：*p，访问指针指向的变量值。
取地址：&amp;变量，获取变量的内存地址，赋值给指针。
算术运算：仅对 “指向数组的指针” 有意义，步长 &#x3D; 指向类型的大小（如int* p，p++移动 4 字节）。

二、引用引用本质是 “变量的别名”，语法上无独立内存（编译器通常用指针实现，但对外隐藏细节），核心优势是简洁安全。
1. 特性
必须初始化：定义时必须绑定已存在的变量（无空引用），否则编译报错。
 int a = 10;int&amp; r = a; // 正确：绑定变量a// int&amp; r; // 错误：未初始化// int&amp; r = nullptr; // 错误：无空引用

不可改指向：绑定后无法切换到其他变量，赋值操作是修改 “绑定变量的值”。
 int b = 20;r = b; // 不是更改绑定，而是将a的值改为20（a=20，r仍绑定a）

内存特性：sizeof(r) = sizeof(原变量)（无额外内存开销）。
 cout &lt;&lt; sizeof(r); // 4字节（与int类型大小一致）

2. 应用（1）函数参数（避免拷贝 + 修改实参）
替代指针，语法更简洁，无野指针风险，适合大对象传递（无拷贝开销）。
示例：  void update(int&amp; x) &#123; x *= 2; &#125;int a = 5;update(a); // a=10（直接修改实参）

（2）函数返回值（避免拷贝）
可返回 “全局变量、静态变量、类成员变量” 的引用（生命周期长于函数），避免返回对象的拷贝开销。

禁忌：禁止返回局部变量的引用（函数结束后局部变量销毁，引用变为悬垂引用）。

示例（正确）：
  int g_val = 10;int&amp; get_global() &#123; return g_val; &#125; // 返回全局变量引用，安全

示例（错误）：
  int&amp; get_local() &#123;    int x = 20;    return x; // 错误：x是局部变量，函数结束后销毁&#125;

三、本质区别
指针：独立的变量，存储目标变量的内存地址（占用 4&#x2F;8 字节内存，与系统位数相关）。
引用：非独立变量，是目标变量的 “别名”（语法层面无独立内存，编译器通常用指针实现，但对外隐藏指针操作）。

四、特性对比表


对比特性
指针（Pointer）
引用（Reference）



初始化
可延迟初始化（但未初始化是野指针）
必须定义时初始化，且绑定已存在变量


指向可修改性
可重新指向其他变量（p = &amp;b; 合法）
绑定后不可更改指向（r = b; 是修改原变量值）


空值支持
支持（int* p = nullptr;）
无空引用（必须绑定有效变量）


解引用操作
需显式用 *（*p = 10;）
无需解引用（r = 10; 直接修改绑定变量）


算术运算
支持（步长 &#x3D; 指向类型大小）
不支持（非独立对象，无地址可运算）


多级嵌套
支持（int** p 指向指针的指针）
不支持（int&amp;&amp; r 是右值引用，非 “引用的引用”）


语法复杂度
较高（需关注*&#x2F;&amp;&#x2F; 空指针 &#x2F; 野指针）
较低（简洁直观，无指针操作风险）



五、补充1. 作为函数参数的传递机制（1）指针传参
本质：“值传递地址”—— 函数接收的是实参地址的拷贝，修改指针本身（如p = &amp;b;）不影响实参指针；但修改指针指向的内容（*p = 10;）会影响实参变量。
示例：  void func(int* p) &#123;    *p = 20; // 影响实参变量（修改指向的内容）    p = nullptr; // 不影响实参指针（仅修改拷贝）&#125;int a = 10;int* ptr = &amp;a;func(ptr); // a=20，ptr仍指向a（未变）

（2）引用传参
本质：传递 “变量别名”—— 函数内修改引用（r = 20;）直接修改实参；且无法修改引用的指向（语法禁止）。

2. 返回值的 “悬垂问题”
指针与引用的共同禁忌：禁止返回局部变量（生命周期随函数结束而销毁）。
返回局部变量的指针：得到野指针（指向已释放内存），访问即未定义行为。
返回局部变量的引用：得到悬垂引用（绑定已销毁变量），访问即未定义行为。



3. const 修饰（1）const 修饰指针（左定值，右定向）
口诀：const 靠近谁，就限制谁 —— 左定值（限制指向的内容不可改），右定向（限制指针本身不可改）。  const int* p; // 常量指针（左定值）：指向的内容不可改（*p不能赋值），指针可改指向int* const p; // 指针常量（右定向）：指针本身不可改指向，指向的内容可改（*p可赋值）const int* const p; // 指向常量的指针常量：内容和指向均不可改

（2）const 引用（const T&amp;）
特性：不可通过引用修改绑定变量，但变量本身可被其他方式修改。
用途：可绑定临时对象（字面量、表达式结果），常用于函数参数（接收任意类型参数，避免拷贝）。
示例：  const int&amp; r1 = 10; // 合法：const引用绑定字面量（临时对象）const int&amp; r2 = 3 + 4; // 合法：绑定表达式结果int a = 5;const int&amp; r3 = a;// r3 = 10; // 错误：const引用不可修改绑定变量a = 10; // 合法：变量本身可通过其他方式修改（r3的值同步变为10）

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程OOP：友元与运算符重载</title>
    <url>/posts/6ea8b1ca.html</url>
    <content><![CDATA[核心要点速览
友元：打破封装，允许外部函数 &#x2F; 类访问类的私有 &#x2F; 保护成员（分友元函数、友元类、友元成员函数）
运算符重载：自定义类型的运算规则，不可重载 6 个运算符，支持成员函数 &#x2F; 友元函数两种形式
特殊重载：赋值运算符&#x3D;只能作为成员函数；&lt;&lt;&#x2F;&gt;&gt;需作为友元函数


一、友元：打破封装的特殊访问机制友元的核心是 “让外部实体获得类的特殊访问权限”，可访问私有（private）和保护（protected）成员，代价是削弱封装性。
1. 友元的种类（1）友元函数
声明方式：类内用friend声明，定义可在类外（非成员函数，无this指针）。
示例：

class A &#123;private:    int num = 10;    // 友元函数声明    friend void printA(A&amp; obj);&#125;;// 友元函数定义（类外），可直接访问私有成员void printA(A&amp; obj) &#123;    cout &lt;&lt; obj.num &lt;&lt; endl; // 合法：访问A的private成员&#125;


关键：访问类成员时需显式传递对象参数（无this指针）。

（2）友元类
声明方式：类内用friend class 类名;，目标类的所有成员函数均可访问当前类私有成员。
示例：

class A &#123;private:    int num = 10;    friend class B; // 声明B为友元类&#125;;class B &#123;public:    void accessA(A&amp; obj) &#123;        cout &lt;&lt; obj.num &lt;&lt; endl; // 合法：B的成员函数访问A的private成员    &#125;&#125;;

（3）友元成员函数
声明方式：指定类的某个成员函数作为友元，更精准控制访问权限。
示例：

class B; // 前置声明class A &#123;private:    int num = 10;    // 声明B的show()函数为友元    friend void B::show(A&amp; obj);&#125;;class B &#123;public:    void show(A&amp; obj); // 成员函数声明&#125;;// B的show()函数定义，可访问A的private成员void B::show(A&amp; obj) &#123;    cout &lt;&lt; obj.num &lt;&lt; endl;&#125;

2. 友元的特性
不可传递性：A 是 B 的友元，B 是 C 的友元，不代表 A 是 C 的友元。
单向性：A 声明 B 为友元，仅 B 能访问 A，A 不能访问 B。
声明位置无关：友元声明可放在类的 public&#x2F;private&#x2F;protected 任意区域，效果一致。


二、运算符重载：自定义类型的运算规则运算符重载是赋予自定义类型（类 &#x2F; 结构体）运算符（如+、=&#x3D;）的运算能力，语法为返回类型 operator运算符(参数列表)。
1. 重载规则
不可重载的 6 个运算符（固定）：
.（成员访问）、.*（成员指针访问）、::（作用域解析）、sizeof（大小计算）、?:（三目运算符）、typeid（类型信息）。


不可改变的特性：运算符的优先级、结合性、操作数个数。
必须包含至少一个自定义类型操作数（避免重载内置类型运算）。

2. 两种重载形式（1）成员函数重载
核心：左侧操作数为当前类对象（隐含this指针），参数列表只需传入右侧操作数。
适用场景：左侧操作数是当前类对象（如a + b，a 是当前类对象）。
示例（重载+）：

class Point &#123;private:    int x, y;public:    Point(int x=0, int y=0) : x(x), y(y) &#123;&#125;    // 成员函数重载+：this指向左侧操作数    Point operator+(const Point&amp; rhs) &#123;        return Point(x + rhs.x, y + rhs.y);    &#125;&#125;;// 调用：左侧a是this指针指向的对象Point a(1,2), b(3,4);Point c = a + b; // 等价于a.operator+(b)

（2）友元函数重载
核心：无this指针，需显式传入所有操作数（左侧 + 右侧）。
适用场景：左侧操作数不是当前类对象（如cout &lt;&lt; a，左侧是ostream对象）。
示例（重载&lt;&lt;，输出自定义类型）：

class Point &#123;private:    int x, y;public:    Point(int x=0, int y=0) : x(x), y(y) &#123;&#125;    // 友元函数重载&lt;&lt;：需访问私有成员，且左侧是ostream    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Point&amp; p) &#123;        os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;        return os; // 支持链式输出（cout &lt;&lt; a &lt;&lt; b）    &#125;&#125;;// 调用：os=cout，p=aPoint a(1,2);cout &lt;&lt; a; // 等价于operator&lt;&lt;(cout, a)，输出(1,2)

3. 特殊重载：赋值运算符&#x3D;
规则：只能作为成员函数（编译器默认生成，执行浅拷贝）。
深拷贝需求：当类包含动态资源（如指针）时，需手动重写，避免双重释放。
示例（深拷贝赋值运算符）：

class String &#123;private:    char* str;public:    // 赋值运算符重载（成员函数）    String&amp; operator=(const String&amp; other) &#123;        if (this == &amp;other) return *this; // 处理自我赋值        delete[] str; // 释放当前资源        // 深拷贝：重新分配内存        str = new char[strlen(other.str) + 1];        strcpy(str, other.str);        return *this; // 支持链式赋值（a = b = c）    &#125;&#125;;
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>友元</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程OOP：继承与多态</title>
    <url>/posts/3a088510.html</url>
    <content><![CDATA[核心要点速览
继承：解决代码复用与扩展，核心是派生类获取基类成员；继承方式分 public&#x2F;protected&#x2F;private，构造先父后子、析构先子后父
多态：解决接口统一与动态行为，核心是基类指针 &#x2F; 引用指向派生类对象，调用虚函数触发动态绑定
机制：虚函数（virtual）、纯虚函数（抽象类）、虚函数表（vtable）+ 虚指针（vptr）、虚析构（避免资源泄漏）
对比：重写（Override）vs 重载（Overload）vs 隐藏（Hide）


一、继承：代码复用与层次化设计继承是派生类从基类获取成员（属性 + 行为）的机制，核心是 “基于已有类扩展功能”。
1. 继承方式与成员访问权限继承方式决定基类成员在派生类中的访问权限，常用public继承（其他方式极少用）。



基类成员权限
public 继承（常用）
protected 继承
private 继承



public
派生类 public
派生类 protected
派生类 private


protected
派生类 protected
派生类 protected
派生类 private


private
派生类不可访问
派生类不可访问
派生类不可访问


2. 派生类的构造与析构构造函数
执行顺序：先调用基类构造函数（初始化基类部分）→ 再调用派生类构造函数（初始化新增部分）。
重点：若基类无默认构造函数（无参 &#x2F; 全默认参数），派生类必须在初始化列表中显式调用基类带参构造（否则编译报错）。

析构函数
执行顺序：先调用派生类析构函数（清理派生类资源）→ 再调用基类析构函数（清理基类资源）。
重点：基类析构函数必须加virtual（虚析构），否则通过基类指针删除派生类对象时，仅调用基类析构，导致派生类资源泄漏。

3. 菱形继承与虚继承菱形继承问题
场景：派生类间接继承同一基类多次（如 D 继承 B 和 C，B 和 C 均继承 A）。
后果：基类成员在派生类中存在多份拷贝，导致数据冗余和访问二义性（如d.a无法确定访问哪个 A 的成员）。

解决方案：虚继承
语法：在间接继承路径中加virtual关键字（如class B : virtual public A）。
原理：虚继承的派生类通过虚基类表指针（vbptr） 间接访问基类成员，确保基类在最终派生类中仅存一份实例。
规则：虚基类的构造函数由最终派生类负责初始化（而非直接派生类）。


二、多态：接口复用与动态行为多态是 “同一接口，不同实现”，按绑定时机分静态多态和动态多态，核心考察动态多态。
1. 静态多态（编译期多态）
绑定时机：编译阶段确定调用哪个函数。
实现方式：
函数重载：同一作用域内同名函数，参数列表（类型 &#x2F; 个数 &#x2F; 顺序）不同。
模板：参数类型不同时，编译器生成不同版本的函数 &#x2F; 类。



2. 动态多态（运行期多态）
绑定时机：运行阶段根据对象实际类型确定调用的函数。
实现条件（缺一不可）：
基类声明虚函数（加virtual关键字）。
派生类重写（override显式标注）该虚函数。
通过基类指针或引用指向派生类对象，调用虚函数。



（1）虚函数重写规则
派生类函数与基类函数的函数名、参数列表、返回类型完全一致（返回类型可协变：基类返回Base*，派生类可返回Derived*）。
基类函数必须带virtual（派生类可省略virtual，但不推荐，显式标注更清晰）。
访问权限可不同（如基类public，派生类protected），但通过基类指针调用时需满足基类访问权限。

（2）底层实现：虚函数表（vtable）+ 虚指针（vptr）
虚函数表（vtable）：每个含虚函数的类（基类 &#x2F; 派生类）有一个全局唯一的 vtable，存储该类所有虚函数的地址。
虚指针（vptr）：每个对象包含一个 vptr 成员（64 位系统占 8 字节），指向所属类的 vtable。
动态绑定流程：
基类声明虚函数，编译器为基类生成 vtable，存入基类虚函数地址。
派生类重写虚函数，编译器为派生类生成 vtable，重写函数地址替换为派生类版本，未重写的仍指向基类版本。
对象创建时，vptr 初始化指向所属类的 vtable。
调用虚函数（如base_ptr-&gt;func()），通过 vptr 找到 vtable，调用对应函数地址（运行时确定）。



（3）纯虚函数与抽象类
纯虚函数：未实现的虚函数，语法virtual void func() = 0;，用于定义接口。
抽象类：含纯虚函数的类，不能实例化对象（仅作为基类）。
派生类规则：必须实现基类所有纯虚函数，否则仍是抽象类（无法实例化）。


三、概念区分重写（Override）vs 重载（Overload）vs 隐藏（Hide）


对比维度
重写（Override）
重载（Overload）
隐藏（Hide）



作用域
不同作用域（基类 vs 派生类）
同一作用域（如同一类 &#x2F; 命名空间）
不同作用域（基类 vs 派生类）


函数关系
基类虚函数与派生类同名函数
同名函数
派生类函数与基类同名，但不满足重写


关键条件
函数名、参数、返回值完全一致
参数列表不同（类型 &#x2F; 个数 &#x2F; 顺序）
不满足重写条件（如基类非虚函数）


多态类型
动态多态（运行期绑定）
静态多态（编译期绑定）
无多态（直接调用派生类函数）


访问基类函数
直接调用（基类指针 &#x2F; 引用触发）
按实参类型匹配
需用基类名限定（Base::func()）


虚函数的限制
静态成员函数不能是虚函数（无this指针，无法访问 vptr，无法动态绑定）。
构造函数不能是虚函数（对象构造时 vptr 尚未初始化，无法访问 vtable）。
内联函数可以是虚函数，但触发动态绑定时，内联优化失效（内联是编译期，动态绑定是运行期）。
友元函数不能是虚函数（友元不是类成员，无this指针，无法关联 vtable）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程OOP：类与对象</title>
    <url>/posts/3a517f26.html</url>
    <content><![CDATA[核心要点速览
访问控制：public（接口）、private（实现）、protected（继承）
const 成员：const 成员变量需初始化列表初始化；const 成员函数不可修改成员变量
static 成员：静态成员变量类共享、类外初始化；静态成员函数无 this 指针、仅访问静态成员
构造函数：可重载、非虚函数；含默认 &#x2F; 带参 &#x2F; 拷贝 &#x2F; 移动构造
析构函数：不可重载；基类需设为虚函数避免资源泄漏
类大小：仅取决于非静态数据成员，遵循内存对齐


一、基本概念
类：抽象的数据类型模板，定义对象的属性（数据成员）和行为（成员函数）。
对象：类的具体实例，占用实际内存，拥有类定义的属性和行为。


二、核心特性：封装核心是 “隐藏实现细节，暴露公共接口”，通过访问控制符实现。



访问控制符
可访问范围
作用



public
类内、类外、派生类
暴露接口，供外部调用


private
仅类内和友元
隐藏数据成员和内部实现


protected
类内、友元、派生类（类外不可访问）
为继承预留访问权限



封装意义：保障数据安全、提升代码维护性、降低使用复杂度。


三、构造函数：对象的初始化
核心特点：函数名与类名相同，无返回值，对象创建时自动调用，可重载，不能为虚函数。

常见类型1. 默认构造函数
定义：无参数，或所有参数都有默认值。
编译器行为：未定义任何构造函数时自动生成；定义其他构造函数后需手动定义。

2. 带参构造函数
用途：通过参数灵活初始化对象。

3. 拷贝构造函数
定义：参数必须为 “同类对象的 const 引用”（避免无限递归）。
调用时机：对象初始化、函数按值传参、函数返回值为对象（非引用）。
浅拷贝 vs 深拷贝：
浅拷贝：仅复制表层数据，指针成员共享内存，可能导致双重释放。
深拷贝：为指针成员重新分配内存并复制数据，示例：



class String &#123;private:    char* str;public:    String(const String&amp; other) &#123;        str = new char[strlen(other.str) + 1];        strcpy(str, other.str);    &#125;    ~String() &#123; delete[] str; &#125;&#125;;

4. 移动构造函数
核心：接管原对象动态资源，避免拷贝，提升效率。
示例：

class String &#123;private:    char* str;public:    String(String&amp;&amp; other) noexcept &#123;        str = other.str;        other.str = nullptr; // 掏空原对象    &#125;&#125;;String s2 = std::move(s1); // 接管s1资源

初始化列表
用途：优先初始化成员变量，推荐使用。
必须使用的场景：const 成员、引用成员、无默认构造函数的类成员，示例：

class A &#123;private:    const int a;    int&amp; b;public:    A(int x, int&amp; y) : a(x), b(y) &#123;&#125; // 初始化列表&#125;;


四、析构函数：对象的清理
特点：函数名~类名，无参数、无返回值，不可重载，对象生命周期结束时自动调用。
必须手动定义的场景：类包含动态分配资源（如 new 的内存）。
虚析构函数（基类必备，避免资源泄漏）：

class Base &#123;public:    virtual ~Base() &#123; delete[] data; &#125; // 虚析构&#125;;class Derived : public Base &#123;public:    ~Derived() &#123; delete[] derivedData; &#125;&#125;;


五、this 指针
本质：非静态成员函数中隐式传递的指针，指向当前调用对象（类型类名* const）。
用途：

void setName(string name) &#123; this-&gt;name = name; &#125; // 区分成员与参数Person&amp; setAge(int age) &#123; return *this; &#125; // 链式调用


六、静态成员（属于类）1. 静态成员变量
特点：所有对象共享，存储在全局数据区，类内声明、类外初始化：

class Counter &#123;public:    static int count; // 类内声明&#125;;int Counter::count = 0; // 类外初始化

2. 静态成员函数
特点：无 this 指针，无需创建对象即可调用，仅能访问静态成员：

static void increment() &#123; count++; &#125; // 仅访问静态成员Counter::increment(); // 直接调用


七、类的大小计算
规则：仅取决于非静态数据成员，遵循内存对齐，与成员函数、静态成员无关。
示例：

class Empty &#123;&#125;;sizeof(Empty); // 1字节（占位）class A &#123; char c; int i; &#125;;sizeof(A); // 8字节（1+3填充+4，对齐系数4）


八、问答
构造函数和析构函数的调用顺序？
构造：先定义先构造；析构：后构造先析构。


拷贝构造函数的参数为什么必须是引用？
避免值传递引发的无限递归（形参初始化需再次调用拷贝构造）。



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理：RAII</title>
    <url>/posts/1fa3f2ba.html</url>
    <content><![CDATA[核心要点速览
设计思想：资源获取与对象初始化绑定，资源释放与对象析构绑定（构造拿资源，析构放资源）
实现：封装资源为类成员，构造获取、析构释放，可选禁止拷贝
典型应用：智能指针、互斥锁、文件句柄、网络连接
优势：自动释放资源、异常安全、简化代码、保障资源独占


一、设计思想：资源对象的生命周期绑定RAII（Resource Acquisition Is Initialization）的本质是用对象生命周期管理资源：

对象构造时：自动获取资源（如分配内存、打开文件、加锁），确保资源获取成功后对象才有效；
对象析构时：自动释放资源（如释放内存、关闭文件、解锁），无论对象正常退出还是因异常销毁，析构函数都会执行。


二、实现原理
封装资源：定义类时，将待管理的资源（如指针、文件句柄、锁对象）声明为私有成员，禁止外部直接访问，确保资源只能通过类的接口管控；
强制获取资源：在构造函数中编写资源获取逻辑（如接收new的内存地址、调用fopen打开文件），若资源获取失败（如内存不足），直接抛出异常，避免构造 “无效对象”；
自动释放资源：在析构函数中编写资源释放逻辑（如delete内存、fclose关闭文件），无需外部手动调用，覆盖所有退出场景；
管控资源所有权（可选）：根据资源特性决定是否禁止拷贝 ——
若资源不可共享（如独占锁、唯一内存块）：删除拷贝构造函数和拷贝赋值运算符（=delete），避免多个对象管理同一资源（析构时重复释放）；
若资源可共享（如引用计数内存）：允许拷贝，但需通过引用计数（如shared_ptr）管理资源，确保最后一个对象析构时才释放资源。




三、典型应用场景


应用场景
标准库实现
RAII 逻辑细节



动态内存管理
std::unique_ptr&#x2F;std::shared_ptr
- unique_ptr：独占资源，禁止拷贝，析构直接释放；- shared_ptr：共享资源，通过引用计数，最后一个对象析构时释放。


互斥锁管理
std::lock_guard&#x2F;std::unique_lock
- lock_guard：构造时自动lock，析构时自动unlock，禁止拷贝；- 避免手动解锁遗漏（如异常、提前返回）导致死锁。


文件句柄管理
std::fstream&#x2F;std::ifstream
构造时通过文件名open文件，析构时自动close，无需手动管理文件描述符，避免泄漏。


网络连接管理
自定义网络连接类
构造时调用connect建立 TCP&#x2F;UDP 连接，析构时调用close断开连接，简化连接生命周期。


临时资源管理
std::scoped_ptr（Boost）
作用域内有效，离开作用域自动释放，适用于 “一次性临时资源”（如临时缓冲区）。



四、优势
自动释放资源：无需手动调用释放函数（delete&#x2F;unlock等），避免疏忽导致的资源泄漏；
异常安全：C++ 标准保证异常抛出时，当前作用域已构造对象会自动析构，资源仍能正常释放；
简化代码：资源管理逻辑封装在类中，业务代码无需关注释放细节，提升可读性和可维护性；
资源独占性：通过禁止拷贝，确保资源不被意外共享（如unique_ptr、独占锁）。
所有权清晰：资源与对象强绑定，对象的 “创建 &#x2F; 销毁 &#x2F; 转移” 即对应资源的 “获取 &#x2F; 释放 &#x2F; 移交”，所有权归属一目了然。


五、资源管理方式对比表


管理方式
缺点
RAII 的优势



手动释放
易遗漏、异常下失效（释放代码未执行）
自动释放，覆盖所有退出场景


goto 跳转释放
代码混乱，多出口难维护（C 语言常用）
无需显式控制流程，依赖对象生命周期


函数末尾释放
提前返回时失效（return 前未释放）
无论退出方式，均自动执行释放逻辑



六、问答1. RAII 如何保证异常安全？C++ 标准规定：当异常抛出时，程序会销毁当前作用域内已构造完成的所有对象（自动调用析构函数）。RAII 将资源释放逻辑封装在析构函数中，因此即使发生异常，对象析构仍会执行，资源被正确释放，避免异常导致的资源泄漏。
2. 为什么 RAII 有时需要禁止拷贝？若允许拷贝，会导致多个对象管理同一资源，析构时会触发 “重复释放”，引发程序崩溃（如两个unique_ptr指向同一内存，析构时两次delete）。

当资源不可共享（如独占锁、唯一内存块）：必须禁止拷贝（=delete拷贝构造 &#x2F; 赋值），确保资源仅被一个对象管理；
当资源可共享（如引用计数内存）：无需禁止拷贝，但需通过额外机制（如shared_ptr的引用计数）确保 “仅最后一个对象析构时释放资源”。

3. RAII 与 “垃圾回收（GC）” 的区别？RAII 是 C++ 的 “编译期资源管理”，GC 是 Java&#x2F;Python 的 “运行期内存回收”，核心差异如下：



维度
RAII
GC



管理范围
所有资源（内存、锁、句柄等）
仅动态内存（部分 GC 支持其他资源）


执行时机
编译期确定（对象析构时）
运行期不定时（GC 线程触发）


性能开销
无额外开销（仅析构函数调用）
有运行期开销（GC 暂停、内存扫描）


确定性
资源释放时机完全确定
释放时机不确定（可能延迟）


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存</tag>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title>数组与字符串：数组</title>
    <url>/posts/c24002d9.html</url>
    <content><![CDATA[核心要点速览
数组名：本质是首元素地址，仅 3 种场景不退化（sizeof、&amp;数组名、decltype）
数组传参：一维退化为指针（丢失长度），二维必须指定第二维长度
C 风格字符串：以&#39;\0&#39;结尾的字符数组，strlen与sizeof计算逻辑不同
数组 vs vector：数组编译期定长、手动管理；vector 动态扩容、自动管理


一、数组名与指针1. 特性数组名 通常等价于首元素地址，仅 3 种场景保留数组类型特性（不退化）。
2. 数组名不退化的 3 种场景
sizeof(数组名)：计算整个数组的字节总大小（非指针大小）
&amp;数组名：获取指向 “整个数组” 的指针（类型为数组类型(*)[长度]）
decltype(数组名)：推导为数组类型（如decltype(arr)为int[5]）

3. 数组初始化（C++11+）
聚合初始化简化：可省略等号，多维数组支持部分初始化

int arr[] &#123;1,2,3&#125;;          // 等价于 int arr[] = &#123;1,2,3&#125;int mat[2][3] &#123;&#123;1,2&#125;, &#123;3&#125;&#125;; // 剩余元素自动补0


零初始化技巧：空大括号或单 0 即可全局置 0

int arr[5] &#123;0&#125;; // 所有元素为0int arr[5] &#123;&#125;;  // C++11+ 空大括号等价上式（局部数组需显式指定）


禁止窄化转换：聚合初始化不允许隐式窄化（普通初始化仅警告）

int arr[] &#123;1.2&#125;; // 编译报错（double→int 窄化）

4. 易错：&amp;数组名 vs &amp;数组首元素int arr[5] = &#123;1,2,3,4,5&#125;;&amp;arr;    // 类型 int(*)[5]，+1 偏移 5 个 int（20 字节）&amp;arr[0]; // 类型 int*，+1 偏移 1 个 int（4 字节）


二、数组作为函数参数数组传参 必然退化为指针，丢失原数组长度，需手动传递长度参数。
1. 一维数组传参（3 种写法，等价）// 写法1：数组形式（[]内数字无意义，仅语法兼容）void func1(int arr[5]) &#123; ... &#125;// 写法2：省略长度的数组形式void func2(int arr[]) &#123; ... &#125;// 写法3：显式指针形式（推荐，最直观）void func3(int* arr) &#123; ... &#125;

2. 二维数组传参
二维数组退化后是 “指向一维数组的指针”，第二维长度不可省略（编译器需计算步长）

// 正确写法：指定第二维长度 3void func(int mat[][3], int rows) &#123; ... &#125;// 错误写法：第二维长度省略（编译报错）void func(int mat[][], int rows, int cols) &#123; ... &#125;

3. 补充
函数内无法通过sizeof(arr)获取原数组长度（此时arr已退化为指针，结果为 4&#x2F;8 字节）
必须显式传递长度（如func(arr, 5)），或通过数组结尾标记获取长度


三、字符串与字符数组（C 风格）1. 本质以&#39;\0&#39;（空字符）结尾的字符数组，&#39;\0&#39;是字符串结束标记（字符串常量后编译器自动填充）。
2. 区别：strlen vs sizeof


函数 &#x2F; 运算符
计算逻辑
是否包含&#39;\0&#39;



strlen(str)
统计&#39;\0&#39;之前的字符个数
否


sizeof(str)
计算整个字符数组的字节大小
是（含未使用空间）


3. 易错点未添加&#39;\0&#39;会导致strlen越界：
char str1[] = &quot;hello&quot;; // 自动补&#x27;\0&#x27;，数组长度 6（h e l l o \0）char str2[] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;; // 无&#x27;\0&#x27;，strlen(str2) 结果不确定

4. 字符串常量 vs 字符数组


类型
存储区域
可修改性
风险点



char* str = &quot;abc&quot;
常量区（只读）
不可修改
试图修改触发未定义行为


char str[] = &quot;abc&quot;
栈区 &#x2F; 全局区
可修改
可直接修改元素（如str[0]=&#39;x&#39;）



四、数组 vs vector（动态数组）对比表


对比维度
数组（Array）
vector（动态数组）



大小特性
编译期固定，运行时不可修改
运行时动态调整，push_back自动扩容


内存管理
栈 &#x2F; 全局区存储，手动管理（无自动释放）
堆内存存储，自动管理（析构时释放资源）


长度获取
手动计算：sizeof(arr)/sizeof(arr[0])
内置size()方法（直接获取元素个数）


传参方式
退化为指针，需额外传递长度
传引用（vector&lt;int&gt;&amp;），保留长度信息


越界安全性
无检查，越界为未定义行为
at()方法支持越界检查（抛异常），更安全


灵活性
低（不可扩容 &#x2F; 缩容）
高（支持插入、删除、扩容等操作）


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理：动态内存</title>
    <url>/posts/58a84bc7.html</url>
    <content><![CDATA[核心要点速览
动态内存：运行时手动分配，需手动释放（否则泄漏）；new&#x2F;delete 自动调用构造 &#x2F; 析构，需与 new []&#x2F;delete [] 严格匹配
智能指针（C++11+，&lt;memory&gt;）：RAII 机制自动管理内存，unique_ptr（独占）、shared_ptr（共享，引用计数）、weak_ptr（解循环引用）
常见问题：内存泄漏（未释放）、野指针（未初始化）、悬空指针（指向已释放内存）


一、动态内存的分配与释放核心是 “分配 - 使用 - 释放” 闭环，C++ 推荐用 new&#x2F;delete，需严格匹配使用。
1. C vs C++ 分配释放方式对比


对比维度
C（malloc&#x2F;free）
C++（new&#x2F;delete）



类型安全
返回void*，需手动强转（不安全）
返回对应类型指针（无需转换，安全）


构造 &#x2F; 析构
不调用（仅操作内存）
自动调用构造（new）&#x2F; 析构（delete）


数组支持
需手动计算总大小（n*sizeof(T)）
直接new T[n]（自动计算大小）


分配失败
返回NULL
默认抛bad_alloc，可指定nothrow返回NULL


重载扩展
不可重载
可重载operator new&#x2F;operator delete定制分配


2. 匹配规则
单个对象：new T → delete ptr（匹配单个构造 &#x2F; 析构）
数组对象：new T[n] → delete[] ptr（匹配 n 次构造 &#x2F; 析构）
不匹配后果：
delete释放new[]：仅第一个元素析构，其余资源泄漏，可能崩溃
delete[]释放new：错误读取数组长度，多次析构，破坏内存状态



3. 底层执行流程new 的主要步骤
调用operator new(sizeof(T))：分配原始内存（底层通常调用 malloc）
调用构造函数：new(p) T(args)（placement new，在指定内存构造对象）
返回对象指针

delete 的主要步骤
调用析构函数：p-&gt;~T()（清理对象资源）
调用operator delete(p)：释放内存（底层通常调用 free）


二、常见动态内存问题1. 内存泄漏
定义：动态内存不再使用但未释放，永久占用内存
原因：忘记释放、指针被重赋值（地址丢失）、异常导致释放代码未执行
解决方案：用智能指针、遵循 “谁分配谁释放”、RAII 机制（对象析构自动释放）

2. 野指针
定义：未初始化的指针（指向随机内存）
危害：解引用导致未定义行为（崩溃、数据错乱）
避免方案：定义时初始化（int* p = nullptr;），释放后置为nullptr

3. 悬空指针
定义：指向已释放内存的指针（地址未置空）
危害：解引用访问无效内存（逻辑错误或崩溃）
避免方案：释放后立即置nullptr，避免重复释放

野指针与悬空指针对比


类型
本质
产生场景



野指针
未初始化的指针
int* p;（未赋值）


悬空指针
指向已释放内存的指针
delete p; 后未置 nullptr



三、智能指针（C++11+，自动内存管理）基于 RAII 机制，析构时自动释放内存，彻底解决手动管理的缺陷。
1. unique_ptr：独占所有权
特性：同一时间仅一个unique_ptr指向内存，不可复制（禁用拷贝构造 &#x2F; 赋值），可通过std::move转移所有权
适用场景：单一所有者的动态内存（如局部动态对象、函数返回动态对象）
补充：
零额外内存开销（仅封装原始指针）
支持数组管理：unique_ptr&lt;T[]&gt;（自动调用 delete[]）
自定义删除器：用于管理非内存资源（如文件、锁）



auto arr = make_unique&lt;int[]&gt;(5); // 管理5个int的数组arr[0] = 10; // 支持[]操作符

2. shared_ptr：共享所有权
特性：多个shared_ptr共享同一内存，通过控制块维护引用计数（计数为 0 时自动释放）
控制块内容：引用计数、弱引用计数、删除器、分配器
适用场景：多所有者的动态内存（如共享资源、容器中存储动态对象）
补充：
优先使用 make_shared&lt;T&gt;()：一次性分配对象 + 控制块（高效，减少内存碎片），避免 shared_ptr&lt;T&gt;(new T())（两次分配）
线程安全：引用计数增减是原子操作，但对象读写需额外同步



3. weak_ptr：解决循环引用
特性：弱引用（不增加引用计数），仅观测shared_ptr管理的内存，不影响生命周期
用途：解决shared_ptr的循环引用问题（如 A 和 B 互相持有shared_ptr，导致计数无法归零）
主要操作：lock()方法获取shared_ptr（有效则返回非空，无效则返回空）
循环引用示例与解决方案：

class A &#123; public: shared_ptr&lt;B&gt; b; &#125;;class B &#123; public: shared_ptr&lt;A&gt; a; &#125;;// 循环引用：a和b的引用计数均为2，析构时无法归零，内存泄漏shared_ptr&lt;A&gt; a = make_shared&lt;A&gt;();shared_ptr&lt;B&gt; b = make_shared&lt;B&gt;();a-&gt;b = b;b-&gt;a = a;// 解决方案：将其中一个改为weak_ptr（如B的a改为weak_ptr&lt;A&gt;）

4. 智能指针使用陷阱
避免用同一原始指针初始化多个 shared_ptr（导致重复释放）
避免暴露原始指针（get() 方法）：外部保存后可能导致悬空
unique_ptr 转移所有权后，原指针失效（需避免再次使用）


四、问答智能指针的底层实现原理？

智能指针是类模板，封装原始指针，通过 RAII 机制在析构时自动释放内存。unique_ptr禁用拷贝实现独占；shared_ptr通过控制块存储引用计数，计数为 0 时释放；weak_ptr指向控制块，不增减计数，用于解循环引用。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存</tag>
        <tag>动态内存</tag>
      </tags>
  </entry>
  <entry>
    <title>网路编程：网络基础</title>
    <url>/posts/91149a63.html</url>
    <content><![CDATA[核心要点速览
协议栈：TCP&#x2F;IP 四层模型（应用层→传输层→网络层→数据链路层）
TCP vs UDP：TCP 面向连接、可靠流式；UDP 无连接、高效数据报
三次握手：建立 TCP 连接，确保双方收发能力正常；四次挥手：断开连接，释放全双工通道
TIME_WAIT：客户端第四次挥手后停留 2MSL，确保 ACK 送达、旧报文失效
Socket：网络编程接口，由 “IP + 端口” 唯一标识，TCP 需按固定流程（绑定 - 监听 - 连接 - 收发）编程


一、TCP&#x2F;IP 四层模型
应用层：提供具体业务协议（HTTP、FTP、DNS），定义数据格式和交互逻辑
传输层：TCP&#x2F;UDP，负责端到端（进程间）数据传输（可靠 &#x2F; 高效）
网络层：IP 协议，负责跨网络路由转发（寻址）
数据链路层：处理物理介质上的帧传输（如以太网帧）


二、TCP 与 UDP 核心对比


对比维度
TCP（传输控制协议）
UDP（用户数据报协议）



连接性
面向连接（三次握手建连，四次挥手断连）
无连接（直接发送，无需建连）


可靠性
可靠（重传、序列号、确认、滑动窗口、拥塞控制）
不可靠（无重传，可能丢包 &#x2F; 乱序）


传输速率
低（含确认、重传等额外开销）
高（无额外开销，仅传输数据）


数据形式
字节流（无边界，需应用层定义分割）
数据报（有边界，一次收发一个完整报文）


拥塞控制
有（避免网络过载）
无（可能导致网络拥塞）


适用场景
文件传输、HTTP、邮件（需可靠性）
实时通信（视频 &#x2F; 语音）、DNS（需实时性）


1. TCP：面向连接的可靠传输
核心特性：
面向连接：通信前必须通过三次握手建立连接，结束后通过四次挥手断开。
可靠保障：通过序列号（保证有序）、确认应答（ACK，确保接收）、重传机制（丢失重发）、滑动窗口（流量控制）、拥塞控制（避免网络过载）实现数据不丢、不重、有序。
字节流：数据无天然边界，需应用层自行处理粘包 &#x2F; 半包问题。


典型协议：HTTP、FTP、SMTP、SSH。

2. UDP：无连接的高效传输
核心特性：
无连接：无需建连 &#x2F; 断连，直接发送数据，开销极低。
不可靠：不保证数据到达、有序，无重传机制（丢包需应用层处理）。
数据报：每个报文是独立单元（有边界），接收方一次接收一个完整报文（无粘包）。


典型协议：RTP（实时音视频）、DNS、DHCP、游戏数据传输。


三、三次握手与四次挥手1. 三次握手（建立 TCP 连接）
目的：确认双方 “发送” 和 “接收” 能力正常，协商初始序列号（避免历史报文干扰）。
流程（客户端→服务器）：
第一次握手：客户端发SYN报文（同步请求），携带初始序列号seq = x。
第二次握手：服务器回SYN+ACK报文（同步 + 确认），携带自身初始序列号seq = y、确认号ack = x + 1（表示已接收客户端x）。
第三次握手：客户端回ACK报文，确认号ack = y + 1（表示已接收服务器y）。


关键问答：为什么需要三次握手？
避免 “过期连接请求” 浪费服务器资源。若客户端旧SYN报文延迟到达，服务器二次握手后，客户端会因识别为无效请求而不发第三次ACK，服务器超时后释放资源（二次握手会导致服务器误建连）。



2. 四次挥手（断开 TCP 连接）
目的：TCP 是全双工通信（双方可同时发数据），需分别关闭各自的发送通道。
流程（客户端先发起关闭）：
第一次挥手：客户端发FIN报文（终止请求），seq = u，表示不再发送数据。
第二次挥手：服务器回ACK报文，ack = u + 1，表示确认关闭请求（此时服务器→客户端通道仍可发数据）。
第三次挥手：服务器数据发送完毕，发FIN报文，seq = v，表示不再发送数据。
第四次挥手：客户端回ACK报文，ack = v + 1，表示确认关闭（此时客户端→服务器通道关闭）。


关键问答：为什么需要四次挥手？
全双工特性导致：第二次挥手仅确认客户端的关闭请求，服务器可能仍有未发送完的数据，需等数据发完后，再通过第三次挥手关闭自身发送通道，因此需四次交互。



3. TIME_WAIT 状态
触发场景：客户端发送第四次挥手的ACK后进入该状态。
停留时间：默认 2MSL（MSL 是报文最大生存时间，通常 1 分钟）。
核心目的：
确保服务器能收到第四次挥手的ACK（若服务器未收到，会重发FIN，客户端可在TIME_WAIT内重传）。
避免客户端新连接收到旧连接的残留报文（2MSL 足够让网络中旧报文失效）。




四、Socket：网络编程接口1. Socket 本质
操作系统提供的网络通信接口，封装了 TCP&#x2F;UDP 底层协议细节。
唯一标识：IP地址 + 端口号（如(192.168.1.1, 8080)），对应进程间通信的端点。

2. TCP Socket 编程流程（极简示例）服务器端（被动连接）#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;int main() &#123;    // 1. 创建TCP Socket    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);    // 2. 绑定IP和端口    sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;         // IPv4    serv_addr.sin_addr.s_addr = INADDR_ANY; // 绑定所有网卡IP    serv_addr.sin_port = htons(8080);       // 端口转换为网络序    bind(listen_fd, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));    // 3. 监听（最大等待连接数10）    listen(listen_fd, 10);    // 4. 阻塞等待客户端连接（返回与该客户端通信的新Socket）    sockaddr_in client_addr;    socklen_t client_len = sizeof(client_addr);    int conn_fd = accept(listen_fd, (sockaddr*)&amp;client_addr, &amp;client_len);    // 5. 收发数据    char buf[1024] = &#123;0&#125;;    recv(conn_fd, buf, sizeof(buf), 0);     // 接收客户端数据    send(conn_fd, &quot;Hello Client&quot;, 12, 0);   // 发送响应    // 6. 关闭Socket    close(conn_fd);    close(listen_fd);    return 0;&#125;

客户端（主动连接）#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;int main() &#123;    // 1. 创建TCP Socket    int client_fd = socket(AF_INET, SOCK_STREAM, 0);    // 2. 连接服务器    sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); // 服务器IP    serv_addr.sin_port = htons(8080);                  // 服务器端口    connect(client_fd, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));    // 3. 收发数据    send(client_fd, &quot;Hello Server&quot;, 12, 0);           // 发送数据    char buf[1024] = &#123;0&#125;;    recv(client_fd, buf, sizeof(buf), 0);             // 接收响应    // 4. 关闭Socket    close(client_fd);    return 0;&#125;

3. UDP Socket 收发示例// UDP服务器端（接收数据）#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;int main() &#123;    int sock_fd = socket(AF_INET, SOCK_DGRAM, 0); // SOCK_DGRAM指定UDP    sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = INADDR_ANY;    serv_addr.sin_port = htons(8080);    bind(sock_fd, (sockaddr*)&amp;serv_addr, sizeof(serv_addr));    char buf[1024] = &#123;0&#125;;    sockaddr_in client_addr;    socklen_t client_len = sizeof(client_addr);    // 接收数据并获取客户端地址    recvfrom(sock_fd, buf, sizeof(buf), 0, (sockaddr*)&amp;client_addr, &amp;client_len);    // 回复客户端    sendto(sock_fd, &quot;Hello UDP Client&quot;, 15, 0, (sockaddr*)&amp;client_addr, client_len);    close(sock_fd);    return 0;&#125;

4. TCP 粘包解决方案示例（消息头 + 消息体，最常用）// 发送端：打包消息（4字节长度+消息体）void send_msg(int sock_fd, const std::string&amp; data) &#123;    int len = data.size();    len = htonl(len); // 长度转换为网络序    // 先发送消息长度（4字节）    send(sock_fd, &amp;len, sizeof(len), 0);    // 再发送消息体    send(sock_fd, data.c_str(), data.size(), 0);&#125;// 接收端：解析消息（先读长度，再读对应长度的消息体）std::string recv_msg(int sock_fd) &#123;    int len = 0;    // 先接收消息长度（4字节）    recv(sock_fd, &amp;len, sizeof(len), 0);    len = ntohl(len); // 转换为主机序    // 再接收消息体    char* buf = new char[len + 1];    recv(sock_fd, buf, len, 0);    buf[len] = &#x27;\0&#x27;;    std::string data(buf);    delete[] buf;    return data;&#125;
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理：内存分区</title>
    <url>/posts/b5d386b7.html</url>
    <content><![CDATA[核心要点速览
五大分区：栈（临时空间，自动管理）、堆（动态空间，手动管理）、全局 &#x2F; 静态区（持久空间）、常量存储区（只读）、代码区（指令存储）
关键点：各分区存储内容 &#x2F; 生命周期 &#x2F; 分配方式、栈与堆的区别、const 变量存储位置、线程局部存储特性
补充：全局 &#x2F; 局部 &#x2F; 静态局部 &#x2F; 静态全局变量的存储、生命周期及作用域差异


一、五大内存分区1. 栈（stack）：函数调用的临时空间
存储内容：函数内局部变量（非 static）、函数参数、返回地址（调用后需返回的下一条指令地址）、寄存器上下文（函数调用时保存的 CPU 寄存器状态）
生命周期：随函数调用创建，函数执行结束后自动释放（无需手动干预）
特点：
分配效率：编译器通过移动栈顶指针（SP 寄存器）完成分配 &#x2F; 释放，效率极高
内存特性：地址连续（栈帧结构），生长方向向下（从高地址向低地址扩展）
大小限制：默认固定（通常 1-8MB，可通过编译器 &#x2F; 操作系统配置），超出则触发栈溢出
初始化：未初始化的局部变量值为 “垃圾值”（随机值，取决于内存历史数据）



2. 堆（heap）：动态分配的手动管理空间
存储内容：通过new&#x2F;malloc&#x2F;new[]&#x2F;calloc等动态分配的内存
生命周期：从手动分配开始，到delete&#x2F;free&#x2F;delete[]手动释放结束；若未释放，仅在程序终止后由操作系统回收（运行时不会自动释放）
特点：
分配效率：需通过内存分配算法查找空闲块，效率低于栈
内存特性：地址不连续（受空闲块分布影响），生长方向向上（从低地址向高地址扩展，与栈相反）
大小灵活性：理论上可接近系统可用内存（GB 级），适合存储大尺寸 &#x2F; 生命周期不确定的数据
潜在问题：
内存碎片：频繁分配 &#x2F; 释放不同大小的块，导致空闲块分散，无法满足大内存分配需求
内存泄漏：未释放已不再使用的堆内存，导致可用内存逐渐减少
野指针：释放后未置空的指针，继续访问会触发未定义行为（崩溃、数据篡改）
重复释放：对同一指针多次调用delete&#x2F;free，导致堆结构损坏





3. 全局 &#x2F; 静态存储区
存储内容：
全局变量（定义在函数外部的变量）
静态变量：
全局静态变量（定义在函数外）
局部静态变量（定义在函数内）




生命周期：从程序加载（main函数执行前）到程序终止（main函数执行后），由操作系统自动分配和释放
特点：
分配时机：编译期确定大小，程序启动时由操作系统一次性分配
初始化：未显式初始化的变量会被自动置 0（区别于栈的 “垃圾值”），显式初始化则在程序启动前完成（早于main）
作用域差异：
全局变量：作用域为整个程序（其他文件可通过extern声明访问）
全局静态变量：作用域仅限当前文件（避免跨文件命名冲突）
局部静态变量：作用域仅限定义它的函数内部（但生命周期为程序全程）


初始化特性：局部静态变量仅在第一次进入函数时初始化，后续调用不再重复初始化



4. 常量存储区
存储内容：
字符串常量
全局const常量（定义在函数外）


生命周期：程序全程（从加载到终止）
特点：
只读属性：尝试修改会触发未定义行为（通常为程序崩溃，因内存被标记为只读）
优化共享：相同字符串常量可能被编译器合并（如const char* p1 = &quot;abc&quot;; const char* p2 = &quot;abc&quot;;，p1与p2指向同一地址，节省内存）
易混淆：
局部const变量（如函数内的const变量）存储在栈上（仅限制修改，生命周期同局部变量，本质是栈内存）
数组初始化拷贝：char arr[] = &quot;hello&quot;;中，&quot;hello&quot;在常量区，但数组arr在栈上（编译器会将常量区的字符串拷贝到栈数组中，修改arr元素是合法的）





5. 代码区
存储内容：程序的机器指令（二进制代码）、只读数据（如常量表达式计算结果）
生命周期：程序全程（从加载到终止）
特点：
只读保护：操作系统会将代码区标记为只读，防止意外修改指令（如缓冲区溢出攻击）
共享性：多进程 &#x2F; 线程运行同一程序时，共享同一份代码区（仅数据区独立），大幅节省内存
加载方式：程序启动时，由操作系统从磁盘可执行文件（如.exe&#x2F;.out）加载到内存，与数据区分离存储




二、对比表


分区
存储内容
生命周期
分配方式
管理方式



栈
局部变量、参数、返回地址
函数调用期间
编译器自动
自动释放


堆
动态分配内存（new&#x2F;malloc）
手动分配→手动释放
程序员手动
手动释放（delete&#x2F;free）


全局 &#x2F; 静态存储区
全局变量、静态变量
程序全程
编译期分配
程序结束自动释放


常量存储区
字符串常量、全局 const 常量
程序全程
编译期分配
程序结束自动释放


代码区
机器指令、只读数据
程序全程
程序加载时
只读不修改



三、线程局部存储（thread_local）
存储内容：由thread_local修饰的变量（线程私有变量，C++11 引入）
生命周期：与线程绑定（线程创建时初始化，线程结束时自动释放）
特点：
线程隔离性：每个线程拥有独立副本，修改当前线程的变量不影响其他线程（解决多线程全局变量竞争问题）
作用域：同普通变量（可定义为全局或局部），但仅对当前线程可见
初始化：若为局部thread_local变量，每个线程第一次进入作用域时初始化一次
示例：



thread_local int t_val = 0; // 每个线程有独立的t_valvoid func() &#123; t_val++; &#125; // 线程1调用后t_val=1，线程2调用后t_val=1（互不影响）


四、问答1. 全局 &#x2F; 局部 &#x2F; 静态变量的区别？


变量类型
存储分区
生命周期
作用域



全局变量
全局 &#x2F; 静态存储区
程序全程
整个程序（跨文件可访问）


静态全局变量
全局 &#x2F; 静态存储区
程序全程
仅限当前文件


局部变量
栈
函数调用期间
仅限函数内部


静态局部变量
全局 &#x2F; 静态存储区
程序全程
仅限函数内部


2. const 变量一定在常量区吗？不一定：

全局 const：常量区（只读，程序全程）；
局部 const：栈上（仅限制修改，生命周期同局部变量）；
static const：全局 &#x2F; 静态存储区（程序全程）。

3. 栈和堆的差异？
管理：栈自动、堆手动；
效率：栈 &gt; 堆；
连续性：栈连续、堆不连续；
生命周期：栈随函数、堆随手动释放；
大小：栈小且固定、堆大且灵活。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存</tag>
        <tag>内存分区</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理：异常传播与栈展开</title>
    <url>/posts/45737555.html</url>
    <content><![CDATA[核心要点速览
异常传播：无匹配catch时，异常逐层向上传递至调用者，直至捕获或触发std::terminate()
栈展开：传播过程中自动逆序销毁局部对象（按构造逆序），保障资源回收
规则：析构函数禁止抛异常（避免双重异常），未完全构造对象不执行析构
异常安全：依赖栈展开原子性 + RAII 机制，避免资源泄漏
补充：异常匹配优先精确 &#x2F; 继承兼容，捕获const引用可避免异常切片


一、异常传播：从抛出点到捕获点的传递逻辑概念函数抛出异常且自身无匹配try-catch时，异常会沿函数调用栈逐层向上传播，依次遍历调用者上下文，直到被某个catch块捕获；若全程无捕获，程序调用std::terminate()终止（默认执行std::abort()）。
传播流程
函数调用链：A→B→C，C 中抛出异常；
C 无catch匹配，异常传播至 B；
B 无catch匹配，继续传播至 A；
A 的try块监控到异常，匹配catch执行处理；
若 A 仍无匹配，异常传播至main函数，最终未捕获则程序终止。

细节
异常传播时，被跳过函数中 “已执行但未进入try块” 的代码不再执行；
传播仅终止当前线程执行流，不跨线程影响其他线程；
std::terminate()可通过std::set_terminate()自定义，但无法恢复程序执行，不推荐使用；
异常匹配遵循 “精确匹配优先、派生类兼容基类匹配”，捕获值会导致 “异常切片”（丢失派生类信息），推荐捕获const引用；
异常对象存储于专用内存区域，传播过程中仅拷贝或引用，处理完成后自动销毁。


二、栈展开：异常传播时的资源回收机制概念异常传播过程中，编译器自动触发栈展开：从异常抛出点开始，逆序遍历函数调用栈，销毁 “try块到抛出点之间” 的所有局部对象（自定义对象、智能指针等），确保资源（内存、文件句柄、锁）被正确释放。
特性
逆序销毁：严格遵循 “后构造先销毁”，与正常函数退出时的对象销毁顺序一致；
原子性：局部对象析构强制连续执行，不会因中间错误中断；
无额外开销：编译器自动实现，无需手动编写回收代码；
终止条件：异常被catch块捕获后，栈展开立即停止，程序跳转至catch块后继续执行。

代码示例（直观理解逆序销毁）class ResourceGuard &#123;public:    ResourceGuard(const std::string&amp; name) : resName(name) &#123;&#125;    ~ResourceGuard() &#123; std::cout &lt;&lt; &quot;释放资源：&quot; &lt;&lt; resName &lt;&lt; std::endl; &#125;private:    std::string resName;&#125;;void riskyFunc() &#123;    ResourceGuard res1(&quot;文件句柄&quot;);    ResourceGuard res2(&quot;内存块&quot;);    throw std::out_of_range(&quot;索引越界&quot;); // 触发栈展开&#125;// 栈展开时输出：释放资源：内存块 → 释放资源：文件句柄（逆序销毁）


三、关键规则与风险规避1. 析构函数禁止抛出异常
风险：栈展开过程中，析构函数抛新异常会导致 “双重异常”，程序直接终止；
规则：C++11 后析构函数默认隐式noexcept，显式声明更清晰；内部错误需自行处理（如记录日志），不向外抛出。

正确示例class SafeGuard &#123;public:    ~SafeGuard() noexcept &#123; // 显式声明noexcept        try &#123; releaseResource(); &#125;        catch(...) &#123; std::cerr &lt;&lt; &quot;资源释放失败&quot; &lt;&lt; std::endl; &#125; // 内部处理错误    &#125;&#125;;

2. 未完全构造的对象，析构函数不执行
规则：构造函数抛出异常时，对象视为 “未完全构造”，其析构函数不会被调用；
风险：构造函数中分配的资源（如new内存、文件句柄）会泄漏；
解决方案：用 RAII 机制管理资源（智能指针、资源守卫类），确保构造失败时资源自动释放。

3. 栈展开不销毁动态分配对象
规则：栈展开仅销毁栈上局部对象，堆上动态分配的对象（new&#x2F;malloc创建）不会自动释放；
规避方案：优先用unique_ptr&#x2F;shared_ptr管理动态内存，利用 RAII 机制在栈展开时自动释放堆内存。


补充
异常传播与函数调用栈：传播路径即调用栈回溯路径，栈展开仅覆盖 “try块到抛出点” 的栈帧；
栈展开性能开销：主要来自局部对象析构调用，性能影响可忽略，远低于资源泄漏的风险；
异常安全等级：最高为 “强异常安全”（异常后程序状态恢复如初），依赖栈展开 + RAII 机制实现；
多线程异常传播：线程内异常仅在当前线程传播，未捕获会导致当前线程终止，不影响进程（除非主线程）；
异常重新抛出：catch块中用throw;可保留原异常完整信息，避免throw 异常对象;导致的信息丢失。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>模板与STL：STL</title>
    <url>/posts/6e08d78f.html</url>
    <content><![CDATA[核心要点速览
组件：容器（存储）、算法（操作）、迭代器（桥梁）、仿函数（自定义逻辑）、适配器（接口转换）、分配器（内存管理）
容器分类：序列式（vector&#x2F;list&#x2F;deque）、关联式（有序红黑树 &#x2F; 无序哈希表）、适配器（stack&#x2F;queue&#x2F;priority_queue）
关键：底层实现、迭代器失效、容器选型、算法适用条件、内存与效率权衡


一、STL 组件
容器：类模板，封装数据结构（如 vector&#x2F;map），存储数据的载体。
算法：函数模板，提供通用操作（sort&#x2F;find），通过迭代器操作容器。
迭代器：类似指针的对象，提供元素访问接口，是容器与算法的桥梁。
仿函数：重载operator()的类 &#x2F; 结构体（函数对象），传递自定义逻辑（比较 &#x2F; 筛选）。
适配器：转换已有组件接口（含容器适配器、迭代器适配器如 reverse_iterator、函数适配器如 bind），如 stack 基于 deque 适配。
分配器：默认std::allocator，核心接口含allocate（分配）&#x2F;deallocate（释放）&#x2F;construct（构造）&#x2F;destroy（析构）；自定义分配器可优化内存碎片（极少使用）。


二、容器：分类、特性与选型1. 序列式容器（元素有序，依赖位置）


容器
底层实现
特性
适用场景



vector
连续动态数组
随机访问 O (1)，尾部增删 O (1)；扩容 1.5&#x2F;2 倍（GCC&#x2F;MSVC），中间增删 O (n)；支持reserve()&#x2F;resize()；emplace_back()比push_back()高效（直接构造，避免拷贝）
频繁随机访问、尾部增删（列表 &#x2F; 缓存）


list
双向链表
任意位置增删 O (1)（需定位），随机访问 O (n)；支持merge()&#x2F;splice()（多重载，转移元素无需拷贝，O (1) 效率）；双向迭代器
频繁中间增删（链表 &#x2F; 非 FIFO 队列）


deque
分段连续数组（缓冲区 + 中控器）
头尾增删 O (1)，随机访问 O (1)（略低于 vector）；扩容无需拷贝全部元素；无capacity()成员（分段存储无连续容量概念）；中间插入迭代器全失效；排序缓存命中率低，建议转 vector 排序
双端操作（BFS 队列）


2. 关联式容器（元素无序，依赖键值）有序关联容器（红黑树，O (logn) 操作）
包含：set（唯一键）、multiset（键可重复）、map（键值对，键唯一）、multimap（键可重复）
特性：按键升序排列（默认less&lt;Key&gt;），支持lower_bound()&#x2F;upper_bound()&#x2F;equal_range()；键为 const（不可修改），但可通过迭代器修改 map 的 value；count()返回键出现次数；双向迭代器

无序关联容器（哈希表，平均 O (1) 操作）
包含：unordered_set&#x2F;multiset、unordered_map&#x2F;multimap
特性：元素无序，前向迭代器；负载因子默认 1.0，超阈值触发rehash（迭代器全失效）；哈希冲突默认用链表法解决（C++17 后部分实现用红黑树优化长链表）；自定义键需特化std::hash+operator==

map vs unordered_map 对比


维度
map（红黑树）
unordered_map（哈希表）



查找效率
O (logn)（稳定）
平均 O (1)，最坏 O (n)（冲突严重）


有序性
支持（升序）
不支持


内存占用
较低
较高（冲突解决需额外空间）


迭代器
双向
前向


键值操作
[]会默认构造不存在的键；可通过replace()修改 value
[]行为同 map，需避免误触发默认构造


3. 容器适配器（接口转换）
stack（LIFO）：默认底层 deque，可指定 vector 为底层（stack&lt;int, vector&lt;int&gt;&gt;），接口push()&#x2F;pop()&#x2F;top()；支持emplace()直接构造元素
queue（FIFO）：默认底层 deque，接口push()&#x2F;pop()&#x2F;front()&#x2F;back()
priority_queue（最大堆）：底层仅支持 vector&#x2F;deque（需随机访问迭代器），不可用 list；最小堆需指定std::greater&lt;int&gt;；无迭代器遍历功能


三、迭代器：类型与失效1. 迭代器类型（按功能划分）


类型
支持操作
对应容器示例



输入迭代器
*（读）、&#x3D;&#x3D;&#x2F;!&#x3D;
istream_iterator


输出迭代器
*（写）
ostream_iterator


前向迭代器
输入 + 输出，多遍访问
unordered_set&#x2F;unordered_map


双向迭代器
前向功能 +--
list、map、set


随机访问迭代器
双向功能 ++n&#x2F;-n&#x2F;[]
vector、deque、数组


2. 失效场景


容器
插入操作
删除操作
其他失效场景



vector
扩容则全失效，未扩容则插入位后失效
删除位后失效（需iter=erase(iter)）
reserve()可能导致失效；shrink_to_fit()不必然失效


list
不失效
仅被删元素迭代器失效
-


map&#x2F;set
不失效
仅被删节点迭代器失效
-


unordered_*
未 rehash 则有效，rehash 全失效
仅被删元素迭代器失效
reserve()&#x2F;rehash()全失效


容器 swap
无
无
vector 可能因内存交换失效；其他容器迭代器仍有效（指向原元素）


3. 迭代器特性
算法通过std::iterator_traits&lt;Iter&gt;获取value_type（元素类型）、difference_type（迭代器差值）等，自定义迭代器需显式定义这些类型。
反向迭代器（reverse_iterator）：rbegin()指向尾元素，rend()指向首元素前；base()方法转换为原迭代器时，位置偏移一位（如rbegin().base() == end()）。
插入迭代器（back_insert_iterator 等）：通过back_inserter(v)生成，配合算法自动调用push_back()，避免手动管理迭代器位置。


四、算法与仿函数1. 常用算法


算法
功能
适用条件
注意点



sort
排序
随机访问迭代器（vector&#x2F;deque）
list 需用成员函数list::sort()；底层为 introsort（快排 + 堆排 + 插入排序）


binary_search
二分查找
有序序列 + 随机访问 &#x2F; 双向迭代器
仅返回是否存在；需获取元素迭代器用lower_bound()


find
线性查找
所有迭代器
O (n) 效率；map&#x2F;set 优先用成员函数find()（O(logn)）


for_each
遍历执行操作
所有迭代器
可传递函数 &#x2F; 仿函数 &#x2F;lambda；返回函数对象（可携带遍历后的状态）


remove
逻辑删除
所有迭代器
需配合erase()物理删除；不改变容器 size


unique
去重
有序序列 + 所有迭代器
需先排序，配合erase()生效；支持自定义谓词（如[](int a,int b){return abs(a-b)&lt;=2;}）；list 有专属unique()，直接物理删除


stable_sort
稳定排序（保原始顺序）
随机访问迭代器
多字段排序场景适用；空间复杂度 O (n)，高于 sort 的 O (logn)


2. 仿函数与 lambda
仿函数：可复用、带状态；标准库提供std::plus&lt;T&gt;（加法）、std::greater&lt;T&gt;（大于）等基础仿函数。
谓词要求：自定义比较谓词需满足严格弱序（非自反：comp(x,x)=false；反对称：comp(x,y)=true则comp(y,x)=false；传递性），违反会导致未定义行为（容器插入异常、算法崩溃）。
函数适配器：std::bind（绑定函数参数），与 C++11+ lambda 为互补关系（日常优先 lambda ，绑定类成员函数、兼容旧代码等场景std::bind更适配）。
优先级：容器成员函数 &gt; 全局算法（如map.find()比std::find()高效）。


五、容器选型决策树
需随机访问 → vector（优先）&#x2F;deque（需头操作）
需频繁中间增删 → list
需按键查找 → 有序（map&#x2F;set，范围查询 &#x2F; 有序遍历）&#x2F; 无序（unordered_*，纯查找高效）
需 LIFO&#x2F;FIFO&#x2F; 优先级 → stack&#x2F;queue&#x2F;priority_queue

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>模板与STL：模板基础</title>
    <url>/posts/6bd4602e.html</url>
    <content><![CDATA[核心要点速览
意义：将类型作为参数，实现通用逻辑，编译期生成具体类型代码
分类：函数模板（可隐式实例化）、类模板（需显式实例化）
模板参数：类型参数（typename T）、非类型参数（编译期常量）
特化：全特化（所有参数指定类型）、偏特化（仅类模板支持，部分参数指定类型）
区别：模板有类型检查，宏无；模板支持特化 &#x2F; 重载，宏不支持


一、模板的意义通过 “类型参数化” 让通用逻辑适配多种类型，既避免为不同类型重复编写相似代码（提升复用），又能在编译期进行类型检查（保证安全），且编译器会生成具体类型的代码（无运行时开销）。这也是 STL 容器（如 vector）和算法（如 sort）的实现基础。

二、函数模板定义生成具体函数的 “模板”，编译器根据实参类型自动实例化对应版本。
规则
语法：template&lt;模板参数列表&gt; 返回类型 函数名(参数列表) { ... }
实例化：
隐式实例化：编译器根据实参推导类型（如max(1,2)推导T=int）。
显式实例化：手动指定类型（如max&lt;int&gt;(1.5,2.5)强制T=int）。


重载：支持模板间重载（参数列表 &#x2F; 模板参数不同），非模板函数优先级高于模板函数。

函数模板VS模板函数
函数模板是带template的 “通用模板”（比如template&lt;typename T&gt; T add(T a, T b)），是生成具体函数的 “模具”，本身不能直接调用。
模板函数是从函数模板实例化出的 “具体函数”（比如int add(int a, int b)），是能实际调用的实体。
示例说明：

// 1. 函数模板（模板/蓝图）template&lt;typename T&gt;  // 包含类型参数T，通用定义T add(T a, T b) &#123;    return a + b;&#125;int main() &#123;    // 调用时，编译器根据实参类型实例化出模板函数    int sum1 = add(1, 2);  // 触发实例化：int add(int a, int b)（模板函数1）    double sum2 = add(1.5, 2.5);  // 触发实例化：double add(double a, double b)（模板函数2）    return 0;&#125;


三、类模板定义生成具体类的 “模板”，用于创建与类型相关的通用类（如vector、map）。
规则
语法：template&lt;模板参数列表&gt; class 类名 { ... };
实例化：必须显式指定模板参数（编译器无法推导），格式类名&lt;类型&gt;（如Vector&lt;int&gt;）。
成员函数：类外定义时需保留模板参数（如template&lt;typename T&gt; void Vector&lt;T&gt;::push_back(T val) { ... }）。


四、模板参数：类型参数与非类型参数1. 类型参数
声明：typename或class修饰（两者等价），代表任意类型（如int、string、自定义类）。
用途：最常用，适配不同数据类型。

2. 非类型参数
定义：代表编译期常量（值在编译期可确定）。
支持类型：整数类型（int、size_t）、全局变量 &#x2F; 函数的指针 &#x2F; 引用。
限制：不支持浮点数、类对象（编译期无法确定值）。

// 非类型参数示例：固定大小数组template&lt;typename T, int N&gt; // N为编译期常量class FixedArray &#123;    T arr[N]; // 大小由N确定public:    int size() &#123; return N; &#125;&#125;;


五、模板特化：定制特定类型实现为特定类型提供定制化实现，覆盖泛化版本（解决泛化模板对某些类型不适用的问题）。
1. 全特化
定义：为模板所有参数指定具体类型，完全覆盖泛化版本。

template&lt;typename T&gt; class Printer &#123; /* 泛化逻辑 */ &#125;;template&lt;&gt; class Printer&lt;int&gt; &#123; /* int类型专属逻辑 */ &#125;; // 全特化

2. 偏特化（仅类模板支持）
定义：为模板部分参数指定具体类型，函数模板不支持偏特化。

template&lt;typename T&gt; class Handler &#123; /* 泛化逻辑 */ &#125;;template&lt;typename T&gt; class Handler&lt;T*&gt; &#123; /* 指针类型专属逻辑 */ &#125;; // 偏特化


六、补充1. 惰性实例化模板仅实例化被使用的成员，未使用的成员不会生成代码（减少冗余）。
2. 分离编译问题模板定义与声明不能分离到.h和.cpp（需放在同一文件，或显式实例化特定类型）。
3. 模板与宏的区别


对比维度
模板（Template）
宏（#define）



类型检查
编译期强类型检查（安全）
无类型检查（文本替换，易错）


调试支持
支持（可见具体实例化类型）
不支持（替换后无宏信息）


灵活性
支持复杂逻辑、重载、特化
仅简单文本替换（复杂逻辑易出错）


代码生成
编译期生成具体类型代码
预编译期替换，不生成新代码


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理：异常基础与语法</title>
    <url>/posts/33981620.html</url>
    <content><![CDATA[核心要点速览
异常处理三关键字：throw（抛出异常）、try（监控异常代码）、catch（捕获处理异常），核心是分离错误检测与处理
基本流程：try监控→throw抛异常→catch匹配处理；无匹配则异常传播，最终未捕获则程序终止
匹配规则：catch按声明顺序匹配，子类异常需在父类前捕获，catch(...)（万能捕获）必须放最后
异常类型：推荐类类型（标准库异常或自定义类），可携带详细信息；避免基本类型（语义模糊）


一、三个关键字一、throw（抛出异常）
作用：检测到不可处理的错误（如参数非法）时，主动抛出异常对象，中断当前执行，通知上层处理。
语法：throw 表达式;（表达式结果为异常对象）。
细节：
异常类型选择：
不推荐基本类型（如throw 1，语义模糊，无法区分错误类型）；
推荐类类型（如标准库std::invalid_argument），可携带详细信息（如&quot;文件路径不能为空&quot;）。


执行逻辑：throw后，当前函数中后续代码立即终止，进入异常传播阶段（寻找匹配catch）。



二、try（监控异常）
作用：包裹可能抛出异常的代码，标记需监控的区域，是异常检测的起点。
语法：

try &#123; /* 可能抛异常的代码 */ &#125;// 必须紧跟1个及以上catch块（否则编译报错）


细节：
不可单独存在，必须搭配catch块；
无异常时，直接跳过所有catch，执行后续代码。



三、catch（捕获与处理异常）
作用：匹配try块中抛出的异常类型，执行处理逻辑（如打印错误、释放资源）。
语法：

catch (异常类型 变量名) &#123; /* 处理逻辑 */ &#125;  // 变量名可省略


规则：
匹配顺序：按声明顺序匹配，首个匹配的catch执行后，后续catch不再执行。
子类异常catch必须在父类前（否则父类会屏蔽子类处理）。
错误示例：父类catch(std::exception&amp;)在前，子类catch(std::out_of_range&amp;)在后（子类处理永远不执行）。


catch(...)：万能捕获，兜底处理所有未匹配的异常，必须放最后（否则屏蔽后续catch）。
异常对象生命周期：throw生成的临时对象存储在特殊区域，catch捕获副本或引用，处理后自动销毁。



二、执行流程
正常流程：try块代码执行完毕→跳过所有catch块→执行catch之后的代码。
异常流程：
try块中执行throw→立即终止try块，生成异常对象；
按顺序检查catch块，匹配第一个兼容类型的块并执行；
若未匹配，异常向上传播（到调用当前函数的外层try-catch）；
若全程无匹配，程序调用std::terminate()终止（默认执行abort()）。



三、问答
try、throw、catch的协作流程是什么？


try监控代码块→throw在错误时抛出异常对象，中断当前执行→按顺序匹配catch块，执行第一个匹配的处理逻辑；无匹配则异常传播，最终未捕获则程序终止。


catch块的匹配顺序有什么要求？为什么？


需按声明顺序匹配，且子类异常catch必须在父类前。因为父类异常可以捕获子类异常，若父类catch放前面，子类catch会被屏蔽，无法执行针对性处理。


catch(...)的作用和使用注意事项？


作用是捕获所有未被前面catch匹配的异常，作为兜底处理。注意必须放在所有catch块最后，否则会屏蔽后续catch，导致特定异常无法处理。


为什么推荐用类类型（而非基本类型）作为异常对象？


类类型可携带详细错误信息（如what()返回的描述），支持继承多态，便于按错误类型分类处理；基本类型语义模糊，无法区分不同错误场景。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C++特性：Lambda表达式</title>
    <url>/posts/bbcf5ff7.html</url>
    <content><![CDATA[核心要点速览
语法：[捕获列表](参数) mutable -&gt; 返回类型 { 函数体 }，必填：捕获列表 + 函数体
捕获方式：[=]（值）、[&amp;]（引用）、[=, &amp;x]（混合）、[this]（类内）、[x=std::move(y)]（C++14 移动捕获）
陷阱：悬垂引用 &#x2F;this、mutable误用、多 return 未显式指定返回类型、STL 排序谓词非严格弱序
特性：无捕获转函数指针、有捕获需std::function包装、C++14 泛型、C++17constexpr&#x2F;[*this]
用途：简化 STL 算法参数（sort&#x2F;find_if），替代短小的临时函数和仿函数


一、捕获列表1. 捕获方式


捕获方式
说明



[=]
捕获时机为 Lambda 创建时，仅拷贝实际使用的外部变量，外部变量后续修改不会影响副本


[&amp;]
默认引用捕获所有用到的外部变量，优点是无拷贝开销，但严禁返回带此捕获的 Lambda（极易产生悬垂引用）


[=, &amp;x]
默认值捕获，仅 x 显式按引用捕获，显式捕获必须与默认方式相反，这是语法硬性规则


[this]
类成员函数中默认捕获，可访问类的成员变量和成员函数，Lambda 生命周期绝对不能超过当前对象


[x=std::move(y)]
C++14 新增的移动捕获，专门解决std::unique_ptr等不可拷贝对象的捕获问题，转移 y 的所有权到 x


2. 陷阱1：悬垂引用（返回局部变量引用捕获）
错误：auto bad() { int x; return [&amp;x]() { return x; }; }（函数返回后 x 销毁，Lambda 引用悬垂，调用时是未定义行为）
正确：值捕获 return [x]() { return x; }（拷贝 x 形成副本，副本生命周期与 Lambda 一致，无风险）

2：悬垂this（类内返回[this] Lambda）
错误：class A { int val; auto get() { return [this]() { cout &lt;&lt; val; }; } }（若调用对象是临时对象，对象销毁后this悬垂）
正确（C++17+）：return [*this]() { ... }（值捕获整个对象副本，彻底规避悬垂风险）

3. 捕获禁忌
非法：[=, x]（重复值捕获）、[&amp;, &amp;y]（重复引用捕获）、直接捕获函数参数（需通过 Lambda 参数列表传递）
合法：全局变量、静态变量无需捕获，可在 Lambda 内直接访问（存储在静态区，不属于局部作用域）

二、类型与存储
无捕获 Lambda：可隐式转换为函数指针，这是因为无状态的 Lambda 本质和普通函数一致
 示例：void(*func)() = []() {};

有捕获 Lambda：因持有外部变量状态，无法转换为函数指针，必须用std::function包装，适用于函数参数、返回值等场景
 示例：std::function&lt;int(int)&gt; f = [x=2](int a) { return a*x; };

大小规律：空捕获 Lambda 大小为 1（符合 C++ 空类的默认大小规则），值捕获 Lambda 大小等于捕获变量总大小，引用捕获 Lambda 大小等于指针大小（64 位系统下为 8 字节）


三、版本特性


版本
特性
示例



C++14
泛型 Lambda + 移动捕获
[](auto x){}; &#x2F; [p=std::move(u)](){}


C++17
constexpr Lambda
constexpr auto sq = [](int x){ return x*x; };（编译期执行，无运行时开销）


C++17
[*this]值捕获对象
return [*this]() { cout &lt;&lt; val; };（解决悬垂 this 问题）


四、STL 算法结合1. std::sort
易错点：排序谓词必须满足 “严格弱序”，必须用a&lt;b或a&gt;b，禁用a&lt;=b或a&gt;=b，否则可能导致算法崩溃
  示例：sort(vec.begin(), vec.end(), [desc](int a, int b) { return desc ? a&gt;b : a&lt;b; })


2. std::find_if
核心：谓词返回bool类型，可通过捕获外部变量灵活控制筛选条件，是 STL 查找场景的常用写法
  示例：find_if(strs.begin(), strs.end(), [minLen](const auto&amp; s) { return s.size()&gt;=minLen; })


五、易错1. mutable
作用：仅解除值捕获变量的const限制（不影响外部变量，只是允许修改 Lambda 内部的副本）

易错：无参数时必须带()，这是编译器的硬性要求，缺()会直接编译失败
  正确：[a]() mutable { a++; }，错误：[a] mutable { a++; }


2. 返回类型推导陷阱
单return语句时，编译器可自动推导返回类型；多个return语句类型不同时，必须显式指定返回类型，否则编译器无法判定统一类型
  正确：[](bool f) -&gt; double { return f ? 1 : 2.0; }，错误：省略-&gt; double（int 与 double 类型冲突）


3. C++14 泛型 Lambda
参数支持auto，无需手动定义模板，就能实现通用逻辑，大幅简化代码
  示例：[](auto x, auto y) { return x + y; }（支持 int、double 等任意可相加的类型）


六、问答1. 有捕获的 Lambda 为什么不能转函数指针？
函数指针仅存储函数代码地址，是无状态的；而有捕获的 Lambda 持有外部变量状态，这些状态需要额外的存储空间，函数指针无法承载，因此不能转换。

2. [=]和[&amp;]的风险？
[=]：对大对象捕获时会产生拷贝开销，影响性能；[&amp;]：最大风险是悬垂引用，尤其是返回带此捕获的 Lambda 时，几乎必然触发未定义行为。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>函数式编程</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C++特性：右值引用和移动语义</title>
    <url>/posts/4d855a6b.html</url>
    <content><![CDATA[核心要点速览
左值 vs 右值：左值有持久地址（可 &amp; 取址），右值是临时对象 &#x2F; 字面量（不可 &amp; 取址）
右值引用（T&amp;&amp;）：绑定右值，延长其生命周期，支持修改绑定对象
移动语义：通过移动构造 &#x2F; 赋值转移资源（而非拷贝），提升性能（避免深拷贝）
std::move：将左值转为右值引用（仅转换，不移动资源），原对象不应再使用
完美转发：std::forward 保持参数左值 &#x2F; 右值属性，用于模板传递参数


一、左值与右值：值的分类1. 左值
定义：可放在赋值左侧，有持久内存地址，生命周期较长（如变量、函数返回的左值引用）。
特征：可被&amp;取址（&amp;a合法），可被赋值（a = 5合法）。
示例：int x = 10;（x 是左值）、int&amp; func()（返回左值引用，是左值）。

2. 右值
定义：只能放在赋值右侧，无持久内存地址（或地址无意义），生命周期短暂。
分类：
纯右值：字面量（5、&quot;hello&quot;）、表达式结果（x + y）、临时对象（func()返回非引用时）。
将亡值：即将被销毁的对象（如返回局部对象的函数返回值）。


特征：不可被&amp;取址（&amp;5编译报错），通常是临时结果。


二、右值引用（T&amp;&amp;）：绑定右值的引用类型特性
绑定对象：仅能绑定右值（纯右值或将亡值），不能直接绑定左值（需通过std::move转换）。
生命周期延长：绑定临时对象后，临时对象生命周期延长至与右值引用相同（避免被立即销毁）。
可修改性：与const T&amp;（常量左值引用，只读）不同，T&amp;&amp;可修改绑定的右值（因右值即将销毁，修改无副作用）。

三种引用对比


引用类型
语法
可绑定对象
能否修改绑定值
典型用途



左值引用
T&amp;
左值
能（非 const）
传递参数、返回引用


常量左值引用
const T&amp;
左值、右值
不能
接收任意值（避免拷贝）


右值引用
T&amp;&amp;
右值（纯右值、将亡值）
能
实现移动语义、完美转发


常量右值引用
const T&amp;&amp;
右值
不能
禁止移动操作（极少使用）


万能引用与引用折叠
万能引用：仅当T&amp;&amp;出现在模板参数推导场景（如template&lt;typename T&gt; void func(T&amp;&amp; param)）时，才是万能引用，可绑定左值和右值；非模板场景下T&amp;&amp;就是普通右值引用（如void func(int&amp;&amp; param)）。
引用折叠规则：C++ 禁止直接声明引用的引用，编译器会自动折叠，原则为左值引用优先
若任一引用为左值引用（&amp;），最终结果为左值引用（如int&amp; &amp;&amp; → int&amp;）
仅当两个都是右值引用（&amp;&amp;），结果才为右值引用（如int&amp;&amp; &amp;&amp; → int&amp;&amp;）


作用：是完美转发的底层实现原理，决定了模板参数的最终引用类型。


三、移动语义：避免冗余拷贝1. 移动构造函数与移动赋值运算符移动构造函数
语法：T(T&amp;&amp; other) noexcept;
作用：接管other的动态资源（如指针指向的内存），将other置为 “可安全销毁” 状态（如指针置空）。
示例逻辑：

String(String&amp;&amp; other) noexcept : str(other.str) &#123;    other.str = nullptr; // 掏空原对象，避免析构时重复释放&#125;


默认移动构造 &#x2F; 赋值的生成条件：


类未自定义拷贝构造、拷贝赋值、析构、移动构造、移动赋值中的任意一个；
所有非静态数据成员和基类可被移动语义处理（允许部分成员拷贝，不影响生成）。

移动赋值运算符
语法：T&amp; operator=(T&amp;&amp; other) noexcept;
作用：先释放当前对象资源，再接管other的资源，最后将other置空。
注意：需处理自赋值场景，避免资源提前释放。

2. 优势
性能优化：将深拷贝（内存分配 + 数据复制）简化为指针赋值，大幅提升效率。
资源安全：针对将亡值（如临时对象），转移资源不影响其他对象。
支持不可拷贝对象的转移：某些资源（如文件句柄）不可拷贝，但可通过移动转移所有权。


四、std::move：左值转右值引用（非实际移动）
作用：强制将左值转换为右值引用（仅修改值的属性，不实际移动资源），底层本质是static_cast&lt;T&amp;&amp;&gt;。
特性：
转换后原对象仍 “有效但不应再使用”（资源可能已被转移）。
可用于任何对象（内置类型、自定义类型），无性能开销。
对 const 对象无效：const T调用std::move后仍是const T&amp;&amp;，无法触发移动构造，会调用拷贝构造。


示例：String s1; String s2 = std::move(s1);（s1 转为右值引用，触发 s2 的移动构造）。


五、完美转发：保持参数值类别
问题：模板中传递参数时，左值 &#x2F; 右值属性可能丢失（如右值被转为左值引用）。
解决方案：std::forward&lt;T&gt;(t)，根据T的类型保持参数的左值 &#x2F; 右值属性，仅在模板万能引用场景下有效。
与 std::move 的区别：
std::move：无条件将左值转右值，仅用于触发移动语义
std::forward：有条件转发，仅在模板中根据参数原始类型保持属性


典型场景：模板转发参数至内部函数，确保参数类型正确传递：

template&lt;typename T&gt;void wrapper(T&amp;&amp; t) &#123;    func(std::forward&lt;T&gt;(t)); // 保持t的左值/右值属性&#125;


六、补充
noexcept 的作用：移动构造 &#x2F; 赋值若加noexcept，标准容器（如vector）扩容时会优先选择移动而非拷贝（避免异常导致数据丢失），否则可能 fallback 到拷贝，失去优化意义。
移动语义 vs 拷贝语义：拷贝是 “复制资源，原对象不变”；移动是 “转移资源，原对象失效”。
右值引用为何能提升性能：针对临时对象（右值），无需拷贝其资源，直接转移所有权，消除冗余的内存分配和复制。
RVO&#x2F;NRVO 与移动语义的关系：
返回值优化（RVO）：C++17 后强制，编译器直接在调用者内存构造返回对象，跳过拷贝 &#x2F; 移动构造
命名返回值优化（NRVO）：优化命名局部变量返回，非标准强制，编译器通常支持
注意：RVO&#x2F;NRVO 优先级高于移动语义，若触发优化，不会调用移动构造函数


移动语义的常见陷阱：
移动后原对象仅保证可析构，不可再访问其资源（如空指针解引用）
浅拷贝对象（无动态资源）使用移动语义无性能提升，反而增加代码复杂度
类中自定义析构函数会导致默认移动函数失效，需手动实现



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>右值引用</tag>
        <tag>移动语义</tag>
      </tags>
  </entry>
  <entry>
    <title>数组与字符串：字符串</title>
    <url>/posts/5f08cd61.html</url>
    <content><![CDATA[核心要点速览
C 风格字符串：以&#39;\0&#39;结尾的字符数组，依赖cstring库函数，无安全检查（易溢出）
C++ std::string：动态管理、安全便捷，支持 SSO（小字符串优化），提供丰富成员方法
拷贝关键：C 语言strcpy不安全、strncpy需补&#39;\0&#39;、strlcpy安全非标准；C++ 直接用拷贝构造 &#x2F; 赋值 &#x2F;assign


一、C 风格字符串（char[]）本质是以&#39;\0&#39;（空字符）为结束标记的字符数组，&#39;\0&#39;是字符串终止的核心标识。
1. 初始化（易错）// 正确写法char str1[] = &quot;hello&quot;;  // 自动添加&#x27;\0&#x27;，数组长度6（h e l l o \0）char str2[] = &#123;&#x27;h&#x27;,&#x27;i&#x27;,&#x27;\0&#x27;&#125;;  // 手动添加&#x27;\0&#x27;，长度3char str3[10] = &quot;hi&quot;;  // 未初始化部分自动填&#x27;\0&#x27;，长度10// 错误写法char str4[] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;  // 无&#x27;\0&#x27;，strlen会越界扫描（未定义行为）

2. 主要操作函数（cstring库）


函数
功能
陷阱与注意事项



strlen(s)
计算&#39;\0&#39;前的字符数（不含&#39;\0&#39;）
无&#39;\0&#39;时越界扫描；返回值是size_t（无符号），避免与 int 比较


strcpy(dst, src)
拷贝src到dst（含&#39;\0&#39;）
dst容量不足会溢出；无长度检查，不安全


strcat(dst, src)
拼接src到dst末尾
需dst已含&#39;\0&#39;；总长度超dst容量会溢出


strcmp(s1, s2)
字典序比较
返回 0 表示相等，正数s1&gt;s2、负数s1&lt;s2；不可用=&#x3D;比较字符串



二、C++ std::string动态管理的字符串类，无需手动处理&#39;\0&#39;，安全便捷，是 C++ 开发首选。
1. 核心特性
动态大小：自动扩容，支持push_back、append等操作
安全保障：at()方法越界抛异常，[]无检查（需自行确保合法）
便捷操作：重载+（拼接）、=&#x3D;（比较）等运算符
内存优化：小字符串优化（SSO），短字符串存栈上（无需堆分配）

2. 常用方法


方法
功能
注意事项



size()&#x2F;length()
返回字符数（不含&#39;\0&#39;）
功能完全一致，仅历史原因并存


c_str()&#x2F;data()
转为 C 风格字符串（const char*）
指针有效期与string绑定，修改string后可能失效


substr(pos, len)
提取子串（从pos开始，长度len）
pos越界抛异常；len超范围则取到字符串末尾


find(sub, pos)
从pos查找sub，返回起始索引
未找到返回string::npos（需用该常量判断，而非 - 1）


reserve(n)
预分配n个字符内存
提升扩容效率，不改变size（实际字符数）


resize(n, c)
调整字符数为n，不足补字符c
可能截断长字符串或填充短字符串


3. 深入特性（1）小字符串优化（SSO）
短字符串（通常长度≤15）：直接存储在std::string对象内部（栈内存），无堆分配开销。
长字符串：存储在堆内存，string对象仅保存指针、长度、容量信息。

（2）迭代器失效
触发场景：push_back、append、resize等可能导致扩容的操作，底层内存重分配。
后果：原有迭代器、指针、引用失效（访问即未定义行为）。

（3）C 风格字符串转换
std::string → C 风格：c_str()（返回const char*，不可修改）。
C 风格 → std::string：直接赋值（string s = c_style_str;），自动识别&#39;\0&#39;。


三、字符串拷贝1. C 语言拷贝函数（cstring库）（1）strcpy（基础，不安全）
核心逻辑：拷贝src到dst，直到&#39;\0&#39;（含&#39;\0&#39;），无长度检查。
特点：支持链式操作；dst容量不足会缓冲区溢出（高危）。

（2）strncpy（带长度限制，需补&#39;\0&#39;）
核心逻辑：最多拷贝n个字节；src长度≤n时补&#39;\0&#39;，&gt;n 时不补&#39;\0&#39;。
特点：降低溢出风险，但需手动确保dst以&#39;\0&#39;结尾（否则不是合法字符串）。

（3）strlcpy（安全首选，非标准）
核心逻辑：目标缓冲区大小dest_size，最多拷贝dest_size-1字节，强制补&#39;\0&#39;。
特点：完全避免溢出；返回src长度（不含&#39;\0&#39;）；非 ISO C 标准，广泛支持（Linux&#x2F;BSD）。

（4）memcpy（按字节拷贝，通用）
核心逻辑：拷贝n个字节，不依赖&#39;\0&#39;，适用于任意数据（字符串、数组、结构体）。
字符串场景注意：需手动计算src长度（含&#39;\0&#39;），避免遗漏终止符。

2. C++ std::string拷贝方式
拷贝构造：string dest(src);
赋值运算符：string dest = src;
assign方法：dest.assign(src, pos, len);（从src第pos位拷贝len个字符）

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理：标准库异常与自定义异常</title>
    <url>/posts/e7e63c57.html</url>
    <content><![CDATA[核心要点速览
标准库异常：以std::exception为基类，分逻辑错误（编译可避免）和运行时错误（运行不可预知）两大类，核心接口what()返回错误描述
自定义异常：推荐继承std::exception，重写what()（必须加noexcept），语义需贴合业务场景
核心原则：优先复用标准库异常，自定义异常兼顾兼容性与信息完整性，杜绝基本类型异常，避免滥用

一、标准库异常体系（&lt;stdexcept&gt;）结构标准库提供了一套统一的异常类继承体系，所有标准异常均派生自std::exception抽象基类。这种设计保证了异常处理的兼容性 —— 无论捕获具体异常还是统一捕获基类引用，都能有效处理，是面试中 “规范异常使用” 的核心考点。
基类：std::exception
接口：virtual const char* what() const noexcept;  纯虚函数，返回 C 风格错误描述字符串，子类必须重写该方法才能实例化。
特性：无参构造、拷贝构造、拷贝赋值均被标记为noexcept，确保异常对象自身的构造和拷贝过程不会抛出新异常（避免双重异常）。

异常分类与常用派生类标准异常按错误性质分为两大类，需精准区分适用场景， “错误类型与异常类的对应关系”：
1. 逻辑错误（std::logic_error）
特点：编译阶段可预判、可避免的错误（本质是编程逻辑缺陷），抛出这类异常通常意味着代码存在可修复的问题。
常用派生类及场景：
std::invalid_argument：参数无效，比如传递负数给 “年龄” 参数、空指针给需非空的函数。
std::out_of_range：范围越界，比如数组索引超出大小、字符串substr的起始位置超出长度。
std::domain_error：定义域错误，比如给平方根函数传入负数、数学运算的参数超出有效定义域。



2. 运行时错误（std::runtime_error）
特点：编译阶段无法预知，由运行环境或资源状态导致的错误（非编程逻辑问题），即使代码无缺陷也可能触发。
常用派生类及场景：
std::range_error：数值范围错误，比如计算结果溢出 &#x2F; 下溢（如 int 类型相加超出最大值）。
std::overflow_error：算术溢出，专门用于标记数值运算时的溢出场景（比range_error更精准）。



特殊标准异常（无需&lt;stdexcept&gt;）
std::bad_alloc：new动态分配内存失败（系统内存耗尽）时自动抛出。
std::bad_cast：dynamic_cast向下转型失败（如基类指针转无关子类指针）时抛出。

使用细节（避坑要点）
what()返回值仅作调试参考，不可依赖格式（编译器实现不同）。
逻辑错误需手动抛出（提示修复代码），运行时错误可手动抛出或系统触发。
避免直接抛出std::logic_error&#x2F;std::runtime_error基类，需用具体派生类（便于精准处理）。

二、自定义异常类1. 设计原则
兼容性：继承std::exception或其派生类（支持统一捕获）。
信息完整：存储关键信息（如文件名、错误码、原因），便于定位问题。
安全性：what()必须加noexcept，构造 &#x2F; 析构不可抛异常。
语义清晰：类名贴合业务（如FileException&#x2F;NetworkException），避免模糊命名。

2. 正确实现示例class FileException : public std::exception &#123;private:    std::string errorMsg; // 存储完整错误信息public:    // 构造函数：拼接文件名+错误原因    FileException(const std::string&amp; filename, const std::string&amp; reason) &#123;        errorMsg = &quot;文件操作失败：文件名=&quot; + filename + &quot;，原因=&quot; + reason;    &#125;    // 重写what()，显式noexcept+override    const char* what() const noexcept override &#123;        return errorMsg.c_str();    &#125;&#125;;

3. 常见错误
漏加noexcept：what()抛异常会触发双重异常，程序直接终止。
未重写what()：返回基类默认无意义信息，失去异常提示价值。
滥用动态内存：异常类中new的资源需在析构函数（noexcept修饰）中释放，否则易泄漏。

4. 简化实现技巧若业务场景可匹配标准异常子类，直接继承该子类，复用父类构造和what()：
// 继承std::invalid_argument，复用父类逻辑class InvalidAgeException : public std::invalid_argument &#123;public:    using std::invalid_argument::invalid_argument; // 复用构造函数&#125;;// 使用：throw InvalidAgeException(&quot;年龄必须在0-150之间，当前值：200&quot;);




写法
异常的 “标签”
调用者看到的信息



throw std::invalid_argument(&quot;年龄无效&quot;)
技术标签：参数无效
知道是参数错了，但不知道是哪个参数（年龄？手机号？密码？）


throw InvalidAgeException(&quot;年龄无效&quot;)
业务标签：年龄无效
一眼就知道是 “年龄” 这个业务字段出了问题


三、异常使用的最佳实践1. 异常类型选择优先级
优先用标准库异常（避免重复造轮子，提升兼容性）；
标准库无法覆盖时，自定义异常（遵循设计原则）；
坚决杜绝基本类型异常（throw 1&#x2F;throw &quot;error&quot;，语义模糊，不支持多态捕获）。

2. 异常安全要求
异常对象构造安全：构造函数不可抛异常，避免无法生成异常对象。
资源清理依赖 RAII：用智能指针、资源守卫类管理try块中资源（文件句柄、锁、动态内存），防止泄漏。
捕获粒度合理：先捕获具体异常（自定义 &#x2F; 标准库派生类）→ 再用catch(const std::exception&amp;)兜底 → 可选catch(...)（需记录日志，不吞异常）。

3. 避免滥用异常
不用于控制流程：异常是 “错误处理机制”，不可替代if-else（如不用异常判断用户输入为空）。
不抛笼统异常：避免直接抛std::exception，导致调用者无法区分具体错误。
轻量场景用错误码：简单参数校验、非严重错误（如输入格式错），返回错误码更高效（避免异常栈展开开销）。

补充
what()返回值生命周期：与异常对象一致，对象销毁后不可访问（避免悬垂指针）。
多态捕获：所有异常（标准 + 自定义）继承std::exception，故catch(const std::exception&amp;)可统一捕获，是异常体系核心设计。
逻辑 &#x2F; 运行时错误边界：编码阶段可通过逻辑避免→logic_error子类；编码阶段无法控制（如系统内存、文件是否存在）→runtime_error子类。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C++特性：类型推导</title>
    <url>/posts/6d04aba6.html</url>
    <content><![CDATA[核心要点速览
auto：基础推导忽略顶层 const &#x2F; 引用，C++14 拓展至函数返回值与 lambda 参数，有明确使用限制。
decltype：精确保留类型（含 const &#x2F; 引用），支持表达式推导，双层括号是推导左值引用的关键。
模板类型推导：分按值 &#x2F; 按引用 &#x2F; 万能引用三类场景，需特殊处理数组与函数名，核心是 “实参到形参的类型映射”。
进阶场景：decltype(auto) 结合两者优势，auto&amp;&amp; 适配多值类别，万能引用需搭配 std::forward 实现完美转发。
区别：auto 侧重 “简化声明”，decltype 侧重 “精确获取”，模板推导侧重 “参数适配”。


一、auto：自动推导变量类型用途是简化长类型声明，C++14 拓展了适用场景，推导逻辑聚焦 “忽略顶层修饰，保留底层约束”。
1. 推导规则
必须初始化：编译器依赖初始化表达式推导，未初始化编译报错（如auto x;报错）。
顶层 const &#x2F; 引用忽略：变量本身的 const 和引用被舍弃，底层 const（指向常量的约束）保留。
示例：const int x=10; auto a=x;（a 为 int）；int&amp; ref=x; auto c=ref;（c 为 int）；const int* p=&amp;x; auto e=p;（e 为const int*）。


显式保留修饰：需保留引用 &#x2F;const 时，添加&amp;或const，如auto&amp; b=x;（b 为const int&amp;）、const auto f=x;（f 为const int）。

2. C++14 拓展规则
函数返回值推导：所有 return 语句类型需一致，不可用于递归函数。
示例：auto add(int a, int b) { return a + b; }（推导为 int）。


泛型 lambda：lambda 参数可声明为 auto，支持多类型调用。
示例：auto sum = [](auto a, auto b) { return a + b; };（兼容 int、double 等）。



3. 限制
不用于函数参数：void func(auto x)（C++17 后支持但不推荐，易与模板混淆）。
不用于非静态成员变量：类成员初始化时机与 auto 推导冲突。
不推导数组类型：int arr[5]; auto p=arr;（p 为int*，需保留数组类型用auto(&amp;p)[5] = arr;）。

二、decltype：推导表达式精确类型优势是 “完全保留原始类型”，无需执行表达式，适配需精确类型的场景。
1. 推导规则
推导变量名：结果为变量声明类型（完全保留 const 和引用）。
示例：const int&amp; ref=x; decltype(ref) r=ref;（r 为const int&amp;）。
双层括号规则：变量名加双层括号时，推导为左值引用（(x)是左值表达式）。
示例：int x=10; decltype(x) a=x;（a 为 int）；decltype((x)) b=x;（b 为int&amp;，需初始化）。




推导表达式：根据值类别判断，左值表达式推导为引用，右值表达式推导为非引用。
示例：int x=0; decltype(x++) a=x;（x++ 是右值，a 为 int）；decltype(++x) b=x;（++x 是左值，b 为int&amp;）。


推导函数调用：结果为函数返回类型（不执行函数，需声明可见）。
示例：int func(int); decltype(func(3)) c=0;（c 为 int）。



2. 用途
模板返回值推导：避免类型丢失，C++11 需尾置返回值，C++14 可省略。
示例：template&lt;typename T, typename U&gt; auto add(T a, U b) -&gt; decltype(a+b) { return a+b; }。


简化复杂类型声明：如std::map&lt;int, std::string&gt; m; decltype(m.begin()) it = m.begin();。

三、auto 与 decltype 区别


对比维度
auto
decltype



推导依据
变量初始化表达式的类型
任意表达式 &#x2F; 变量名的类型（不执行表达式）


const &#x2F; 引用处理
忽略顶层 const 和引用，保留底层 const
完全保留 const 和引用（含表达式值类别）


初始化要求
必须初始化
无需初始化（推导表达式类型时）


C++ 版本拓展
C++14 支持函数返回值、lambda 参数
C++11 起稳定，无重大拓展


进阶场景
可结合&amp;&amp;实现auto&amp;&amp;
可结合auto实现decltype(auto)


四、模板类型推导模板参数 T 的推导规则与 auto 类似，分三类场景，需处理特殊类型（数组 &#x2F; 函数名）。
1. 按值传递（模板参数为 T）
规则：忽略实参的顶层 const 和引用，保留底层 const。
示例：template&lt;typename T&gt; void func(T x);
const int a=10; func(a);（T 为 int）；int&amp; b=x; func(b);（T 为 int）；const int* c=&amp;a; func(c);（T 为const int*）。





2. 按引用传递（模板参数为 T&amp;）
规则：保留实参的 const 和引用，T 推导为 “实参去掉引用后的类型”。
示例：template&lt;typename T&gt; void func(T&amp; x);
int a=10; func(a);（T 为 int，x 为int&amp;）；const int b=20; func(b);（T 为const int，x 为const int&amp;）。


限制：不能传递字面量（非 const 引用无法绑定右值）。



3. 万能引用（模板参数为 T&amp;&amp;）
场景：适配左值 &#x2F; 右值实参，依赖引用折叠规则推导。
引用折叠规则：T&amp;+&amp;→T&amp;、T&amp;+&amp;&amp;→T&amp;、T&amp;&amp;+&amp;&amp;→T&amp;&amp;。
推导示例：template&lt;typename T&gt; void func(T&amp;&amp; x);
传递左值：int a=10; func(a);（T 为int&amp;，x 为int&amp;）。
传递右值：func(20);（T 为 int，x 为int&amp;&amp;）。


完美转发：用std::forward&lt;T&gt;(x)保持实参原始值类别，避免拷贝。
示例：template&lt;typename T&gt; void wrapper(T&amp;&amp; x) { target_func(std::forward&lt;T&gt;(x)); }。



4. 数组与函数名的特殊推导
数组推导：
按值传递：数组名转为指针，T 为指针类型（如int arr[5]; func(arr);，T 为int*）。
按引用传递：保留数组类型，T 为元素类型（如template&lt;typename T, size_t N&gt; void func(T(&amp;x)[N]);，T 为 int，N 为 5）。


函数名推导：
按值传递：函数名转为指针，T 为函数指针类型（如void add(int,int); func(add);，T 为void(*)(int,int)）。
按引用传递：保留函数类型，T 为函数签名类型（如func(add);，T 为void(int,int)，x 为void(&amp;)(int,int)）。



五、进阶场景：decltype (auto) 与 auto&amp;&amp;1. decltype (auto)：精确推导的简化写法
逻辑：用 auto 的简洁语法，按 decltype 规则推导（保留 const、引用、值类别）。
适用场景：函数返回值推导，尤其需保留引用时。
示例：decltype(auto) get_ref(int&amp; x) { return x; }（返回int&amp;）；decltype(auto) get_rval(int x) { return x+1; }（返回 int）。



2. auto&amp;&amp;：多值类别适配工具
逻辑：非模板场景的 “万能引用”，依赖引用折叠适配左值 &#x2F; 右值。
适用场景：局部变量接收表达式结果、范围 for 循环（避免拷贝）。
示例：int x=10; auto&amp;&amp; a=x;（a 为int&amp;）；auto&amp;&amp; b=20;（b 为int&amp;&amp;）；for(auto&amp;&amp; val : container)。



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型推导</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C++特性：结构化绑定</title>
    <url>/posts/53866983.html</url>
    <content><![CDATA[核心要点速览
适用类型：public 成员的结构体 &#x2F; 类、pair&#x2F;tuple、固定大小数组 &#x2F;std::array、自定义适配类型
优势：语法简洁、支持 const &#x2F; 引用绑定、无需提前声明变量
补充：std::tie对比、生命周期问题、非适用场景、底层依赖


一、语法格式：auto [变量1, 变量2, ...] = 复合类型;支持修饰符：const auto&amp;（只读无拷贝）、auto&amp;（修改原对象）、auto&amp;&amp;（C++20 右值绑定）
示例// 1. 结构体/类（public成员）struct Point &#123; int x; int y; &#125;;Point p = &#123;1, 2&#125;;auto [a, b] = p; // 值拷贝绑定// 2. pair/tuplestd::pair&lt;int, std::string&gt; user = &#123;101, &quot;Alice&quot;&#125;;auto [id, name] = user;// 3. 数组/std::arrayint arr[3] = &#123;10, 20, 30&#125;;auto [x, y, z] = arr; // 严格匹配长度

二、适用类型与非适用场景支持类型（编译期确定成员数 + 可访问）


类型
要求



结构体 &#x2F; 类
非静态成员全 public，顺序固定


pair&#x2F;tuple
标准库已实现适配接口，直接支持


数组 &#x2F;std::array
长度为编译期常量


自定义类型
需实现std::tuple_size、std::tuple_element、std::get三大接口


非适用场景（编译失败情况）
类成员为private/protected（无访问权限）；
动态类型：int*（动态数组）、std::vector（无固定长度）；
变量数量与成员数不匹配（多 &#x2F; 少均报错）。

三、与 std::tie 的区别


特性
结构化绑定
std::tie



语法简洁性
无需提前声明变量（简洁）
需先声明变量（繁琐）


变量修饰
支持 const&#x2F;&amp;&#x2F;&amp;&amp;
仅支持可修改左值


忽略成员
需用std::ignore占位
天然支持std::ignore


适用场景
一次性使用、避免拷贝
变量复用、部分绑定


示例对比std::pair&lt;int, std::string&gt; getData() &#123; return &#123;100, &quot;success&quot;&#125;; &#125;// 结构化绑定（推荐）auto [_, msg] = getData(); // 忽略第一个成员// std::tie（繁琐）int tmp_id;std::string tmp_msg;std::tie(tmp_id, tmp_msg) = getData();

四、易错
悬垂引用风险：不要绑定临时对象（原对象销毁后引用失效）

Point getPoint() &#123; return &#123;1,2&#125;; &#125;// auto&amp; [a, b] = getPoint(); // 错误：临时对象生命周期结束Point p = &#123;1,2&#125;;auto&amp; [a, b] = p; // 正确：绑定左值，修改a即修改p.x


只读无拷贝绑定：只读场景用const auto&amp;，避免大对象拷贝

std::map&lt;int, std::string&gt; m = &#123;&#123;1, &quot;a&quot;&#125;, &#123;2, &quot;b&quot;&#125;&#125;;for (const auto&amp; [key, value] : m) &#123; /* 无拷贝开销 */ &#125;


不支持 getter 方法：直接访问成员，不调用类的 getter&#x2F;setter。

五、底层依赖结构化绑定本质是 “成员别名”，底层依赖 3 个接口（编译器自动为标准类型生成）：

std::tuple_size&lt;T&gt;：获取成员数量（编译期常量）；
std::tuple_element&lt;I, T&gt;：获取第 I 个成员类型；
std::get&lt;I&gt;(T&amp;)：访问第 I 个成员（返回引用）。

自定义类型支持需手动实现上述 3 个接口，示例：
class MyData &#123; public: int a; double b; &#125;;// 1. 特化tuple_size（成员数2）namespace std &#123;template&lt;&gt; struct tuple_size&lt;MyData&gt; : integral_constant&lt;size_t, 2&gt; &#123;&#125;;template&lt;&gt; struct tuple_element&lt;0, MyData&gt; &#123; using type = int; &#125;;template&lt;&gt; struct tuple_element&lt;1, MyData&gt; &#123; using type = double; &#125;;&#125;// 2. 实现全局get函数int&amp; get&lt;0&gt;(MyData&amp; d) &#123; return d.a; &#125;double&amp; get&lt;1&gt;(MyData&amp; d) &#123; return d.b; &#125;

六、实用技巧与 C++20 扩展
忽略成员：用std::ignore占位（如auto [id, _, age] = user;）；
C++20 扩展：支持constexpr编译期绑定、auto&amp;&amp;右值绑定（避免临时对象拷贝）、std::span（固定大小视图绑定）。

问答1. 结构化绑定支持 &#x2F; 不支持哪些类型？原因？
支持：public 成员的结构体 &#x2F; 类（成员顺序固定）、pair&#x2F;tuple（标准库适配）、固定大小数组 &#x2F;std::array（编译期长度）、自定义适配类型（实现三大接口）；
不支持：private&#x2F;protected 成员类（无访问权限）、动态类型（int*&#x2F;vector，无固定成员数）、变量数与成员数不匹配（编译器无法绑定）；
原因：结构化绑定要求 “编译期确定成员数量 + 成员可直接访问”。

2. 与 std::tie 的区别？
语法：结构化绑定无需提前声明变量，更简洁；std::tie 需先声明变量，较繁琐；
修饰符：结构化绑定支持 const&#x2F;&amp;&#x2F;&amp;&amp;，灵活控制权限；std::tie 仅支持可修改左值；
场景：结构化绑定适合一次性使用、避免拷贝；std::tie 适合变量复用、部分绑定。

3. auto&amp; [a,b] = getPoint()为何危险？
getPoint()返回临时对象，生命周期仅在当前语句结束前。auto&amp;绑定后，临时对象销毁，a、b 成为悬垂引用，后续访问会触发未定义行为（UB）。正确做法是绑定左值对象（如先定义 Point p&#x3D;getPoint ()，再绑定 p）。

4. C++20 对结构化绑定的扩展？
支持constexpr：编译期完成绑定（如 constexpr auto [x,y] &#x3D; getConstPair ()），无运行时开销；
支持auto&amp;&amp;：绑定右值临时对象，延长其生命周期，避免拷贝；
支持std::span（固定大小）：绑定非拥有式视图的元素（如 std::span&lt;const int,3&gt; span&#x3D;{1,2,3}，可直接绑定元素）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>结构化绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>文件IO：文件流</title>
    <url>/posts/e5197e53.html</url>
    <content><![CDATA[核心要点速览
本质区别：文本基于字符编码（含格式 &#x2F; 编码转换），二进制基于原始字节流（无任何转换）；
差异：可读性（文本可读 &#x2F; 二进制不可读）、效率（二进制 &gt; 文本）、适用场景（文本→日志 &#x2F; 配置，二进制→图片 &#x2F; 结构体）；
操作：文本用&gt;&gt;&#x2F;&lt;&lt;&#x2F;getline()，二进制用read()&#x2F;write()+ios::binary；
补充：本质区别对比、结构体二进制读写禁忌、场景选择依据、跨平台兼容原理。


一、本质区别：从存储到操作的差异文本处理和二进制处理的所有差异，根源在于数据存储形式和读写时是否进行转换



对比维度
文本处理（Text Mode）
二进制处理（Binary Mode）



存储形式
以字符编码（ASCII&#x2F;UTF-8 等）存储，数据需转换为字符编码（如int 123→字符串 “123”）
以原始二进制存储，直接复刻内存字节布局（如int 123→0x7B 0x00 0x00 0x00）


读写转换
自动处理换行符（Windows：\n→\r\n；Linux：不转换），支持编码互转
无任何转换，字节数据原样读写（\n&#x3D;0x0A，\r&#x3D;0x0D）


人类可读性
可直接用记事本打开阅读（日志、ini 配置等）
打开为乱码，需程序解析（图片、结构体数据等）


处理效率
需编码 &#x2F; 解码 + 格式转换，效率较低
直接操作内存字节，无额外开销，效率极高


数据完整性
适合无结构 &#x2F; 弱结构化数据，解析依赖分隔符（空格、换行）
适合结构化数据，完整性依赖字节对齐、类型长度规范


跨平台兼容性
换行符转换可能导致兼容问题，编码统一（UTF-8）后适配较好
需处理字节对齐、字节序、类型长度差异，否则解析错位



二、原理：两种模式的设计逻辑1. 文本处理：为 “人类可读” 设计
目标：适配人类阅读 &#x2F; 编辑习惯，支持跨平台文本共享；
特性：字符编码映射（数据→字符）、自动换行符适配、按字符 &#x2F; 单词 &#x2F; 行读写，贴合人类操作逻辑。

2. 二进制处理：为 “高效存储 + 机器解析” 设计
目标：最大化效率与数据准确性，适配机器间传输 &#x2F; 存储；
特性：字节级复刻内存布局、无任何额外转换、支持结构化数据批量读写，解析速度极快。


三、操作实践：函数与示例1. 文本处理：操作与注意事项函数
写入：&lt;&lt;（格式化输出）、put()（单个字符）、endl（换行 + 刷新）；
读取：&gt;&gt;（按空白分割）、getline()（读整行）、get()（读单个字符）。

示例：读写文本日志// 写入ofstream log(&quot;log.txt&quot;, ios::app);if (!log.is_open()) return -1;log &lt;&lt; &quot;[&quot; &lt;&lt; __TIME__ &lt;&lt; &quot;] 操作成功&quot; &lt;&lt; endl;log.close();// 读取ifstream ifs(&quot;log.txt&quot;);string line;while (getline(ifs, line)) cout &lt;&lt; line &lt;&lt; endl;ifs.close();

注意事项
&gt;&gt;与getline()混用：&gt;&gt;残留换行符，需用ifs.ignore(numeric_limits&lt;streamsize&gt;::max(), &#39;\n&#39;)清除；
编码一致性：中文需统一编码（如 UTF-8），避免乱码。

2. 二进制处理：操作与注意事项函数
写入：write(const char* buf, streamsize n)（强转char*）；
读取：read(char* buf, streamsize n)；
模式要求：必须显式指定ios::binary。

示例：读写结构体#pragma pack(1) // 关闭字节对齐struct User &#123; int32_t id; char name[20]; double score; &#125;;#pragma pack()// 写入ofstream ofs(&quot;users.bin&quot;, ios::out | ios::binary);User u = &#123;101, &quot;Alice&quot;, 95.5&#125;;ofs.write(reinterpret_cast&lt;const char*&gt;(&amp;u), sizeof(u));ofs.close();// 读取ifstream ifs(&quot;users.bin&quot;, ios::in | ios::binary);User u2;ifs.read(reinterpret_cast&lt;char*&gt;(&amp;u2), sizeof(u2));if (ifs.good()) cout &lt;&lt; u2.id &lt;&lt; &quot; &quot; &lt;&lt; u2.name &lt;&lt; &quot; &quot; &lt;&lt; u2.score &lt;&lt; endl;ifs.close();

注意事项
字节对齐：#pragma pack(1)强制紧凑存储，避免编译器填充空白字节；
禁用动态类型：string&#x2F;vector含指针，需用固定长度数组；
字节序：跨平台用htonl()&#x2F;ntohl()转换为网络字节序（大端）。


四、场景决策：如何选择处理模式？1. 优先选文本模式
需人类查看 &#x2F; 编辑：日志、配置文件（.ini）、CSV 表格；
数据无复杂结构，需跨程序共享（如 Excel 读取 CSV）。

2. 优先选二进制模式
结构化数据：结构体、数组；
非文本文件：图片（.jpg）、音频（.mp3）、视频（.mp4）；
追求极致效率：大文件传输、高频读写（如数据库存储）；
加密 &#x2F; 隐私数据：避免编码转换导致密文失真。

3. 禁忌场景
文本模式不读写结构体 &#x2F; 非文本文件（易失真）；
二进制模式不存储需编辑内容（如配置文件）；
二进制不读写含动态内存的类型（如string）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>文件流</tag>
        <tag>文件IO</tag>
      </tags>
  </entry>
  <entry>
    <title>文件IO：二进制与文本处理</title>
    <url>/posts/3931e70b.html</url>
    <content><![CDATA[核心要点速览
区别：文本处理基于字符编码（有格式转换），二进制处理基于原始字节流（无转换）。
差异：文本可人类直接阅读，二进制不可；文本有换行符 &#x2F; 编码转换，二进制无；文本适合日志 &#x2F; 配置，二进制适合图片 &#x2F; 结构体。
操作：文本用&gt;&gt;&#x2F;&lt;&lt;&#x2F;getline()，二进制用read()&#x2F;write()+ios::binary。


一、区别


维度
文本处理（Text Mode）
二进制处理（Binary Mode）



存储形式
字符编码（如 ASCII、UTF-8），每个字符对应编码值。
数据原始二进制（如 int 的 4 字节、结构体的连续字节）。


格式转换
自动处理换行符（Windows：\n→\r\n；Linux：不转换），部分编码可能转换（如宽字符）。
无任何转换，字节数据原样读写（\n就是 0x0A，\r就是 0x0D）。


可读性
人类可直接阅读（如记事本打开txt文件）。
人类不可读（打开为乱码，需程序解析）。


效率
读写需编码 &#x2F; 解码，效率较低。
直接操作字节流，效率高（无额外处理）。


适用场景
日志文件、配置文件（.ini）、文本数据（如csv）。
图像 &#x2F; 音频（.jpg&#x2F;.mp3）、结构体、加密数据、大文件。


二、文本处理：基于字符的读写文本处理的核心是 “按字符或行操作”，依赖流的格式化输入输出，自动处理字符编码和换行符。
1. 操作函数
写入：&lt;&lt;（插入运算符，输出数据）、put()（单个字符）、endl（换行 + 刷新）。
读取：&gt;&gt;（提取运算符，按空白分割）、getline()（读取一行，含空格）、get()（单个字符，含空格 &#x2F; 换行）。

2. 典型示例与易错示例：读写文本日志
// 写入ofstream log(&quot;log.txt&quot;, ios::app); // 追加模式log &lt;&lt; &quot;[&quot; &lt;&lt; __TIME__ &lt;&lt; &quot;] 操作成功&quot; &lt;&lt; endl; // 自动换行+刷新// 读取ifstream ifs(&quot;log.txt&quot;);string line;while (getline(ifs, line)) &#123; // 逐行读，保留空格    cout &lt;&lt; line &lt;&lt; endl;&#125;

易错：

&gt;&gt;与getline()混用：&gt;&gt;读取后会残留换行符在缓冲区，导致getline()直接读空行。解决：用ignore()清除：

int num;ifs &gt;&gt; num; ifs.ignore(numeric_limits&lt;streamsize&gt;::max(), &#x27;\n&#x27;); // 清除到换行符getline(ifs, line); // 正常读取


换行符跨平台问题：Windows 文本在 Linux 下用cat查看可能显示^M（未转换的\r），需用文本模式读写避免。

三、二进制处理：基于字节的读写二进制处理的核心是 “按原始字节操作”，需显式指定ios::binary模式，直接读写内存中的二进制数据。
1. 操作函数
写入：write(const char* buf, streamsize n)：将内存中n字节数据写入文件（需强转为char*）。
读取：read(char* buf, streamsize n)：从文件读取n字节到内存缓冲区。

2. 典型示例与注意事项示例：读写结构体（二进制）
#pragma pack(1) // 关闭字节对齐（跨平台必备）struct User &#123;    int id;    char name[20]; // 用固定数组，避免string动态内存    double score;&#125;;#pragma pack()// 写入ofstream ofs(&quot;users.bin&quot;, ios::out | ios::binary);User u = &#123;101, &quot;Alice&quot;, 95.5&#125;;ofs.write(reinterpret_cast&lt;const char*&gt;(&amp;u), sizeof(u)); // 写入整个结构体字节// 读取ifstream ifs(&quot;users.bin&quot;, ios::in | ios::binary);User u2;ifs.read(reinterpret_cast&lt;char*&gt;(&amp;u2), sizeof(u2));if (ifs.good()) &#123; // 检查读取成功    cout &lt;&lt; u2.id &lt;&lt; &quot; &quot; &lt;&lt; u2.name &lt;&lt; &quot; &quot; &lt;&lt; u2.score &lt;&lt; endl;&#125;

注意事项：

字节对齐：结构体默认按编译器规则对齐（如int占 4 字节，double占 8 字节），不同平台对齐方式不同，会导致读写错位。必须用#pragma pack(n)强制对齐（n=1为紧凑模式）。
避免string：string内部含指针（指向堆内存），二进制写入会存储指针地址而非字符串内容，读取后指针无效（野指针），必须用char数组。
字节序：跨平台（如 x86 是小端，ARM 可能大端）时，整数 &#x2F; 浮点数的字节顺序可能不同，需统一字节序（如用htonl&#x2F;ntohl转换为网络字节序）。

四、问答1. 二进制读写结构体时，为什么string会出问题？string是动态容器，存储的是指向堆中字符的指针，而非字符本身。二进制写入时会存储指针地址，读取后指针指向无效内存（野指针），导致数据错乱。
2. 为什么二进制处理效率比文本高？文本处理需将数据与字符编码互转（如int 123→字符串 “123”），还需处理换行符；二进制直接读写内存原始字节，无额外转换，效率更高。
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>文件IO</tag>
        <tag>二进制</tag>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件IO：文件操作</title>
    <url>/posts/95495db.html</url>
    <content><![CDATA[核心要点速览
文本文件：&gt;&gt;&#x2F;&lt;&lt;、getline()读写，自动转换换行符，适配人类可读数据（日志、配置）。
二进制文件：read()&#x2F;write()操作原始字节流，适配非文本数据（图片、结构体），效率更高。
文件指针：seekg()&#x2F;seekp()定位、tellg()&#x2F;tellp()获取位置，支持随机访问。
关键：模式区分、读写混用问题、字节对齐、缓冲区刷新、跨平台兼容核心点。


一、文本文件：读写逻辑与易错文本文件以字符编码（ASCII&#x2F;UTF-8）存储，读写时自动处理换行符转换（如 Windows 下\n→\r\n），核心关注 “读写一致性” 与 “缓冲区问题”。
1. 读写方法（1）写入操作（ofstream）ofstream ofs(&quot;text.txt&quot;, ios::out | ios::app); // 追加模式if (!ofs) return -1; // 检查打开失败ofs &lt;&lt; &quot;姓名：Tom&quot; &lt;&lt; endl; // endl=换行+刷新缓冲区ofs.put(&#x27;!&#x27;); // 写入单个字符ofs.close(); // 显式关闭，确保数据落盘

（2）读取操作（ifstream）ifstream ifs(&quot;text.txt&quot;);if (!ifs) return -1;// 方式1：getline()读整行（保留空格，丢弃换行符）string line;while (getline(ifs, line)) &#123;    cout &lt;&lt; line &lt;&lt; endl;&#125;// 方式2：&gt;&gt;按空白分割读（跳过空格/换行）string name;int age;ifs &gt;&gt; name &gt;&gt; age;ifs.close();

2. 易错（1）getline()与&gt;&gt;混用陷阱&gt;&gt;读取后缓冲区残留换行符，导致getline()直接读空行：
int num;string line;ifs &gt;&gt; num; // 读入数字后，缓冲区剩&quot;\n&quot;ifs.ignore(); // 清除残留换行符（简单场景）// 通用解法：清除到换行符为止，避免多字符残留ifs.ignore(numeric_limits&lt;streamsize&gt;::max(), &#x27;\n&#x27;);getline(ifs, line); // 正常读取下一行

（2）缓冲区未刷新导致数据丢失// 错误：仅换行不刷新，程序异常退出时数据可能丢失ofs &lt;&lt; &quot;重要数据&quot; &lt;&lt; &#x27;\n&#x27;;// 正确：用endl刷新或手动调用flush()ofs &lt;&lt; &quot;重要数据&quot; &lt;&lt; endl; // ofs.flush(); // 不换行，仅刷新

（3）getline()与get()的换行差异
getline()：读取时自动丢弃换行符，不残留；
get()：读取单个字符（含换行），换行符会留在缓冲区，后续读取需注意。


二、二进制文件：原始字节操作与跨平台二进制文件直接存储原始字节（无编码 &#x2F; 换行转换），适合结构化数据存储，但需额外处理字节对齐、字节序、数据类型长度等差异才能实现跨平台兼容。
1. 读写方法（1）二进制写入（ios::binary必加）// 关闭字节对齐（跨平台读取关键）#pragma pack(1)struct Student &#123;    int32_t id; // 用固定长度类型（int32_t），避免平台长度差异    char name[20]; // 用char数组，避免string动态内存问题&#125;;#pragma pack()ofstream ofs(&quot;data.bin&quot;, ios::out | ios::binary);if (!ofs) return -1;Student s = &#123;1, &quot;Tom&quot;&#125;;// 强转数据地址为char*，写入整个结构体ofs.write(reinterpret_cast&lt;const char*&gt;(&amp;s), sizeof(s));ofs.close();

（2）二进制读取ifstream ifs(&quot;data.bin&quot;, ios::in | ios::binary);if (!ifs) return -1;Student s;ifs.read(reinterpret_cast&lt;char*&gt;(&amp;s), sizeof(s));// 检查读取成功if (ifs.good()) &#123;    cout &lt;&lt; &quot;ID: &quot; &lt;&lt; s.id &lt;&lt; &quot;, Name: &quot; &lt;&lt; s.name &lt;&lt; endl;&#125;ifs.close();

2. 跨平台（1）字节对齐问题
原因：不同编译器默认对齐规则不同（如 GCC 与 MSVC），结构体可能被填充空白字节；
后果：跨平台读取时字节错位（如结构体总长度不一致）；
解决方案：用#pragma pack(1)设置 1 字节对齐（紧凑模式），读写两端需保持一致。

（2）字节序（大小端）问题
原因：多字节数据（int32_t、long等）在不同平台的字节排列顺序不同：
小端（x86 平台）：低位字节存低地址（如 100 存为 0x64 0x00 0x00 0x00）；
大端（部分 ARM 平台、网络字节序）：高位字节存低地址（如 100 存为 0x00 0x00 0x00 0x64）；


后果：直接跨平台读写会导致数据解析错误（如小端写入的 100 大端读取为 1677721600）；
解决方案：统一转为 “网络字节序”（大端）读写，用 htons()&#x2F;htonl()（主机→网络）、ntohs()&#x2F;ntohl()（网络→主机）转换：

// 写入时：主机字节序 → 网络字节序（大端）s.id = htonl(s.id); ofs.write(reinterpret_cast&lt;const char*&gt;(&amp;s), sizeof(s));// 读取时：网络字节序 → 主机字节序ifs.read(reinterpret_cast&lt;char*&gt;(&amp;s), sizeof(s));s.id = ntohl(s.id);

（3）数据类型长度问题
原因：不同平台基础类型长度可能不同（如 32 位系统 long 是 4 字节，64 位系统是 8 字节）；
后果：sizeof(long) 不一致导致读写字节数不匹配，数据错位；
解决方案：用 C++11 固定长度类型（int32_t&#x2F;uint32_t&#x2F;int64_t），避免使用 int&#x2F;long 等平台相关类型。


三、文件指针：随机访问与经典场景1. 主要函数


函数
功能
适用场景



tellg()
获取读指针当前位置（字节偏移量）
记录读取位置、计算文件大小


seekg(pos, mode)
移动读指针，mode：ios::beg（开头）&#x2F;ios::cur（当前）&#x2F;ios::end（结尾）
定位读取位置


tellp()
获取写指针当前位置
记录写入位置


seekp(pos, mode)
移动写指针（参数同seekg）
定位写入位置


2. 常见场景（1）获取文件大小ifstream ifs(&quot;file.txt&quot;, ios::binary); // 二进制模式避免换行符影响ifs.seekg(0, ios::end); // 指针移至文件尾int file_size = ifs.tellg(); // 尾位置 = 文件字节数ifs.seekg(0, ios::beg); // 指针回退至开头，便于后续读取

（2）随机读取指定字节ifs.seekg(100, ios::beg); // 从文件开头偏移100字节char c;ifs.get(c); // 读取第101个字节（偏移从0开始）


四、问答1. 文本文件和二进制文件的区别？
存储：文本存字符编码（人类可读），二进制存原始字节（机器可读）；
转换：文本模式自动转换换行符 &#x2F; 编码，二进制模式无任何转换；
效率：二进制 &gt; 文本；
场景：文本用配置 &#x2F; 日志，二进制用图片 &#x2F; 结构体 &#x2F; 大文件。

2. 二进制读写结构体实现跨平台，需处理哪些问题？需解决 3 个主要问题，避免数据错位：

字节对齐：用#pragma pack(1)统一 1 字节对齐；
字节序：用 htons()&#x2F;htonl() 转换为网络字节序（大端）；
数据类型长度：用固定长度类型（int32_t），替代 int&#x2F;long。

3. fstream中seekg()和seekp()需要分别调用吗？默认情况下，fstream的读写指针是关联的（移动一个会同步影响另一个），但部分编译器实现可能分离；保险起见，若需独立控制读写位置（如边读边写不同区域），建议分别调用。
4. getline()与&gt;&gt;混用的问题及解决方案？
问题：&gt;&gt;读取后缓冲区残留换行符，导致getline()读空行；
解决方案：用ifs.ignore(numeric_limits&lt;streamsize&gt;::max(), &#39;\n&#39;)清除缓冲区残留字符（直到换行符为止）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>文件IO</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[在互联网的一角搭建一个属于自己的天地。
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/comments/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[内容导航选择下方感兴趣的分类，探索相关主题的文章：
]]></content>
  </entry>
  <entry>
    <title>链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/custom.css</url>
    <content><![CDATA[/* 页脚与头图透明 */
#footer {
  background: transparent !important;
}

#page-header {
  background: transparent !important;
}

/* 白天模式遮罩透明 */
#footer::before {
  background: transparent !important;
}

#page-header::before {
  background: transparent !important;
}

/* 夜间模式遮罩透明 */
[data-theme="dark"] #footer::before {
  background: transparent !important;
}

[data-theme="dark"] #page-header::before {
  background: transparent !important;
}

/* 日间模式不生效 */
[data-theme="light"] #site-name,
[data-theme="light"] #site-title,
[data-theme="light"] #site-subtitle,
[data-theme="light"] #post-info {
  animation: none;
}

/* 夜间模式生效 */
[data-theme="dark"] #site-name,
[data-theme="dark"] #site-title {
  animation: light_15px 10s linear infinite;
}

[data-theme="dark"] #site-subtitle {
  animation: light_10px 10s linear infinite;
}

[data-theme="dark"] #post-info {
  animation: light_5px 10s linear infinite;
}

/* 关键帧描述 */
@keyframes light_15px {
  0% {
    text-shadow: #5636ed 0 0 15px;
  }

  12.5% {
    text-shadow: #11ee5e 0 0 15px;
  }

  25% {
    text-shadow: #f14747 0 0 15px;
  }

  37.5% {
    text-shadow: #f1a247 0 0 15px;
  }

  50% {
    text-shadow: #f1ee47 0 0 15px;
  }

  50% {
    text-shadow: #b347f1 0 0 15px;
  }

  62.5% {
    text-shadow: #002afa 0 0 15px;
  }

  75% {
    text-shadow: #ed709b 0 0 15px;
  }

  87.5% {
    text-shadow: #39c5bb 0 0 15px;
  }

  100% {
    text-shadow: #5636ed 0 0 15px;
  }
}

@keyframes light_10px {
  0% {
    text-shadow: #5636ed 0 0 10px;
  }

  12.5% {
    text-shadow: #11ee5e 0 0 10px;
  }

  25% {
    text-shadow: #f14747 0 0 10px;
  }

  37.5% {
    text-shadow: #f1a247 0 0 10px;
  }

  50% {
    text-shadow: #f1ee47 0 0 10px;
  }

  50% {
    text-shadow: #b347f1 0 0 10px;
  }

  62.5% {
    text-shadow: #002afa 0 0 10px;
  }

  75% {
    text-shadow: #ed709b 0 0 10px;
  }

  87.5% {
    text-shadow: #39c5bb 0 0 10px;
  }

  100% {
    text-shadow: #5636ed 0 0 10px;
  }
}

@keyframes light_5px {
  0% {
    text-shadow: #5636ed 0 0 5px;
  }

  12.5% {
    text-shadow: #11ee5e 0 0 5px;
  }

  25% {
    text-shadow: #f14747 0 0 5px;
  }

  37.5% {
    text-shadow: #f1a247 0 0 15px;
  }

  50% {
    text-shadow: #f1ee47 0 0 5px;
  }

  50% {
    text-shadow: #b347f1 0 0 5px;
  }

  62.5% {
    text-shadow: #002afa 0 0 5px;
  }

  75% {
    text-shadow: #ed709b 0 0 5px;
  }

  87.5% {
    text-shadow: #39c5bb 0 0 5px;
  }

  100% {
    text-shadow: #5636ed 0 0 5px;
  }
}

:root {
  --trans-light: rgba(255, 255, 255, 0.88);
  --trans-dark: rgba(25, 25, 25, 0.88);
  --border-style: 1px solid rgb(169, 169, 169);
  --backdrop-filter: blur(5px) saturate(150%);
}

/* 首页文章卡片 */
#recent-posts>.recent-post-item {
  background: var(--trans-light);
  backdrop-filter: var(--backdrop-filter);
  border-radius: 25px;
  border: var(--border-style);
}

/* 首页侧栏卡片 */
#aside-content .card-widget {
  background: var(--trans-light);
  backdrop-filter: var(--backdrop-filter);
  border-radius: 18px;
  border: var(--border-style);
}

/* 文章页、归档页、普通页面 */
div#post,
div#page,
div#archive {
  background: var(--trans-light);
  backdrop-filter: var(--backdrop-filter);
  border: var(--border-style);
  border-radius: 20px;
}

/* 导航栏 */
#page-header.nav-fixed #nav {
  background: rgba(255, 255, 255, 0.75);
  backdrop-filter: var(--backdrop-filter);
}

[data-theme="dark"] #page-header.nav-fixed #nav {
  background: rgba(0, 0, 0, 0.7) !important;
}

/* 夜间模式遮罩 */
[data-theme="dark"] #recent-posts>.recent-post-item,
[data-theme="dark"] #aside-content .card-widget,
[data-theme="dark"] div#post,
[data-theme="dark"] div#archive,
[data-theme="dark"] div#page {
  background: var(--trans-dark);
}


/* 夜间模式页脚页头遮罩透明 */
[data-theme="dark"] #footer::before {
  background: transparent !important;
}

[data-theme="dark"] #page-header::before {
  background: transparent !important;
}

/* 阅读模式 */
.read-mode #aside-content .card-widget {
  background: rgba(158, 204, 171, 0.5) !important;
}

.read-mode div#post {
  background: rgba(158, 204, 171, 0.5) !important;
}

/* 夜间模式下的阅读模式 */
[data-theme="dark"] .read-mode #aside-content .card-widget {
  background: rgba(25, 25, 25, 0.9) !important;
  color: #ffffff;
}

[data-theme="dark"] .read-mode div#post {
  background: rgba(25, 25, 25, 0.9) !important;
  color: #ffffff;
}

/* 雪花特效 */
[data-theme="light"] #snow {
  display: block;
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -2;
}

/* 雪花黑夜模式不显示 */
[data-theme="dark"] #snow {
  display: none;
}

#home_top {
  margin: 1rem auto 0;
  padding: 0px 15px;
  max-width: 1450px;
  width: 100%;
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/snow.js</url>
    <content><![CDATA[if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
    // 移动端不显示
} else {
    // document.write('');

    window && (() => {
        let e = {
            flakeCount: 50, // 雪花数目
            minDist: 150,   // 最小距离
            color: "255, 255, 255", // 雪花颜色
            size: 1.5,  // 雪花大小
            speed: .5,  // 雪花速度
            opacity: .7,    // 雪花透明度
            stepsize: .5    // 步距
        };
        const t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {
            window.setTimeout(e, 1e3 / 60)
        }
            ;
        window.requestAnimationFrame = t;
        const i = document.getElementById("snow"),
            n = i.getContext("2d"),
            o = e.flakeCount;
        let a = -100,
            d = -100,
            s = [];
        i.width = window.innerWidth,
            i.height = window.innerHeight;
        const h = () => {
            n.clearRect(0, 0, i.width, i.height);
            const r = e.minDist;
            for (let t = 0; t < o; t++) {
                let o = s[t];
                const h = a,
                    w = d,
                    m = o.x,
                    c = o.y,
                    p = Math.sqrt((h - m) * (h - m) + (w - c) * (w - c));
                if (p < r) {
                    const e = (h - m) / p,
                        t = (w - c) / p,
                        i = r / (p * p) / 2;
                    o.velX -= i * e,
                        o.velY -= i * t
                } else
                    o.velX *= .98,
                        o.velY < o.speed && o.speed - o.velY > .01 && (o.velY += .01 * (o.speed - o.velY)),
                        o.velX += Math.cos(o.step += .05) * o.stepSize;
                n.fillStyle = "rgba(" + e.color + ", " + o.opacity + ")",
                    o.y += o.velY,
                    o.x += o.velX,
                    (o.y >= i.height || o.y = i.width || o.x  {
                e.x = Math.floor(Math.random() * i.width),
                    e.y = 0,
                    e.size = 3 * Math.random() + 2,
                    e.speed = 1 * Math.random() + .5,
                    e.velY = e.speed,
                    e.velX = 0,
                    e.opacity = .5 * Math.random() + .3
            }
            ;
        document.addEventListener("mousemove", (e => {
            a = e.clientX,
                d = e.clientY
        }
        )),
            window.addEventListener("resize", (() => {
                i.width = window.innerWidth,
                    i.height = window.innerHeight
            }
            )),
            (() => {
                for (let t = 0; t < o; t++) {
                    const t = Math.floor(Math.random() * i.width)
                        , n = Math.floor(Math.random() * i.height)
                        , o = 3 * Math.random() + e.size
                        , a = 1 * Math.random() + e.speed
                        , d = .5 * Math.random() + e.opacity;
                    s.push({
                        speed: a,
                        velX: 0,
                        velY: a,
                        x: t,
                        y: n,
                        size: o,
                        stepSize: Math.random() / 30 * e.stepsize,
                        step: 0,
                        angle: 180,
                        opacity: d
                    })
                }
                h()
            }
            )()
    }
    )();
}]]></content>
  </entry>
</search>
