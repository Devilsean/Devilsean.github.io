<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数基础</title>
      <link href="/posts/1111c3f5.html"/>
      <url>/posts/1111c3f5.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>声明与定义：可多次声明，仅能一次定义；原型需匹配参数类型 &#x2F; 个数（返回类型不影响）</li><li>参数传递：值传递（拷贝，不影响实参）、引用传递（别名，无拷贝）、指针传递（地址，支持 nullptr）</li><li>函数重载：同名 + 参数列表不同（类型 &#x2F; 个数 &#x2F; 顺序），返回类型不参与重载</li><li>内联函数：inline 修饰，建议编译器嵌入调用处（适合短函数，无循环 &#x2F; 递归）</li><li>默认参数：遵循 “靠右原则”，不可跳过右侧参数省略左侧</li><li>返回值：禁止返回局部变量引用；大型对象返回有 RVO&#x2F;NRVO 优化</li></ul><hr><h2 id="一、函数的声明与定义"><a href="#一、函数的声明与定义" class="headerlink" title="一、函数的声明与定义"></a>一、函数的声明与定义</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>声明：告知编译器函数的 “存在及原型”（返回类型、函数名、参数类型 &#x2F; 个数），不包含实现；参数名可选（仅声明时）。<ul><li>用途：解决 “调用在前、定义在后” 的编译错误，如<code>int add(int, int);</code></li></ul></li><li>定义：包含声明 + 函数体（具体实现），编译器会分配内存生成指令。</li></ul><h3 id="关键规则"><a href="#关键规则" class="headerlink" title="关键规则"></a>关键规则</h3><ul><li>单定义原则（ODR）：一个函数可在多个文件中声明，但<strong>仅能在一个文件中定义</strong>（否则链接报错 “重复定义”）。</li><li>原型匹配：声明与定义的参数类型、个数必须一致；返回类型可省略（默认 int，不推荐），但建议显式声明。</li></ul><hr><h2 id="二、参数传递"><a href="#二、参数传递" class="headerlink" title="二、参数传递"></a>二、参数传递</h2><p>参数传递决定函数与实参的交互方式，核心分三类，重点考察适用场景与区别。</p><h3 id="1-值传递"><a href="#1-值传递" class="headerlink" title="1. 值传递"></a>1. 值传递</h3><ul><li><p>核心规则：形参是实参的<strong>拷贝</strong>，函数内修改形参不影响实参。</p></li><li><p>优点：安全（隔离实参）、逻辑简单。</p></li><li><p>缺点：大对象拷贝开销大（如大型结构体、类对象）。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="type">int</span> t=a; a=b; b=t; &#125; <span class="comment">// 仅交换拷贝，实参不变</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">2</span>; <span class="built_in">swap</span>(x,y); <span class="comment">// x=1, y=2（实参未变）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-引用传递（int-）"><a href="#2-引用传递（int-）" class="headerlink" title="2. 引用传递（int&amp;）"></a>2. 引用传递（<code>int&amp;</code>）</h3><ul><li><p>核心规则：形参是实参的<strong>别名</strong>，无拷贝开销；函数内修改形参直接影响实参。</p></li><li><p>优点：效率高（无拷贝）、语法简洁、可修改实参。</p></li><li><p>约束：引用必须绑定实参（不能传字面量，如<code>func(5)</code>报错），绑定后不可更改指向。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123; <span class="type">int</span> t=a; a=b; b=t; &#125;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">2</span>; <span class="built_in">swap</span>(x,y); <span class="comment">// x=2, y=1（实参已交换）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-指针传递（int-）"><a href="#3-指针传递（int-）" class="headerlink" title="3. 指针传递（int*）"></a>3. 指针传递（<code>int*</code>）</h3><ul><li><p>核心规则：形参是实参的<strong>地址拷贝</strong>，通过解引用（<code>*p</code>）间接修改实参。</p></li><li><p>优点：可修改实参，支持传递<code>nullptr</code>（空值语义）。</p></li><li><p>缺点：需显式解引用（易漏写<code>*</code>），可能出现野指针（未初始化指针）。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123; <span class="type">int</span> t=*a; *a=*b; *b=t; &#125;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">2</span>; <span class="built_in">swap</span>(&amp;x,&amp;y); <span class="comment">// x=2, y=1（通过地址修改）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三类传递方式对比表"><a href="#三类传递方式对比表" class="headerlink" title="三类传递方式对比表"></a>三类传递方式对比表</h3><table><thead><tr><th>对比维度</th><th>值传递</th><th>引用传递</th><th>指针传递</th></tr></thead><tbody><tr><td>内存开销</td><td>拷贝实参（大对象开销大）</td><td>无拷贝（仅别名）</td><td>拷贝地址（4&#x2F;8 字节，固定）</td></tr><tr><td>实参修改</td><td>不可修改</td><td>可直接修改</td><td>可修改（需解引用）</td></tr><tr><td>空值传递</td><td>不支持</td><td>不支持（必须绑定对象）</td><td>支持（传<code>nullptr</code>）</td></tr><tr><td>适用场景</td><td>小对象、无需修改实参</td><td>大对象、需修改实参</td><td>需 “空值” 语义的场景</td></tr><tr><td>语法复杂度</td><td>简单（直接传值）</td><td>简洁（传变量名）</td><td>复杂（传地址 + 解引用）</td></tr></tbody></table><hr><h2 id="三、返回值"><a href="#三、返回值" class="headerlink" title="三、返回值"></a>三、返回值</h2><h3 id="1-返回值类型与规则"><a href="#1-返回值类型与规则" class="headerlink" title="1. 返回值类型与规则"></a>1. 返回值类型与规则</h3><ul><li>基本类型（<code>int</code>&#x2F;<code>double</code>等）：直接返回值拷贝，无额外风险。</li><li>自定义类型（类 &#x2F; 结构体）：返回对象副本，编译器可能触发<strong>返回值优化（RVO&#x2F;NRVO）</strong> ，避免临时对象拷贝。</li><li>引用返回（<code>&amp;</code>）：<ul><li><p>优点：无拷贝，效率高（适合大对象）。</p></li><li><p>禁忌：<strong>禁止返回局部变量的引用</strong>（局部变量生命周期随函数结束，引用变为 “悬垂引用”，访问即未定义行为）。</p></li><li><p>示例（错误）：</p><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="type">int</span> x=<span class="number">10</span>; <span class="keyword">return</span> x; &#125; <span class="comment">// x是局部变量，函数结束后销毁</span></span><br><span class="line"><span class="type">int</span>&amp; res = <span class="built_in">func</span>(); <span class="comment">// 悬垂引用，访问res可能崩溃</span></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="2-特殊返回值：void"><a href="#2-特殊返回值：void" class="headerlink" title="2. 特殊返回值：void"></a>2. 特殊返回值：<code>void</code></h3><ul><li>表示 “无返回值”，函数体中可省略<code>return</code>，或用<code>return;</code>提前结束。</li><li>限制：不能定义<code>void</code>类型变量（<code>void x;</code>报错）；可定义<code>void*</code>指针（指向任意类型，需强转后使用）。</li></ul><h3 id="3-返回值优化（RVO-NRVO）"><a href="#3-返回值优化（RVO-NRVO）" class="headerlink" title="3. 返回值优化（RVO&#x2F;NRVO）"></a>3. 返回值优化（RVO&#x2F;NRVO）</h3><ul><li>概念：编译器对 “返回大型对象” 的优化，直接在调用处构造对象，避免函数返回时的临时对象拷贝。</li><li>特点：无需手动修改代码，编译器自动触发（主流编译器均支持），显著提升大型对象返回效率。</li></ul><hr><h2 id="四、函数重载"><a href="#四、函数重载" class="headerlink" title="四、函数重载"></a>四、函数重载</h2><h3 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h3><p>同一作用域中，函数名相同但<strong>参数列表不同</strong>，用于实现 “同一功能的不同参数版本”。</p><h3 id="重载的条件（缺一不可）"><a href="#重载的条件（缺一不可）" class="headerlink" title="重载的条件（缺一不可）"></a>重载的条件（缺一不可）</h3><ol><li>同一作用域（如同一命名空间、同一类）。</li><li>函数名完全相同。</li><li>参数列表不同（满足任一即可）：<ul><li>参数类型不同（如<code>add(int, int)</code> vs <code>add(double, double)</code>）；</li><li>参数个数不同（如<code>add(int)</code> vs <code>add(int, int)</code>）；</li><li>参数顺序不同（如<code>func(int, double)</code> vs <code>func(double, int)</code>）。</li></ul></li><li>补充场景（易忽略）：<ul><li>参数为引用 &#x2F; 指针时，<code>const</code>修饰可形成重载（如<code>func(int&amp;)</code> vs <code>func(const int&amp;)</code>）；</li><li>类的成员函数中，<code>const</code>修饰<code>this</code>指针可形成重载（如<code>void show()</code> vs <code>void show() const</code>）。</li></ul></li></ol><h3 id="重载的排除条件"><a href="#重载的排除条件" class="headerlink" title="重载的排除条件"></a>重载的排除条件</h3><ul><li>返回类型不同不能形成重载（如<code>int add(int)</code> vs <code>double add(int)</code>，编译报错）；</li><li>参数名不同不能形成重载（如<code>add(int a)</code> vs <code>add(int b)</code>，视为同一函数）。</li></ul><h3 id="重载决议（编译器匹配逻辑）"><a href="#重载决议（编译器匹配逻辑）" class="headerlink" title="重载决议（编译器匹配逻辑）"></a>重载决议（编译器匹配逻辑）</h3><p>编译器按 “实参与形参的匹配度” 选择最佳函数，匹配度从高到低：</p><ol><li>精确匹配（类型完全一致，含<code>const</code>匹配）；</li><li>提升转换（如<code>char→int</code>、<code>float→double</code>）；</li><li>标准转换（如<code>int→double</code>、<code>int*→void*</code>）；</li><li>用户定义转换（如类的构造函数、运算符重载）。</li></ol><ul><li>若匹配度相同（歧义），编译报错（需显式类型转换解决）。</li></ul><hr><h2 id="五、内联函数（inline）"><a href="#五、内联函数（inline）" class="headerlink" title="五、内联函数（inline）"></a>五、内联函数（<code>inline</code>）</h2><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li>作用：建议编译器将函数体 “嵌入” 调用处（而非生成函数调用指令），减少栈帧创建 &#x2F; 销毁的开销。</li><li>建议性：<code>inline</code>是编译器 “建议”，非强制 —— 若函数含循环、递归、复杂分支，编译器会忽略<code>inline</code>，按普通函数处理。</li><li>定义即声明：内联函数需在调用前定义（不能仅声明），通常放在头文件中（方便多个编译单元包含）。</li><li>避免重复定义：允许在多个编译单元中定义，但所有定义必须完全一致（否则链接报错）。</li></ul><h3 id="与宏（-define）的区别（面试高频）"><a href="#与宏（-define）的区别（面试高频）" class="headerlink" title="与宏（#define）的区别（面试高频）"></a>与宏（<code>#define</code>）的区别（面试高频）</h3><table><thead><tr><th>对比维度</th><th>内联函数（<code>inline</code>）</th><th>宏（<code>#define</code>）</th></tr></thead><tbody><tr><td>类型检查</td><td>有（编译期校验参数类型）</td><td>无（文本替换，无类型校验）</td></tr><tr><td>调试支持</td><td>支持（可打断点、查看变量）</td><td>不支持（替换后无宏信息）</td></tr><tr><td>复杂逻辑支持</td><td>支持（循环、分支等）</td><td>不适合（易因优先级出错）</td></tr><tr><td>作用域</td><td>受作用域限制（如局部内联）</td><td>全局替换（无作用域）</td></tr><tr><td>副作用风险</td><td>低（参数仅计算一次）</td><td>高（参数可能多次计算）</td></tr></tbody></table><hr><h2 id="六、默认参数"><a href="#六、默认参数" class="headerlink" title="六、默认参数"></a>六、默认参数</h2><h3 id="核心规则"><a href="#核心规则" class="headerlink" title="核心规则"></a>核心规则</h3><ul><li><p>靠右原则：默认参数必须从右往左连续指定，<strong>不能跳过右侧参数省略左侧参数</strong>。</p></li><li><p>示例（正确 vs 错误）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">2</span>, <span class="type">int</span> c=<span class="number">3</span>)</span></span>; <span class="comment">// 正确（从右往左指定）</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>); <span class="comment">// 等价于func(1,2,3)</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="number">4</span>); <span class="comment">// 等价于func(1,4,3)</span></span><br><span class="line"><span class="comment">// func(,4,5); // 错误（跳过左侧a，未指定默认值）</span></span><br></pre></td></tr></table></figure></li><li><p>声明与定义一致性：默认参数仅需在声明或定义中指定一次（建议在声明中指定，方便外部调用者查看）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 2. 函数与指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 函数 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型与变量</title>
      <link href="/posts/52c049c7.html"/>
      <url>/posts/52c049c7.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>数据类型分类：基本类型、复合（派生）类型、自定义类型</li><li>核心复合类型：指针、引用、数组、结构体、联合体、枚举</li><li>变量关键特性：存储类别（auto&#x2F;static&#x2F;extern 等）、初始化要求、作用域与生命周期</li><li>常量核心：const（只读）、constexpr（编译期常量）</li><li>类型转换：隐式转换（编译器自动）、显式转换（四种强制转换）</li></ul><hr><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-1-基本类型"><a href="#1-1-基本类型" class="headerlink" title="1.1 基本类型"></a>1.1 基本类型</h3><p>基本类型是 C++ 内置的基础数据类型，具有固定内存大小（部分受平台影响）和明确取值范围。</p><table><thead><tr><th>类型</th><th>典型大小（32&#x2F;64 位系统）</th><th>含义 &#x2F; 范围</th><th>面试考点</th></tr></thead><tbody><tr><td><code>bool</code></td><td>1 字节</td><td>布尔值：<code>true</code>（1）&#x2F;<code>false</code>（0）</td><td><code>sizeof(bool)</code>恒为 1；不可用 0 &#x2F; 非 0 代替（语法允许但不规范）</td></tr><tr><td><code>char</code></td><td>1 字节</td><td>ASCII 码：-128<del>127 或 0</del>255</td><td>区分<code>signed char</code>（带符号）和<code>unsigned char</code>（无符号）；默认符号性由编译器决定</td></tr><tr><td><code>short</code></td><td>2 字节</td><td>短整数：-32768~32767</td><td>与<code>short int</code>等价；用于节省内存</td></tr><tr><td><code>int</code></td><td>4 字节（通用）</td><td>整数：-2³¹~2³¹-1</td><td>平台无关性（主流编译器统一 4 字节）；计数、返回值首选类型</td></tr><tr><td><code>long</code></td><td>4 字节（32 位）&#x2F;8 字节（64 位）</td><td>长整数：随平台变化</td><td>避免依赖其大小，优先用固定宽度类型（如<code>int64_t</code>）</td></tr><tr><td><code>long long</code></td><td>8 字节</td><td>超长整数：-2⁶³~2⁶³-1</td><td>C++11 标准，跨平台 8 字节，适合大整数</td></tr><tr><td><code>float</code></td><td>4 字节</td><td>单精度浮点：有效数字 6-7 位</td><td>精度低；避免直接比较（存在误差）</td></tr><tr><td><code>double</code></td><td>8 字节</td><td>双精度浮点：有效数字 15-17 位</td><td>默认浮点类型（如<code>3.14</code>是 double）；科学计算首选</td></tr><tr><td><code>void</code></td><td>无大小</td><td>无类型（表示 “空”）</td><td>用于无返回值函数、<code>void*</code>指针（可指向任意类型）</td></tr></tbody></table><h4 id="关键补充"><a href="#关键补充" class="headerlink" title="关键补充"></a>关键补充</h4><ul><li>跨平台一致性保证：使用 C++11 固定宽度类型（定义于<code>&lt;cstdint&gt;</code>），如<code>int32_t</code>（32 位带符号）、<code>uint64_t</code>（64 位无符号）。</li><li><code>sizeof</code>计算规则：<code>sizeof(char)</code>恒为 1；<code>sizeof(int)</code>通常 4 字节；<code>sizeof(void)</code>编译报错；<code>sizeof(bool)</code>始终为 1。</li></ul><h3 id="1-2-复合类型（派生类型）"><a href="#1-2-复合类型（派生类型）" class="headerlink" title="1.2 复合类型（派生类型）"></a>1.2 复合类型（派生类型）</h3><p>基于基本类型或自定义类型扩展，核心用于组合、关联或间接访问数据。</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li>存储目标变量的内存地址，大小仅与系统位数相关（32 位 4 字节，64 位 8 字节，与指向类型无关）。</li><li>核心特性：<ol><li>未初始化指针为<strong>野指针</strong>（指向随机地址，操作易崩溃），需避免。</li><li><code>nullptr</code>（C++11）：空指针常量，替代<code>NULL</code>（<code>NULL</code>本质是 0，易引发歧义）。</li><li>指针运算：仅对数组指针有效（<code>p++</code>步长为指向类型的大小）。</li><li>数组名本质：指向数组首元素的常量指针（不可修改指向）。</li></ol></li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>变量的 “别名”，语法：<code>类型&amp; 引用名 = 变量名</code>，必须初始化且绑定后不可更改。</li></ul><table><thead><tr><th>对比项</th><th>指针</th><th>引用</th></tr></thead><tbody><tr><td>定义</td><td>可空（<code>nullptr</code>）</td><td>不可空（必须绑定变量）</td></tr><tr><td>指向修改</td><td>可重新指向其他变量</td><td>绑定后不可更改</td></tr><tr><td>初始化</td><td>可延迟初始化（风险高）</td><td>必须定义时初始化</td></tr><tr><td>内存占用</td><td>占内存（存储地址）</td><td>不占额外内存（编译器优化）</td></tr><tr><td>核心用途</td><td>动态内存管理、多级间接访问</td><td>函数参数 &#x2F; 返回值（避免拷贝）、简化代码</td></tr></tbody></table><h4 id="结构体（Struct）"><a href="#结构体（Struct）" class="headerlink" title="结构体（Struct）"></a>结构体（Struct）</h4><ul><li>组合多个不同类型数据（成员）为一个整体，成员按顺序占用独立内存。</li><li>核心特性：结构体大小 &#x3D; 成员大小之和 + 内存对齐填充字节。</li><li>用途：存储关联数据（如个人信息：姓名、年龄、身高）。</li></ul><h4 id="联合体（Union）"><a href="#联合体（Union）" class="headerlink" title="联合体（Union）"></a>联合体（Union）</h4><ul><li>所有成员共享同一块内存，同一时间仅能有效使用一个成员。</li></ul><table><thead><tr><th>对比项</th><th>结构体（Struct）</th><th>联合体（Union）</th></tr></thead><tbody><tr><td>内存分配</td><td>成员独立占用内存，总大小 &#x3D; 成员和 + 填充</td><td>成员共享内存，总大小 &#x3D; 最大成员大小（+ 对齐填充）</td></tr><tr><td>成员关系</td><td>成员并存（可同时访问）</td><td>成员互斥（同一时间仅能用一个）</td></tr><tr><td>核心用途</td><td>组合关联数据</td><td>节省内存、实现类型转换</td></tr></tbody></table><h4 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h4><ul><li>自定义整数类型，用于组合含义相关的命名常量。</li><li>分类：<ol><li>传统枚举：<code>enum E {A, B=5, C};</code>，成员作用域全局（易冲突），可隐式转 int。</li><li>强类型枚举（C++11 推荐）：<code>enum class E {A, B};</code>，作用域受限（需<code>E::A</code>访问），不可隐式转 int（更安全）。</li></ol></li><li>赋值规则：未手动赋值时，首个常量为 0，后续依次 + 1；中间赋值后，后续常量基于该值递增。</li></ul><h3 id="1-3-自定义类型"><a href="#1-3-自定义类型" class="headerlink" title="1.3 自定义类型"></a>1.3 自定义类型</h3><ul><li>由用户通过<code>class</code>（类）、<code>struct</code>（结构体）、<code>enum</code>（枚举）等关键字定义的类型。</li><li>核心作用：封装数据与行为，提升代码可读性和复用性。</li></ul><hr><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><h3 id="2-1-变量的定义与初始化"><a href="#2-1-变量的定义与初始化" class="headerlink" title="2.1 变量的定义与初始化"></a>2.1 变量的定义与初始化</h3><ul><li><p>定义：编译器为变量分配内存空间。</p></li><li><p>初始化：定义时赋予初始值（避免 “垃圾值”，提升代码安全性）。</p></li><li><p>常见初始化方式：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;    <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;     <span class="comment">// 直接初始化（适合构造函数场景）</span></span><br><span class="line"><span class="type">int</span> c&#123;<span class="number">30</span>&#125;;     <span class="comment">// 列表初始化（C++11，禁止窄化转换，如int&#123;3.14&#125;编译报错）</span></span><br><span class="line"><span class="type">int</span> d = &#123;<span class="number">40</span>&#125;;  <span class="comment">// 拷贝列表初始化</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-存储类别（关键字修饰）"><a href="#2-2-存储类别（关键字修饰）" class="headerlink" title="2.2 存储类别（关键字修饰）"></a>2.2 存储类别（关键字修饰）</h3><p>存储类别决定变量的生命周期、作用域和存储位置。</p><table><thead><tr><th>关键字</th><th>核心特性与用途</th></tr></thead><tbody><tr><td><code>auto</code>（C++11）</td><td>编译器自动推导类型；不能用于函数参数（模板除外）、数组类型；推导引用需显式加<code>&amp;</code></td></tr><tr><td><code>static</code></td><td>局部静态变量：生命周期为程序全程，首次调用初始化；全局静态变量：仅当前.cpp 可见（避免命名冲突）；类静态成员：属于类，所有对象共享</td></tr><tr><td><code>extern</code></td><td>声明变量 &#x2F; 函数在其他文件定义（跨文件共享）；仅声明不分配内存，带初始化则变为定义</td></tr><tr><td><code>register</code></td><td>提示编译器存于寄存器（C++17 后弃用，现代编译器优化足够）</td></tr><tr><td><code>mutable</code></td><td>仅用于类非静态成员；允许 const 成员函数修改该变量（突破 const 限制）</td></tr><tr><td><code>volatile</code></td><td>禁止编译器优化；变量值可能被外部因素修改（如硬件、多线程），每次访问直接读内存</td></tr></tbody></table><h3 id="2-3-常见问题解答"><a href="#2-3-常见问题解答" class="headerlink" title="2.3 常见问题解答"></a>2.3 常见问题解答</h3><ul><li>局部变量屏蔽全局变量时如何访问全局变量？用<code>::</code>（全局作用域解析符），如<code>::global_var</code>。</li><li>全局变量与局部<code>static</code>变量的初始化顺序？全局变量在<code>main</code>前初始化，局部<code>static</code>变量首次进入函数时初始化（C++11 后线程安全）；销毁顺序与初始化相反。</li><li>未初始化的局部变量和全局变量区别？局部非<code>static</code>变量是 “垃圾值”；全局变量和<code>static</code>变量会零初始化（数值为 0，指针为<code>nullptr</code>）。</li></ul><h3 id="2-4-常量"><a href="#2-4-常量" class="headerlink" title="2.4 常量"></a>2.4 常量</h3><p>常量是初始化后不可修改的变量，核心分为<code>const</code>和<code>constexpr</code>。</p><h4 id="const（只读常量）"><a href="#const（只读常量）" class="headerlink" title="const（只读常量）"></a><code>const</code>（只读常量）</h4><ul><li><p>修饰变量：初始化后不可修改，作用域与变量一致。</p></li><li><p>修饰指针（三大场景）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p;    <span class="comment">// 常量指针：指向的内容不可改（*p不可改），p可改指向</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p;    <span class="comment">// 指针常量：p的指向不可改，*p可改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p;  <span class="comment">// 指向常量的指针常量：内容和指向均不可改</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="constexpr（编译期常量，C-11）"><a href="#constexpr（编译期常量，C-11）" class="headerlink" title="constexpr（编译期常量，C++11）"></a><code>constexpr</code>（编译期常量，C++11）</h4><ul><li>要求表达式在编译期可计算，比<code>const</code>更严格（<code>const</code>可运行期初始化）。</li><li>用途：定义数组大小、模板参数等依赖编译期常量的场景。</li></ul><h3 id="2-5-类型转换"><a href="#2-5-类型转换" class="headerlink" title="2.5 类型转换"></a>2.5 类型转换</h3><h4 id="隐式转换（自动转换）"><a href="#隐式转换（自动转换）" class="headerlink" title="隐式转换（自动转换）"></a>隐式转换（自动转换）</h4><ul><li>遵循 “安全优先” 原则，优先 “小范围→大范围”（类型提升），避免溢出。</li><li>转换顺序：<code>bool</code>→<code>char</code>→<code>short</code>→<code>int</code>→<code>long</code>→<code>long long</code>→<code>float</code>→<code>double</code>→<code>long double</code>。</li><li>注意：<code>explicit</code>关键字可禁止类的隐式类型转换。</li></ul><h4 id="显式转换（四种强制转换）"><a href="#显式转换（四种强制转换）" class="headerlink" title="显式转换（四种强制转换）"></a>显式转换（四种强制转换）</h4><table><thead><tr><th>转换方式</th><th>核心用途</th><th>风险程度</th></tr></thead><tbody><tr><td><code>static_cast</code></td><td>基本类型转换（<code>int→double</code>）、父类 &#x2F; 子类指针转换（无动态检查）</td><td>中等（父类→子类可能越界）</td></tr><tr><td><code>dynamic_cast</code></td><td>多态类型转换（仅用于含虚函数的类），运行期检查有效性</td><td>低（失败返回<code>nullptr</code>&#x2F; 抛异常）</td></tr><tr><td><code>const_cast</code></td><td>移除指针 &#x2F; 引用的<code>const</code>属性</td><td>高（修改原<code>const</code>变量会导致未定义行为）</td></tr><tr><td><code>reinterpret_cast</code></td><td>底层二进制重解释（如<code>int*→char*</code>）</td><td>极高（依赖平台，无移植性）</td></tr></tbody></table><h4 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h4><ul><li>何时用<code>dynamic_cast</code>？多态场景下，需将父类指针安全转为子类指针（需父类有虚函数，运行期校验合法性）。</li><li>为何避免<code>reinterpret_cast</code>？直接操作二进制，忽略类型安全，结果依赖平台，移植性极差。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 1. 基础语法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 变量 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序结构与预处理</title>
      <link href="/posts/43ae7cb1.html"/>
      <url>/posts/43ae7cb1.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>程序入口：main 函数（返回值 int，return 0 表示正常退出）</li><li>核心预处理指令：#include（头文件包含）、#define（宏定义）、条件编译（#ifdef&#x2F;#ifndef&#x2F;endif）、#pragma once（头文件防重复包含）</li><li>核心流程：预处理→编译→汇编→链接→执行</li></ul><hr><h2 id="一、程序结构"><a href="#一、程序结构" class="headerlink" title="一、程序结构"></a>一、程序结构</h2><ul><li>执行流程：预处理→编译→汇编→链接→执行</li><li>预处理是编译的第一个阶段，由预处理器处理所有以 #开头的指令，生成 “预处理后的源代码”</li><li>预处理核心操作：消除注释、展开宏、处理条件编译、引入头文件内容</li></ul><hr><h2 id="二、预处理指令详解"><a href="#二、预处理指令详解" class="headerlink" title="二、预处理指令详解"></a>二、预处理指令详解</h2><h3 id="2-1-include：头文件包含"><a href="#2-1-include：头文件包含" class="headerlink" title="2.1 #include：头文件包含"></a>2.1 #include：头文件包含</h3><ul><li><code>#include &lt;header&gt;</code>：优先搜索<strong>系统标准头文件目录</strong>（如<code>/usr/include</code>），用于引入标准库（如<code>&lt;iostream&gt;</code>、<code>&lt;vector&gt;</code>）</li><li><code>#include &quot;header&quot;</code>：优先搜索<strong>当前源文件所在目录</strong>，再搜索系统目录，用于引入自定义头文件（如<code>&quot;myfunc.h&quot;</code>）</li></ul><h3 id="2-2-define：宏定义"><a href="#2-2-define：宏定义" class="headerlink" title="2.2 #define：宏定义"></a>2.2 #define：宏定义</h3><p>宏定义在预处理阶段执行，本质是 “文本替换”，语法格式为：<code>#define 宏名 替换文本</code></p><h4 id="宏的分类"><a href="#宏的分类" class="headerlink" title="宏的分类"></a>宏的分类</h4><ul><li>常量宏定义：直接进行文本替换（如<code>#define PI 3.14159</code>）</li><li>函数宏定义：带参数的文本替换（如<code>#define MUL(a,b) a*b</code>），非真正函数调用</li><li><code>#undef</code>：用于取消已定义的宏，缩小作用域（如<code>#undef PI</code>）</li></ul><h4 id="宏与相关概念的区别"><a href="#宏与相关概念的区别" class="headerlink" title="宏与相关概念的区别"></a>宏与相关概念的区别</h4><ul><li>与函数的区别：<ul><li>宏：无类型检查、无调用栈开销、可操作类型（如<code>#define SWAP(T,a,b) {T t=a;a=b;b=t;}</code>）</li><li>函数：有类型检查、有调用开销、参数类型固定</li></ul></li><li>与<code>const</code>的区别：<ul><li>宏：无类型、全局替换、不可调试、无作用域限制</li><li><code>const</code>变量：有类型、有作用域、可调试、编译阶段检查</li></ul></li></ul><h4 id="宏定义的优缺点"><a href="#宏定义的优缺点" class="headerlink" title="宏定义的优缺点"></a>宏定义的优缺点</h4><ul><li>优点：<ul><li>提升可读性：为常量或复杂表达式赋予有意义名称</li><li>便于修改：统一更新宏定义，无需逐个替换</li><li>增强可移植性：配合条件编译适配不同平台 &#x2F; 编译器</li></ul></li><li>缺点：<ul><li>无类型检查：仅文本替换，不校验参数类型，易藏错误</li><li>可能代码膨胀：大量使用函数宏会增大目标代码体积</li><li>作用域风险：从定义到文件结束（或<code>#undef</code>），易引发命名冲突</li></ul></li></ul><h3 id="2-3-条件编译"><a href="#2-3-条件编译" class="headerlink" title="2.3 条件编译"></a>2.3 条件编译</h3><p>条件编译在预处理阶段执行，根据条件决定部分代码是否进入编译，核心用于跨平台适配、调试 &#x2F; 发布版本区分、头文件防重复包含。</p><h4 id="核心指令"><a href="#核心指令" class="headerlink" title="核心指令"></a>核心指令</h4><ul><li><code>#ifdef MACRO</code>：若<code>MACRO</code>已定义，则编译后续代码</li><li><code>#ifndef MACRO</code>：若<code>MACRO</code>未定义，则编译后续代码（常用）</li><li><code>#if 表达式</code>：表达式为真则编译（支持<code>defined(MACRO)</code>判断宏是否定义）</li><li><code>#else</code>&#x2F;<code>#elif</code>：分支控制</li><li><code>#endif</code>：结束条件编译块（必须配对）</li><li><code>#error</code>：预处理阶段报错，终止编译（可用于版本 &#x2F; 系统检查）</li><li><code>#pragma pack(n)</code>：设置结构体对齐字节数（面试高频），如<code>#pragma pack(1)</code>强制 1 字节对齐</li></ul><h4 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h4><ul><li>头文件防重复包含：<code>#ifndef HEADER_NAME_H #define HEADER_NAME_H ... #endif</code></li><li>跨平台适配：<code>#if defined(WIN32) ... #elif defined(LINUX) ... #endif</code></li><li>调试模式控制：<code>#ifdef DEBUG printf(&quot;调试信息&quot;); #endif</code></li></ul><h3 id="2-4-pragma-once"><a href="#2-4-pragma-once" class="headerlink" title="2.4 #pragma once"></a>2.4 #pragma once</h3><ul><li>功能：替代<code>#ifndef</code>实现头文件防重复包含</li><li>特点：非 C++ 标准，但几乎所有主流编译器都支持</li><li>优势：语法简洁，无需定义头文件保护宏，预处理效率更高</li></ul><hr><h2 id="三、带参数宏陷阱及解决方案"><a href="#三、带参数宏陷阱及解决方案" class="headerlink" title="三、带参数宏陷阱及解决方案"></a>三、带参数宏陷阱及解决方案</h2><h3 id="3-1-运算符优先级错乱"><a href="#3-1-运算符优先级错乱" class="headerlink" title="3.1 运算符优先级错乱"></a>3.1 运算符优先级错乱</h3><ul><li>问题：宏替换直接插入代码，不自动加括号，运算符优先级冲突导致逻辑错误</li><li>示例：<code>#define MUL(a, b) a * b</code>，调用<code>MUL(2+3, 4)</code>会替换为<code>2+3*4=14</code>（预期 16）</li><li>解决方案：给<strong>每个参数</strong>和<strong>整个替换体</strong>都加括号，如<code>#define MUL(a, b) ((a) * (b))</code></li></ul><h3 id="3-2-参数副作用（多次计算）"><a href="#3-2-参数副作用（多次计算）" class="headerlink" title="3.2 参数副作用（多次计算）"></a>3.2 参数副作用（多次计算）</h3><ul><li>问题：参数为副作用表达式（如<code>i++、x+=1</code>）时，宏替换会让参数多次计算，放大副作用</li><li>示例：<code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</code>，调用<code>MAX(i++, j++)</code>会导致<code>i</code>和<code>j</code>多次自增</li><li>解决方案：<ol><li>避免将带副作用的表达式作为宏参数</li><li>先将参数值存入临时变量，再传入宏（如<code>int a_val = i++; int b_val = j++; MAX(a_val, b_val)</code>）</li></ol></li></ul><h3 id="3-3-重复计算（性能-逻辑风险）"><a href="#3-3-重复计算（性能-逻辑风险）" class="headerlink" title="3.3 重复计算（性能 + 逻辑风险）"></a>3.3 重复计算（性能 + 逻辑风险）</h3><ul><li>问题：参数为复杂表达式（如函数调用、耗时计算）时，宏替换会导致表达式多次执行</li><li>影响：浪费性能，若表达式有状态依赖（如获取系统时间）会引发逻辑错误</li><li>解决方案：<ol><li>避免将复杂表达式直接作为宏参数</li><li>先计算表达式结果存入临时变量，再传入宏</li></ol></li></ul><h3 id="3-4-缺少分号导致逻辑断裂"><a href="#3-4-缺少分号导致逻辑断裂" class="headerlink" title="3.4 缺少分号导致逻辑断裂"></a>3.4 缺少分号导致逻辑断裂</h3><ul><li>问题：多行宏体未用<code>{}</code>包裹，开发者习惯加<code>;</code>会导致语法逻辑破坏</li><li>示例：<code>#define PRINT() printf(&quot;a&quot;); printf(&quot;b&quot;)</code>，在<code>if(1) PRINT(); else ...</code>中会提前结束 if 逻辑</li><li>解决方案：用<code>do{...}while(0)</code>包裹多行宏体，如<code>#define PRINT() do{printf(&quot;a&quot;); printf(&quot;b&quot;);}while(0)</code></li></ul><h3 id="3-5-命名冲突"><a href="#3-5-命名冲突" class="headerlink" title="3.5 命名冲突"></a>3.5 命名冲突</h3><ul><li>问题：宏作用域广（定义到文件结束），无差别替换所有匹配标识符，易与变量 &#x2F; 函数同名冲突</li><li>解决方案：<ol><li>宏名采用 “全大写 + 下划线” 规范（如<code>MAX_VALUE</code>）</li><li>用<code>#undef</code>及时取消无用宏，缩小作用域</li><li>避免使用库函数名、关键字作为宏名</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 1. 基础语法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 程序结构 </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针与引用</title>
      <link href="/posts/eed757dd.html"/>
      <url>/posts/eed757dd.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>指针：存储内存地址的变量，支持空值（nullptr）、动态指向、多级访问，存在野指针风险</li><li>引用：变量的别名，必须初始化、不可改指向、无空引用，语法简洁安全</li><li>访问效率：两者基本一致</li><li>适用场景：需空值 &#x2F; 动态指向 &#x2F; 多级访问用指针；需简洁语法 &#x2F; 确保有效 &#x2F; 避免误操作引用</li></ul><hr><h2 id="一、指针"><a href="#一、指针" class="headerlink" title="一、指针"></a>一、指针</h2><p>指针本质是 “存储内存地址的变量”，支持对内存的间接访问。</p><h3 id="1-关键类型与特性"><a href="#1-关键类型与特性" class="headerlink" title="1. 关键类型与特性"></a>1. 关键类型与特性</h3><h4 id="（1）野指针"><a href="#（1）野指针" class="headerlink" title="（1）野指针"></a>（1）野指针</h4><ul><li><p>定义：未初始化、已释放或越界访问的指针（指向随机 &#x2F; 无效内存）。</p></li><li><p>风险：访问野指针会导致内存错误（崩溃、数据错乱），是常见 bug 来源。</p></li><li><p>示例（错误）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p; <span class="comment">// 未初始化，野指针</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// 未定义行为（访问随机内存）</span></span><br></pre></td></tr></table></figure></li><li><p>规避：指针定义时立即初始化（如<code>int* p = nullptr;</code>），释放后及时置空（<code>p = nullptr;</code>）。</p></li></ul><h4 id="（2）空指针（nullptr）"><a href="#（2）空指针（nullptr）" class="headerlink" title="（2）空指针（nullptr）"></a>（2）空指针（nullptr）</h4><ul><li><p>定义：C++11 标准的空指针常量，替代旧版<code>NULL</code>（<code>NULL</code>本质是<code>0</code>，易引发歧义）。</p></li><li><p>用途：表示指针 “无指向”，避免野指针，可通过条件判断安全使用。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123; <span class="comment">// 安全判断空指针</span></span><br><span class="line">    <span class="comment">// 避免无效访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）函数指针"><a href="#（3）函数指针" class="headerlink" title="（3）函数指针"></a>（3）函数指针</h4><ul><li><p>定义：指向函数的指针，语法：<code>返回类型 (*指针名)(参数类型列表)</code>。</p></li><li><p>核心用途：作为函数参数 &#x2F; 返回值，实现回调函数（如排序算法中的比较器）。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标函数：两数相加</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>) = add; <span class="comment">// 函数指针指向add</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">func_ptr</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 调用：res=8（等价于(*func_ptr)(3,5)）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）指针数组与数组指针（面试必考区分）"><a href="#（4）指针数组与数组指针（面试必考区分）" class="headerlink" title="（4）指针数组与数组指针（面试必考区分）"></a>（4）指针数组与数组指针（面试必考区分）</h4><p>核心原则：<code>[]</code>优先级高于<code>*</code>，<code>()</code>可提升<code>*</code>的优先级，需通过语法结构判断本质。</p><table><thead><tr><th>类型</th><th>语法格式</th><th>核心逻辑（优先级分析）</th><th>示例</th></tr></thead><tbody><tr><td>指针数组</td><td><code>类型* 数组名[数组长度];</code></td><td><code>[]</code>优先级高，先构成数组，元素是指针</td><td><code>int* arr[3];</code>（3 个 int * 指针的数组）</td></tr><tr><td>数组指针</td><td><code>类型 (*指针名)[数组长度];</code></td><td><code>()</code>提升<code>*</code>优先级，先是指针，指向 “固定长度的数组”</td><td><code>int (*p)[3];</code>（指向含 3 个 int 的数组）</td></tr></tbody></table><ul><li><p>示例解析：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>* arr[<span class="number">3</span>]; <span class="comment">// 指针数组：每个元素是int*，可指向不同int变量</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>] = &amp;a; <span class="comment">// 数组指针：p指向整个数组a，*p等价于a（数组首地址）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-指针的核心操作"><a href="#2-指针的核心操作" class="headerlink" title="2. 指针的核心操作"></a>2. 指针的核心操作</h3><ul><li>解引用：<code>*p</code>，访问指针指向的变量值。</li><li>取地址：<code>&amp;变量</code>，获取变量的内存地址，赋值给指针。</li><li>算术运算：仅对 “指向数组的指针” 有意义，步长 &#x3D; 指向类型的大小（如<code>int* p</code>，<code>p++</code>移动 4 字节）。</li></ul><hr><h2 id="二、引用"><a href="#二、引用" class="headerlink" title="二、引用"></a>二、引用</h2><p>引用本质是 “变量的别名”，语法上无独立内存（编译器通常用指针实现，但对外隐藏细节），核心优势是简洁安全。</p><h3 id="1-核心特性"><a href="#1-核心特性" class="headerlink" title="1. 核心特性"></a>1. 核心特性</h3><ol><li><p>必须初始化：定义时必须绑定已存在的变量（无空引用），否则编译报错。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = a; <span class="comment">// 正确：绑定变量a</span></span><br><span class="line"><span class="comment">// int&amp; r; // 错误：未初始化</span></span><br><span class="line"><span class="comment">// int&amp; r = nullptr; // 错误：无空引用</span></span><br></pre></td></tr></table></figure></li><li><p>不可改指向：绑定后无法切换到其他变量，赋值操作是修改 “绑定变量的值”。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">r = b; <span class="comment">// 不是更改绑定，而是将a的值改为20（a=20，r仍绑定a）</span></span><br></pre></td></tr></table></figure></li><li><p>内存特性：<code>sizeof(r) = sizeof(原变量)</code>（无额外内存开销）。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(r); <span class="comment">// 4字节（与int类型大小一致）</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-核心应用"><a href="#2-核心应用" class="headerlink" title="2. 核心应用"></a>2. 核心应用</h3><h4 id="（1）函数参数（避免拷贝-修改实参）"><a href="#（1）函数参数（避免拷贝-修改实参）" class="headerlink" title="（1）函数参数（避免拷贝 + 修改实参）"></a>（1）函数参数（避免拷贝 + 修改实参）</h4><ul><li><p>替代指针，语法更简洁，无野指针风险，适合大对象传递（无拷贝开销）。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; x *= <span class="number">2</span>; &#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">update</span>(a); <span class="comment">// a=10（直接修改实参）</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）函数返回值（避免拷贝）"><a href="#（2）函数返回值（避免拷贝）" class="headerlink" title="（2）函数返回值（避免拷贝）"></a>（2）函数返回值（避免拷贝）</h4><ul><li><p>可返回 “全局变量、静态变量、类成员变量” 的引用（生命周期长于函数），避免返回对象的拷贝开销。</p></li><li><p>禁忌：禁止返回局部变量的引用（函数结束后局部变量销毁，引用变为悬垂引用）。</p></li><li><p>示例（正确）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_val = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">get_global</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g_val; &#125; <span class="comment">// 返回全局变量引用，安全</span></span><br></pre></td></tr></table></figure></li><li><p>示例（错误）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">get_local</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 错误：x是局部变量，函数结束后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="三、本质区别"><a href="#三、本质区别" class="headerlink" title="三、本质区别"></a>三、本质区别</h2><ul><li>指针：独立的变量，存储目标变量的内存地址（占用 4&#x2F;8 字节内存，与系统位数相关）。</li><li>引用：非独立变量，是目标变量的 “别名”（语法层面无独立内存，编译器通常用指针实现，但对外隐藏指针操作）。</li></ul><hr><h2 id="四、核心特性对比表"><a href="#四、核心特性对比表" class="headerlink" title="四、核心特性对比表"></a>四、核心特性对比表</h2><table><thead><tr><th>对比特性</th><th>指针（Pointer）</th><th>引用（Reference）</th></tr></thead><tbody><tr><td>初始化</td><td>可延迟初始化（但未初始化是野指针）</td><td>必须定义时初始化，且绑定已存在变量</td></tr><tr><td>指向可修改性</td><td>可重新指向其他变量（<code>p = &amp;b;</code> 合法）</td><td>绑定后不可更改指向（<code>r = b;</code> 是修改原变量值）</td></tr><tr><td>空值支持</td><td>支持（<code>int* p = nullptr;</code>）</td><td>无空引用（必须绑定有效变量）</td></tr><tr><td>解引用操作</td><td>需显式用 <code>*</code>（<code>*p = 10;</code>）</td><td>无需解引用（<code>r = 10;</code> 直接修改绑定变量）</td></tr><tr><td>算术运算</td><td>支持（步长 &#x3D; 指向类型大小）</td><td>不支持（非独立对象，无地址可运算）</td></tr><tr><td>多级嵌套</td><td>支持（<code>int** p</code> 指向指针的指针）</td><td>不支持（<code>int&amp;&amp; r</code> 是右值引用，非 “引用的引用”）</td></tr><tr><td>语法复杂度</td><td>较高（需关注<code>*</code>&#x2F;<code>&amp;</code>&#x2F; 空指针 &#x2F; 野指针）</td><td>较低（简洁直观，无指针操作风险）</td></tr></tbody></table><hr><h2 id="五、补充知识点"><a href="#五、补充知识点" class="headerlink" title="五、补充知识点"></a>五、补充知识点</h2><h3 id="1-作为函数参数的传递机制"><a href="#1-作为函数参数的传递机制" class="headerlink" title="1. 作为函数参数的传递机制"></a>1. 作为函数参数的传递机制</h3><h4 id="（1）指针传参"><a href="#（1）指针传参" class="headerlink" title="（1）指针传参"></a>（1）指针传参</h4><ul><li><p>本质：“值传递地址”—— 函数接收的是实参地址的拷贝，修改指针本身（如<code>p = &amp;b;</code>）不影响实参指针；但修改指针指向的内容（<code>*p = 10;</code>）会影响实参变量。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">20</span>; <span class="comment">// 影响实参变量（修改指向的内容）</span></span><br><span class="line">    p = <span class="literal">nullptr</span>; <span class="comment">// 不影响实参指针（仅修改拷贝）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;</span><br><span class="line"><span class="built_in">func</span>(ptr); <span class="comment">// a=20，ptr仍指向a（未变）</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）引用传参"><a href="#（2）引用传参" class="headerlink" title="（2）引用传参"></a>（2）引用传参</h4><ul><li>本质：传递 “变量别名”—— 函数内修改引用（<code>r = 20;</code>）直接修改实参；且无法修改引用的指向（语法禁止）。</li></ul><h3 id="2-返回值的-“悬垂问题”"><a href="#2-返回值的-“悬垂问题”" class="headerlink" title="2. 返回值的 “悬垂问题”"></a>2. 返回值的 “悬垂问题”</h3><ul><li>指针与引用的共同禁忌：禁止返回局部变量（生命周期随函数结束而销毁）。<ul><li>返回局部变量的指针：得到野指针（指向已释放内存），访问即未定义行为。</li><li>返回局部变量的引用：得到悬垂引用（绑定已销毁变量），访问即未定义行为。</li></ul></li></ul><h3 id="3-const-修饰（面试高频）"><a href="#3-const-修饰（面试高频）" class="headerlink" title="3. const 修饰（面试高频）"></a>3. const 修饰（面试高频）</h3><h4 id="（1）const-修饰指针（左定值，右定向）"><a href="#（1）const-修饰指针（左定值，右定向）" class="headerlink" title="（1）const 修饰指针（左定值，右定向）"></a>（1）const 修饰指针（左定值，右定向）</h4><ul><li><p>核心口诀：<code>const</code> 靠近谁，就限制谁 —— 左定值（限制指向的内容不可改），右定向（限制指针本身不可改）。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p; <span class="comment">// 常量指针（左定值）：指向的内容不可改（*p不能赋值），指针可改指向</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p; <span class="comment">// 指针常量（右定向）：指针本身不可改指向，指向的内容可改（*p可赋值）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p; <span class="comment">// 指向常量的指针常量：内容和指向均不可改</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）const-引用（const-T-）"><a href="#（2）const-引用（const-T-）" class="headerlink" title="（2）const 引用（const T&amp;）"></a>（2）const 引用（<code>const T&amp;</code>）</h4><ul><li><p>核心特性：不可通过引用修改绑定变量，但变量本身可被其他方式修改。</p></li><li><p>关键用途：可绑定临时对象（字面量、表达式结果），常用于函数参数（接收任意类型参数，避免拷贝）。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r1 = <span class="number">10</span>; <span class="comment">// 合法：const引用绑定字面量（临时对象）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r2 = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// 合法：绑定表达式结果</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r3 = a;</span><br><span class="line"><span class="comment">// r3 = 10; // 错误：const引用不可修改绑定变量</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 合法：变量本身可通过其他方式修改（r3的值同步变为10）</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 2. 函数与指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAII</title>
      <link href="/posts/1fa3f2ba.html"/>
      <url>/posts/1fa3f2ba.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>核心思想：资源获取与对象初始化绑定，资源释放与对象析构绑定（构造拿资源，析构放资源）</li><li>实现：封装资源为类成员，构造获取、析构释放，可选禁止拷贝</li><li>典型应用：智能指针、互斥锁、文件句柄、网络连接</li><li>核心优势：自动释放资源、异常安全、简化代码、保障资源独占</li></ul><hr><h2 id="一、核心思想"><a href="#一、核心思想" class="headerlink" title="一、核心思想"></a>一、核心思想</h2><p>RAII（Resource Acquisition Is Initialization）的本质是<strong>用对象生命周期管理资源</strong>：</p><ul><li>对象构造时：自动获取资源（如分配内存、打开文件、加锁），确保资源获取成功后对象才有效；</li><li>对象析构时：自动释放资源（如释放内存、关闭文件、解锁），无论对象正常退出还是因异常销毁，析构函数都会执行。</li></ul><hr><h2 id="二、实现原理（四步核心）"><a href="#二、实现原理（四步核心）" class="headerlink" title="二、实现原理（四步核心）"></a>二、实现原理（四步核心）</h2><ol><li><strong>封装资源</strong>：定义类，将资源（指针、句柄、锁等）作为私有成员；</li><li><strong>获取资源</strong>：在构造函数中获取资源，确保资源获取成功后对象才完成初始化；</li><li><strong>释放资源</strong>：在析构函数中释放资源，覆盖所有退出场景（正常 &#x2F; 异常 &#x2F; 提前返回）；</li><li><strong>禁止拷贝（可选）</strong>：资源不可共享时（如独占锁），删除拷贝构造和赋值运算符，避免资源重复释放。</li></ol><hr><h2 id="三、典型应用场景"><a href="#三、典型应用场景" class="headerlink" title="三、典型应用场景"></a>三、典型应用场景</h2><ul><li><strong>动态内存管理</strong>：智能指针（<code>unique_ptr</code>&#x2F;<code>shared_ptr</code>），构造接收动态内存，析构自动<code>delete</code>；</li><li><strong>互斥锁管理</strong>：多线程中封装锁，构造加锁、析构解锁，避免忘记解锁导致死锁；</li><li><strong>文件句柄管理</strong>：<code>fstream</code>&#x2F; 自定义文件类，构造<code>fopen</code>、析构<code>fclose</code>，避免文件描述符泄漏；</li><li><strong>网络连接管理</strong>：对象创建时建立连接，析构时自动断开，简化连接生命周期管理。</li></ul><hr><h2 id="四、核心优势"><a href="#四、核心优势" class="headerlink" title="四、核心优势"></a>四、核心优势</h2><ol><li><strong>自动释放资源</strong>：无需手动调用释放函数（<code>delete</code>&#x2F;<code>unlock</code>等），避免疏忽导致的资源泄漏；</li><li><strong>异常安全</strong>：C++ 标准保证异常抛出时，当前作用域已构造对象会自动析构，资源仍能正常释放；</li><li><strong>简化代码</strong>：资源管理逻辑封装在类中，业务代码无需关注释放细节，提升可读性和可维护性；</li><li><strong>资源独占性</strong>：通过禁止拷贝，确保资源不被意外共享（如<code>unique_ptr</code>、独占锁）。</li></ol><hr><h2 id="五、资源管理方式对比表"><a href="#五、资源管理方式对比表" class="headerlink" title="五、资源管理方式对比表"></a>五、资源管理方式对比表</h2><table><thead><tr><th>管理方式</th><th>缺点</th><th>RAII 的优势</th></tr></thead><tbody><tr><td>手动释放</td><td>易遗漏、异常下失效（释放代码未执行）</td><td>自动释放，覆盖所有退出场景</td></tr><tr><td>goto 跳转释放</td><td>代码混乱，多出口难维护（C 语言常用）</td><td>无需显式控制流程，依赖对象生命周期</td></tr><tr><td>函数末尾释放</td><td>提前返回时失效（return 前未释放）</td><td>无论退出方式，均自动执行释放逻辑</td></tr></tbody></table><hr><h2 id="六、问答"><a href="#六、问答" class="headerlink" title="六、问答"></a>六、问答</h2><h3 id="RAII-如何保证异常安全？"><a href="#RAII-如何保证异常安全？" class="headerlink" title="RAII 如何保证异常安全？"></a>RAII 如何保证异常安全？</h3><p>C++ 标准规定：当异常抛出时，程序会销毁当前作用域内已构造完成的所有对象（自动调用析构函数）。RAII 将资源释放逻辑封装在析构函数中，因此即使发生异常，对象析构仍会执行，资源被正确释放，避免异常导致的资源泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 6. 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
            <tag> RAII </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符与表达式</title>
      <link href="/posts/dc2fae3c.html"/>
      <url>/posts/dc2fae3c.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>逻辑运算符（<code>&amp;&amp;</code>&#x2F;<code>||</code>）：支持短路求值，右操作数可能不执行（面试高频陷阱）</li><li>逗号运算符（<code>,</code>）：按左到右执行多个表达式，返回最后一个值，优先级最低</li><li>右结合运算符：赋值运算符（<code>=</code>）、条件运算符（<code>?:</code>）、单目运算符，优先级相同时从右到左执行</li></ul><hr><h2 id="一、逻辑运算符的短路求值（-）"><a href="#一、逻辑运算符的短路求值（-）" class="headerlink" title="一、逻辑运算符的短路求值（&amp;&amp; &#x2F; ||）"></a>一、逻辑运算符的短路求值（&amp;&amp; &#x2F; ||）</h2><h3 id="核心规则"><a href="#核心规则" class="headerlink" title="核心规则"></a>核心规则</h3><p>短路求值是逻辑运算符的优化特性，仅在必要时计算右操作数，直接影响代码执行结果。</p><ol><li><code>&amp;&amp;</code>（逻辑与）：左操作数为<code>false</code>时，直接返回<code>false</code>，<strong>右操作数不执行</strong>。</li><li><code>||</code>（逻辑或）：左操作数为<code>true</code>时，直接返回<code>true</code>，<strong>右操作数不执行</strong>。</li></ol><h3 id="常见场景（含副作用表达式）"><a href="#常见场景（含副作用表达式）" class="headerlink" title="常见场景（含副作用表达式）"></a>常见场景（含副作用表达式）</h3><ul><li><p><code>&amp;&amp;</code>短路示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> res = (i == <span class="number">1</span>) &amp;&amp; (++i); <span class="comment">// 左为false，右++i不执行</span></span><br><span class="line"><span class="comment">// 结果：res=false，i=0（而非1）</span></span><br></pre></td></tr></table></figure></li><li><p><code>||</code>短路示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> res = (j == <span class="number">0</span>) || (++j); <span class="comment">// 左为true，右++j不执行</span></span><br><span class="line"><span class="comment">// 结果：res=true，j=0（而非1）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ul><li>禁止将 “必须执行的代码”（如变量更新、数据写入）放在短路运算符右侧，可能因短路导致逻辑失效。</li><li>区分<code>&amp;&amp;</code>&#x2F;<code>||</code>（有短路特性）与<code>&amp;</code>&#x2F;<code>|</code>（按位运算，无短路，左右操作数均执行）。</li></ul><hr><h2 id="二、逗号运算符（-）"><a href="#二、逗号运算符（-）" class="headerlink" title="二、逗号运算符（,）"></a>二、逗号运算符（,）</h2><h3 id="核心规则-1"><a href="#核心规则-1" class="headerlink" title="核心规则"></a>核心规则</h3><ul><li>执行顺序：按<strong>从左到右</strong>依次执行所有表达式。</li><li>返回值：最终返回<strong>最后一个表达式的值</strong>。</li><li>优先级：C++ 中优先级最低（低于赋值运算符），需用括号明确执行逻辑。</li></ul><h3 id="典型场景（含陷阱）"><a href="#典型场景（含陷阱）" class="headerlink" title="典型场景（含陷阱）"></a>典型场景（含陷阱）</h3><ol><li>优先级陷阱（与赋值结合）：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, <span class="number">2</span>; <span class="comment">// 错误：等价于(a=1),2，赋值语句不合法</span></span><br><span class="line"><span class="type">int</span> a = (<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 正确：返回最后一个表达式，a=2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>for 循环多操作场景：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">5</span>; i&lt;<span class="number">5</span>; i++, j--) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 初始化：i=0和j=5同时执行；更新：i++和j--按顺序执行</span></span><br></pre></td></tr></table></figure><h3 id="核心考点"><a href="#核心考点" class="headerlink" title="核心考点"></a>核心考点</h3><ul><li>核心考察 “返回最后一个表达式值”，常结合赋值语句预判结果。</li><li>区分 “变量声明中的逗号”（非运算符），如<code>int a, b;</code>是声明两个变量，并非逗号运算符。</li></ul><hr><h2 id="三、右结合运算符（优先级相同时的执行顺序）"><a href="#三、右结合运算符（优先级相同时的执行顺序）" class="headerlink" title="三、右结合运算符（优先级相同时的执行顺序）"></a>三、右结合运算符（优先级相同时的执行顺序）</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>结合性指 “多个优先级相同的运算符连续出现时的执行顺序”，C++ 中多数运算符为左结合，仅以下三类为右结合（面试必考）。</p><h3 id="三类核心右结合运算符"><a href="#三类核心右结合运算符" class="headerlink" title="三类核心右结合运算符"></a>三类核心右结合运算符</h3><h4 id="1-赋值运算符（-）"><a href="#1-赋值运算符（-）" class="headerlink" title="1. 赋值运算符（&#x3D;）"></a>1. 赋值运算符（&#x3D;）</h4><ul><li><p>规则：从右到左执行，支持链式赋值。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = b = c = <span class="number">5</span>; <span class="comment">// 右结合：先c=5 → 再b=c → 最后a=b，结果a=b=c=5</span></span><br></pre></td></tr></table></figure></li><li><p>易错点：<code>a = 3, 4</code>等价于<code>(a=3),4</code>，a 的值为 3（非 4），因逗号运算符优先级更低。</p></li></ul><h4 id="2-条件运算符（-）"><a href="#2-条件运算符（-）" class="headerlink" title="2. 条件运算符（?:）"></a>2. 条件运算符（?:）</h4><ul><li><p>规则：唯一的右结合双目运算符，嵌套时从右向左解析。</p></li><li><p>嵌套示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> res = x&gt;y ? x : y&gt;z ? y : z; <span class="comment">// 等价于x&gt;y ? x : (y&gt;z ? y : z)</span></span><br><span class="line"><span class="comment">// 结果：res=3（y&gt;z为false，取z=3）</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-单目运算符"><a href="#3-单目运算符" class="headerlink" title="3. 单目运算符"></a>3. 单目运算符</h4><ul><li><p>包含：前缀<code>++</code>、前缀<code>--</code>、<code>*</code>（解引用）、<code>&amp;</code>（取地址）、<code>!</code>、<code>~</code>、<code>+</code>（正）、<code>-</code>（负）、<code>sizeof</code>等。</p></li><li><p>规则：从右到左执行，常结合指针操作考察。</p></li><li><p>指针示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* p=&amp;a;</span><br><span class="line">++*p; <span class="comment">// 右结合：先*p（取a=5）→ 再++，结果a=6</span></span><br></pre></td></tr></table></figure></li><li><p>易错点：区分前缀（右结合）和后缀<code>++</code>&#x2F;<code>--</code>（左结合），如<code>*p++</code>是左结合，先<code>*p</code>再<code>p++</code>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 1. 基础语法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 运算符 </tag>
            
            <tag> 表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组基础</title>
      <link href="/posts/c24002d9.html"/>
      <url>/posts/c24002d9.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>数组名：本质是首元素地址，仅 3 种场景不退化（sizeof、&amp; 数组名、decltype）</li><li>数组传参：一维退化为指针（丢失长度），二维必须指定第二维长度</li><li>C 风格字符串：以<code>&#39;\0&#39;</code>结尾的字符数组，strlen 与 sizeof 计算逻辑不同</li><li>数组 vs vector：数组编译期定长、手动管理内存；vector 动态扩容、自动管理</li></ul><hr><h2 id="一、数组名与指针"><a href="#一、数组名与指针" class="headerlink" title="一、数组名与指针"></a>一、数组名与指针</h2><p>数组名的核心特性：<strong>通常等价于首元素地址</strong>，但以下 3 种场景不退化（保留数组类型特性）。</p><h3 id="1-数组名不退化的-3-种场景"><a href="#1-数组名不退化的-3-种场景" class="headerlink" title="1. 数组名不退化的 3 种场景"></a>1. 数组名不退化的 3 种场景</h3><ul><li><code>sizeof(数组名)</code>：计算整个数组的字节总大小（而非指针大小）。</li><li><code>&amp;数组名</code>：获取指向 “整个数组” 的指针（类型为<code>数组类型(*)[长度]</code>，而非首元素指针）。</li><li><code>decltype(数组名)</code>：推导为数组类型（如<code>decltype(arr)</code>为<code>int[5]</code>，而非<code>int*</code>）。</li></ul><h3 id="2-易错点补充"><a href="#2-易错点补充" class="headerlink" title="2. 易错点补充"></a>2. 易错点补充</h3><ul><li><p>区分<code>&amp;数组名</code>与<code>&amp;数组首元素</code>：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">&amp;arr;    <span class="comment">// 类型为int(*)[5]（指向整个数组的指针），+1偏移5个int（20字节）</span></span><br><span class="line">&amp;arr[<span class="number">0</span>]; <span class="comment">// 类型为int*（指向首元素的指针），+1偏移1个int（4字节）</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="二、数组作为函数参数"><a href="#二、数组作为函数参数" class="headerlink" title="二、数组作为函数参数"></a>二、数组作为函数参数</h2><p>数组传参时<strong>必然退化为指针</strong>，丢失原数组长度信息，需手动传递长度参数。</p><h3 id="1-一维数组传参（3-种写法）"><a href="#1-一维数组传参（3-种写法）" class="headerlink" title="1. 一维数组传参（3 种写法）"></a>1. 一维数组传参（3 种写法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1：数组形式（[]内数字无意义，仅为语法兼容）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> arr[<span class="number">5</span>])</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2：省略长度的数组形式（等价于int* arr）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3：显式指针形式（最直观，推荐）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>* arr)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="2-二维数组传参"><a href="#2-二维数组传参" class="headerlink" title="2. 二维数组传参"></a>2. 二维数组传参</h3><ul><li>核心规则：二维数组退化后是 “指向一维数组的指针”，编译器需通过第二维长度计算步长，因此<strong>第二维长度不可省略</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确写法：第二维长度3必须指定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> mat[][<span class="number">3</span>], <span class="type">int</span> rows)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法：第二维长度省略（编译器无法确定元素访问步长）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> mat[][], <span class="type">int</span> rows, <span class="type">int</span> cols)</span> </span>&#123; ... &#125; <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h3 id="3-关键提醒"><a href="#3-关键提醒" class="headerlink" title="3. 关键提醒"></a>3. 关键提醒</h3><ul><li>函数内无法通过<code>sizeof(arr)</code>获取原数组长度（此时 arr 已退化为指针，<code>sizeof(arr)</code>为 4&#x2F;8 字节）。</li><li>必须显式传递长度参数（如<code>func(arr, 5)</code>），或通过其他方式（如数组结尾标记）获取长度。</li></ul><hr><h2 id="三、字符串与字符数组（C-风格）"><a href="#三、字符串与字符数组（C-风格）" class="headerlink" title="三、字符串与字符数组（C 风格）"></a>三、字符串与字符数组（C 风格）</h2><ul><li>本质：以<code>&#39;\0&#39;</code>（空字符）结尾的字符数组，<code>&#39;\0&#39;</code>是字符串结束标记（编译器在字符串常量后自动填充）。</li></ul><h3 id="1-核心区别：strlen-vs-sizeof"><a href="#1-核心区别：strlen-vs-sizeof" class="headerlink" title="1. 核心区别：strlen vs sizeof"></a>1. 核心区别：<code>strlen</code> vs <code>sizeof</code></h3><ul><li><code>strlen(str)</code>：计算<code>&#39;\0&#39;</code>之前的字符个数（不包含<code>&#39;\0&#39;</code>）。</li><li><code>sizeof(str)</code>：计算整个字符数组的字节大小（包含<code>&#39;\0&#39;</code>和未使用的空间）。</li></ul><h3 id="2-高频易错点补充"><a href="#2-高频易错点补充" class="headerlink" title="2. 高频易错点补充"></a>2. 高频易错点补充</h3><ul><li><p>未手动添加<code>&#39;\0&#39;</code>会导致 strlen 越界：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 自动添加&#x27;\0&#x27;，数组长度6（h e l l o \0）</span></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// 无&#x27;\0&#x27;，strlen(str2)结果不确定（越界查找）</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四、数组和动态容器（vector）对比表"><a href="#四、数组和动态容器（vector）对比表" class="headerlink" title="四、数组和动态容器（vector）对比表"></a>四、数组和动态容器（vector）对比表</h2><table><thead><tr><th>对比维度</th><th>数组（Array）</th><th>vector（动态数组）</th></tr></thead><tbody><tr><td>大小特性</td><td>编译期固定，运行时不可修改</td><td>运行时动态调整，<code>push_back</code>自动扩容</td></tr><tr><td>内存管理</td><td>栈 &#x2F; 全局区存储，手动管理（无自动释放）</td><td>堆内存存储，自动管理（析构时释放资源）</td></tr><tr><td>长度获取</td><td>手动计算（<code>sizeof(arr)/sizeof(arr[0])</code>）</td><td>内置<code>size()</code>方法（直接获取元素个数）</td></tr><tr><td>传参方式</td><td>退化为指针，需额外传递长度参数</td><td>传引用（<code>vector&lt;int&gt;&amp;</code>），保留长度信息</td></tr><tr><td>越界安全性</td><td>无越界检查，访问越界为未定义行为</td><td><code>at()</code>方法支持越界检查（抛异常），更安全</td></tr><tr><td>灵活性</td><td>低（不可扩容 &#x2F; 缩容）</td><td>高（支持插入、删除、扩容等操作）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 3. 数组与字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态内存</title>
      <link href="/posts/58a84bc7.html"/>
      <url>/posts/58a84bc7.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>动态内存：运行时手动分配，需手动释放（否则泄漏）；new&#x2F;delete 自动调用构造 &#x2F; 析构，需与 new []&#x2F;delete [] 严格匹配</li><li>智能指针（C++11+，<code>&lt;memory&gt;</code>）：RAII 机制自动管理内存，<code>unique_ptr</code>（独占）、<code>shared_ptr</code>（共享，引用计数）、<code>weak_ptr</code>（解循环引用）</li><li>常见问题：内存泄漏（未释放）、野指针（未初始化）、悬空指针（指向已释放内存）</li></ul><hr><h2 id="一、动态内存的分配与释放"><a href="#一、动态内存的分配与释放" class="headerlink" title="一、动态内存的分配与释放"></a>一、动态内存的分配与释放</h2><p>核心是 “分配 - 使用 - 释放” 闭环，C++ 推荐用 new&#x2F;delete，需严格匹配使用。</p><h3 id="1-C-vs-C-分配释放方式对比"><a href="#1-C-vs-C-分配释放方式对比" class="headerlink" title="1. C vs C++ 分配释放方式对比"></a>1. C vs C++ 分配释放方式对比</h3><table><thead><tr><th>对比维度</th><th>C（malloc&#x2F;free）</th><th>C++（new&#x2F;delete）</th></tr></thead><tbody><tr><td>类型安全</td><td>返回<code>void*</code>，需手动强转（不安全）</td><td>返回对应类型指针（无需转换，安全）</td></tr><tr><td>构造 &#x2F; 析构</td><td>不调用（仅操作内存）</td><td>自动调用构造（new）&#x2F; 析构（delete）</td></tr><tr><td>数组支持</td><td>需手动计算总大小（<code>n*sizeof(T)</code>）</td><td>直接<code>new T[n]</code>（自动计算大小）</td></tr><tr><td>分配失败</td><td>返回<code>NULL</code></td><td>默认抛<code>bad_alloc</code>，可指定<code>nothrow</code>返回<code>NULL</code></td></tr><tr><td>重载扩展</td><td>不可重载</td><td>可重载<code>operator new</code>&#x2F;<code>operator delete</code>定制分配</td></tr></tbody></table><h3 id="2-关键匹配规则"><a href="#2-关键匹配规则" class="headerlink" title="2. 关键匹配规则"></a>2. 关键匹配规则</h3><ul><li>单个对象：<code>new T</code> → <code>delete ptr</code>（匹配单个构造 &#x2F; 析构）</li><li>数组对象：<code>new T[n]</code> → <code>delete[] ptr</code>（匹配 n 次构造 &#x2F; 析构）</li><li>不匹配后果：<ul><li><code>delete</code>释放<code>new[]</code>：仅第一个元素析构，其余资源泄漏，可能崩溃</li><li><code>delete[]</code>释放<code>new</code>：错误读取数组长度，多次析构，破坏内存状态</li></ul></li></ul><h3 id="3-底层执行流程"><a href="#3-底层执行流程" class="headerlink" title="3. 底层执行流程"></a>3. 底层执行流程</h3><h4 id="new-的核心步骤"><a href="#new-的核心步骤" class="headerlink" title="new 的核心步骤"></a>new 的核心步骤</h4><ol><li>调用<code>operator new(sizeof(T))</code>：分配原始内存（底层通常调用 malloc）</li><li>调用构造函数：<code>new(p) T(args)</code>（placement new，在指定内存构造对象）</li><li>返回对象指针</li></ol><h4 id="delete-的核心步骤"><a href="#delete-的核心步骤" class="headerlink" title="delete 的核心步骤"></a>delete 的核心步骤</h4><ol><li>调用析构函数：<code>p-&gt;~T()</code>（清理对象资源）</li><li>调用<code>operator delete(p)</code>：释放内存（底层通常调用 free）</li></ol><hr><h2 id="二、常见动态内存问题"><a href="#二、常见动态内存问题" class="headerlink" title="二、常见动态内存问题"></a>二、常见动态内存问题</h2><h3 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1. 内存泄漏"></a>1. 内存泄漏</h3><ul><li>定义：动态内存不再使用但未释放，永久占用内存</li><li>核心原因：忘记释放、指针被重赋值（地址丢失）、异常导致释放代码未执行</li><li>解决方案：用智能指针、遵循 “谁分配谁释放”、RAII 机制（对象析构自动释放）</li></ul><h3 id="2-野指针"><a href="#2-野指针" class="headerlink" title="2. 野指针"></a>2. 野指针</h3><ul><li>定义：未初始化的指针（指向随机内存）</li><li>危害：解引用导致未定义行为（崩溃、数据错乱）</li><li>避免方案：定义时初始化（<code>int* p = nullptr;</code>），释放后置为<code>nullptr</code></li></ul><h3 id="3-悬空指针"><a href="#3-悬空指针" class="headerlink" title="3. 悬空指针"></a>3. 悬空指针</h3><ul><li>定义：指向已释放内存的指针（地址未置空）</li><li>危害：解引用访问无效内存（逻辑错误或崩溃）</li><li>避免方案：释放后立即置<code>nullptr</code>，避免重复释放</li></ul><hr><h2 id="三、智能指针（C-11-，自动内存管理）"><a href="#三、智能指针（C-11-，自动内存管理）" class="headerlink" title="三、智能指针（C++11+，自动内存管理）"></a>三、智能指针（C++11+，自动内存管理）</h2><p>基于 RAII 机制，析构时自动释放内存，彻底解决手动管理的缺陷。</p><h3 id="1-unique-ptr：独占所有权"><a href="#1-unique-ptr：独占所有权" class="headerlink" title="1. unique_ptr：独占所有权"></a>1. unique_ptr：独占所有权</h3><ul><li>核心特性：同一时间仅一个<code>unique_ptr</code>指向内存，不可复制（禁用拷贝构造 &#x2F; 赋值），可通过<code>std::move</code>转移所有权</li><li>适用场景：单一所有者的动态内存（如局部动态对象、函数返回动态对象）</li><li>关键：无额外内存开销（仅封装原始指针）</li></ul><h3 id="2-shared-ptr：共享所有权"><a href="#2-shared-ptr：共享所有权" class="headerlink" title="2. shared_ptr：共享所有权"></a>2. shared_ptr：共享所有权</h3><ul><li>核心特性：多个<code>shared_ptr</code>共享同一内存，通过<strong>控制块</strong>维护引用计数（计数为 0 时自动释放）</li><li>控制块内容：引用计数、弱引用计数、删除器、分配器</li><li>适用场景：多所有者的动态内存（如共享资源、容器中存储动态对象）</li><li>注意：线程安全（引用计数的增减是原子操作），但对象读写需额外同步</li></ul><h3 id="3-weak-ptr：解决循环引用"><a href="#3-weak-ptr：解决循环引用" class="headerlink" title="3. weak_ptr：解决循环引用"></a>3. weak_ptr：解决循环引用</h3><ul><li>核心特性：弱引用（不增加引用计数），仅观测<code>shared_ptr</code>管理的内存，不影响生命周期</li><li>核心用途：解决<code>shared_ptr</code>的循环引用问题（如 A 和 B 互相持有<code>shared_ptr</code>，导致计数无法归零）</li><li>关键操作：<code>lock()</code>方法获取<code>shared_ptr</code>（有效则返回非空，无效则返回空）</li></ul><h3 id="4-循环引用示例"><a href="#4-循环引用示例" class="headerlink" title="4. 循环引用示例"></a>4. 循环引用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: shared_ptr&lt;B&gt; b; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="keyword">public</span>: shared_ptr&lt;A&gt; a; &#125;;</span><br><span class="line"><span class="comment">// 循环引用：a和b的引用计数均为2，析构时无法归零，内存泄漏</span></span><br><span class="line">shared_ptr&lt;A&gt; a = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">shared_ptr&lt;B&gt; b = <span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">a-&gt;b = b;</span><br><span class="line">b-&gt;a = a;</span><br><span class="line"><span class="comment">// 解决方案：将其中一个改为weak_ptr（如B的a改为weak_ptr&lt;A&gt;）</span></span><br></pre></td></tr></table></figure><hr><h2 id="四、问答"><a href="#四、问答" class="headerlink" title="四、问答"></a>四、问答</h2><ul><li><p>智能指针的底层实现原理？</p><p>  智能指针是类模板，封装原始指针，通过 RAII 机制在析构时自动释放内存。<code>unique_ptr</code>禁用拷贝实现独占；<code>shared_ptr</code>通过控制块存储引用计数，计数为 0 时释放；<code>weak_ptr</code>指向控制块，不增减计数，用于解循环引用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 6. 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态内存 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区</title>
      <link href="/posts/b5d386b7.html"/>
      <url>/posts/b5d386b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>五大核心分区：栈（临时空间，自动管理）、堆（动态空间，手动管理）、全局 &#x2F; 静态区（持久空间）、常量存储区（只读）、代码区（指令存储）</li><li>关键考点：各分区存储内容 &#x2F; 生命周期 &#x2F; 分配方式、栈与堆的区别、const 变量存储位置、线程局部存储特性</li><li>高频问答：全局 &#x2F; 局部 &#x2F; 静态局部变量的存储与生命周期</li></ul><hr><h2 id="一、五大核心内存分区"><a href="#一、五大核心内存分区" class="headerlink" title="一、五大核心内存分区"></a>一、五大核心内存分区</h2><h3 id="1-栈（stack）：函数调用的临时空间"><a href="#1-栈（stack）：函数调用的临时空间" class="headerlink" title="1. 栈（stack）：函数调用的临时空间"></a>1. 栈（stack）：函数调用的临时空间</h3><ul><li>存储内容：局部变量、函数参数、返回地址、寄存器上下文</li><li>生命周期：函数调用时创建，函数返回时自动释放</li><li>关键特点：<ul><li>分配方式：编译器自动分配，仅移动栈顶指针（效率极高）</li><li>内存特性：地址连续，生长方向<strong>向下</strong>（高地址→低地址）</li><li>大小限制：固定（通常几 MB），超出则栈溢出（递归过深、局部数组过大）</li></ul></li></ul><h3 id="2-堆（heap）：动态分配的手动管理空间"><a href="#2-堆（heap）：动态分配的手动管理空间" class="headerlink" title="2. 堆（heap）：动态分配的手动管理空间"></a>2. 堆（heap）：动态分配的手动管理空间</h3><ul><li>存储内容：new&#x2F;malloc 动态分配的内存</li><li>生命周期：手动分配（new&#x2F;malloc）→ 手动释放（delete&#x2F;free），未释放则程序结束后由 OS 回收</li><li>关键特点：<ul><li>分配方式：程序员手动调用，需查找空闲内存块（效率低于栈）</li><li>内存特性：地址不连续，生长方向<strong>向上</strong>（低地址→高地址）</li><li>潜在问题：频繁分配 &#x2F; 释放产生内存碎片，未释放导致内存泄漏</li></ul></li></ul><h3 id="3-全局-静态存储区"><a href="#3-全局-静态存储区" class="headerlink" title="3. 全局 &#x2F; 静态存储区"></a>3. 全局 &#x2F; 静态存储区</h3><ul><li>存储内容：全局变量（函数外定义）、静态变量（static 修饰，含全局静态 &#x2F; 局部静态）</li><li>生命周期：程序启动（main 前）→ 程序结束（main 后），OS 自动释放</li><li>关键特点：<ul><li>分配方式：编译期确定大小，程序加载时 OS 分配</li><li>默认初始化：未初始化的变量自动置 0（区别于栈的 “垃圾值”）</li><li>作用域差异：全局变量作用域为整个程序，静态变量作用域限于定义位置</li></ul></li></ul><h3 id="4-常量存储区"><a href="#4-常量存储区" class="headerlink" title="4. 常量存储区"></a>4. 常量存储区</h3><ul><li>存储内容：字符串常量（如<code>&quot;hello&quot;</code>）、全局 const 常量</li><li>生命周期：程序全程（加载→结束）</li><li>关键特点（面试易错）：<ul><li>内存只读（修改触发未定义行为，如崩溃）</li><li>字符串常量可能被编译器优化共享（如多个<code>&quot;hello&quot;</code>指向同一地址）</li><li>区分：const 局部变量存储在<strong>栈</strong>上（仅不可修改，生命周期同局部变量）；<code>char arr[] = &quot;hello&quot;</code>的内容存储在<strong>栈</strong>上（拷贝常量区字符串）</li></ul></li></ul><h3 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5. 代码区"></a>5. 代码区</h3><ul><li>存储内容：程序机器指令（二进制代码）、只读数据（常量表达式）</li><li>生命周期：程序全程（加载→结束）</li><li>关键特点：<ul><li>内存只读（防止指令被篡改）</li><li>可共享：多线程运行同一程序时，共享同一份代码区（节省内存）</li></ul></li></ul><hr><h2 id="二、核心对比表"><a href="#二、核心对比表" class="headerlink" title="二、核心对比表"></a>二、核心对比表</h2><table><thead><tr><th>分区</th><th>存储内容</th><th>生命周期</th><th>分配方式</th><th>管理方式</th></tr></thead><tbody><tr><td>栈</td><td>局部变量、参数、返回地址</td><td>函数调用期间</td><td>编译器自动</td><td>自动释放</td></tr><tr><td>堆</td><td>动态分配内存（new&#x2F;malloc）</td><td>手动分配→手动释放</td><td>程序员手动</td><td>手动释放（delete&#x2F;free）</td></tr><tr><td>全局 &#x2F; 静态存储区</td><td>全局变量、静态变量</td><td>程序全程</td><td>编译期分配</td><td>程序结束自动释放</td></tr><tr><td>常量存储区</td><td>字符串常量、全局 const 常量</td><td>程序全程</td><td>编译期分配</td><td>程序结束自动释放</td></tr><tr><td>代码区</td><td>机器指令、只读数据</td><td>程序全程</td><td>程序加载时</td><td>只读不修改</td></tr></tbody></table><hr><h2 id="三、线程局部存储（thread-local）"><a href="#三、线程局部存储（thread-local）" class="headerlink" title="三、线程局部存储（thread_local）"></a>三、线程局部存储（thread_local）</h2><ul><li>存储内容：<code>thread_local</code>修饰的变量（线程私有变量）</li><li>生命周期：线程创建→线程结束（与线程绑定）</li><li>关键特点：<ul><li>每个线程拥有独立副本，互不干扰（解决多线程全局变量竞争问题）</li><li>作用域：同普通变量（局部 &#x2F; 全局），但仅当前线程可见</li></ul></li></ul><hr><h2 id="四、问答"><a href="#四、问答" class="headerlink" title="四、问答"></a>四、问答</h2><h3 id="全局变量、局部变量、静态局部变量的存储分区与生命周期？"><a href="#全局变量、局部变量、静态局部变量的存储分区与生命周期？" class="headerlink" title="全局变量、局部变量、静态局部变量的存储分区与生命周期？"></a>全局变量、局部变量、静态局部变量的存储分区与生命周期？</h3><ul><li>全局变量：全局 &#x2F; 静态存储区，生命周期为程序全程。</li><li>局部变量：栈，生命周期为函数调用期间。</li><li>静态局部变量：全局 &#x2F; 静态存储区，生命周期为程序全程（作用域限于函数内）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 6. 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
            <tag> 分区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态</title>
      <link href="/posts/3a088510.html"/>
      <url>/posts/3a088510.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>继承：解决代码复用与扩展，核心是派生类获取基类成员；继承方式分 public&#x2F;protected&#x2F;private，构造先父后子、析构先子后父</li><li>多态：解决接口统一与动态行为，核心是基类指针 &#x2F; 引用指向派生类对象，调用虚函数触发动态绑定</li><li>关键机制：虚函数（<code>virtual</code>）、纯虚函数（抽象类）、虚函数表（vtable）+ 虚指针（vptr）、虚析构（避免资源泄漏）</li><li>易混淆点：重写（Override）vs 重载（Overload）vs 隐藏（Hide）</li></ul><hr><h2 id="一、继承：代码复用与层次化设计"><a href="#一、继承：代码复用与层次化设计" class="headerlink" title="一、继承：代码复用与层次化设计"></a>一、继承：代码复用与层次化设计</h2><p>继承是派生类从基类获取成员（属性 + 行为）的机制，核心是 “基于已有类扩展功能”。</p><h3 id="1-继承方式与成员访问权限"><a href="#1-继承方式与成员访问权限" class="headerlink" title="1. 继承方式与成员访问权限"></a>1. 继承方式与成员访问权限</h3><p>继承方式决定基类成员在派生类中的访问权限，常用<code>public</code>继承（其他方式极少用）。</p><table><thead><tr><th>基类成员权限</th><th>public 继承（常用）</th><th>protected 继承</th><th>private 继承</th></tr></thead><tbody><tr><td>public</td><td>派生类 public</td><td>派生类 protected</td><td>派生类 private</td></tr><tr><td>protected</td><td>派生类 protected</td><td>派生类 protected</td><td>派生类 private</td></tr><tr><td>private</td><td>派生类不可访问</td><td>派生类不可访问</td><td>派生类不可访问</td></tr></tbody></table><h3 id="2-派生类的构造与析构"><a href="#2-派生类的构造与析构" class="headerlink" title="2. 派生类的构造与析构"></a>2. 派生类的构造与析构</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>执行顺序：<strong>先调用基类构造函数</strong>（初始化基类部分）→ 再调用派生类构造函数（初始化新增部分）。</li><li>关键规则：若基类无默认构造函数（无参 &#x2F; 全默认参数），派生类必须在<strong>初始化列表中显式调用基类带参构造</strong>（否则编译报错）。</li></ul><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul><li>执行顺序：<strong>先调用派生类析构函数</strong>（清理派生类资源）→ 再调用基类析构函数（清理基类资源）。</li><li>核心考点：基类析构函数必须加<code>virtual</code>（虚析构），否则通过基类指针删除派生类对象时，仅调用基类析构，导致派生类资源泄漏。</li></ul><h3 id="3-菱形继承与虚继承"><a href="#3-菱形继承与虚继承" class="headerlink" title="3. 菱形继承与虚继承"></a>3. 菱形继承与虚继承</h3><h4 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h4><ul><li>场景：派生类间接继承同一基类多次（如 D 继承 B 和 C，B 和 C 均继承 A）。</li><li>后果：基类成员在派生类中存在多份拷贝，导致<strong>数据冗余</strong>和<strong>访问二义性</strong>（如<code>d.a</code>无法确定访问哪个 A 的成员）。</li></ul><h4 id="解决方案：虚继承"><a href="#解决方案：虚继承" class="headerlink" title="解决方案：虚继承"></a>解决方案：虚继承</h4><ul><li>语法：在间接继承路径中加<code>virtual</code>关键字（如<code>class B : virtual public A</code>）。</li><li>原理：虚继承的派生类通过<strong>虚基类表指针（vbptr）</strong> 间接访问基类成员，确保基类在最终派生类中仅存一份实例。</li><li>关键规则：虚基类的构造函数由<strong>最终派生类</strong>负责初始化（而非直接派生类）。</li></ul><hr><h2 id="二、多态：接口复用与动态行为"><a href="#二、多态：接口复用与动态行为" class="headerlink" title="二、多态：接口复用与动态行为"></a>二、多态：接口复用与动态行为</h2><p>多态是 “同一接口，不同实现”，按绑定时机分静态多态和动态多态，核心考察动态多态。</p><h3 id="1-静态多态（编译期多态）"><a href="#1-静态多态（编译期多态）" class="headerlink" title="1. 静态多态（编译期多态）"></a>1. 静态多态（编译期多态）</h3><ul><li>绑定时机：编译阶段确定调用哪个函数。</li><li>实现方式：<ul><li>函数重载：同一作用域内同名函数，参数列表（类型 &#x2F; 个数 &#x2F; 顺序）不同。</li><li>模板：参数类型不同时，编译器生成不同版本的函数 &#x2F; 类。</li></ul></li></ul><h3 id="2-动态多态（运行期多态，面试核心）"><a href="#2-动态多态（运行期多态，面试核心）" class="headerlink" title="2. 动态多态（运行期多态，面试核心）"></a>2. 动态多态（运行期多态，面试核心）</h3><ul><li>绑定时机：运行阶段根据对象实际类型确定调用的函数。</li><li>实现条件（缺一不可）：<ol><li>基类声明虚函数（加<code>virtual</code>关键字）。</li><li>派生类重写（<code>override</code>显式标注）该虚函数。</li><li>通过基类指针或引用指向派生类对象，调用虚函数。</li></ol></li></ul><h4 id="（1）虚函数重写规则"><a href="#（1）虚函数重写规则" class="headerlink" title="（1）虚函数重写规则"></a>（1）虚函数重写规则</h4><ul><li>派生类函数与基类函数的<strong>函数名、参数列表、返回类型完全一致</strong>（返回类型可协变：基类返回<code>Base*</code>，派生类可返回<code>Derived*</code>）。</li><li>基类函数必须带<code>virtual</code>（派生类可省略<code>virtual</code>，但不推荐，显式标注更清晰）。</li><li>访问权限可不同（如基类<code>public</code>，派生类<code>protected</code>），但通过基类指针调用时需满足基类访问权限。</li></ul><h4 id="（2）底层实现：虚函数表（vtable）-虚指针（vptr）"><a href="#（2）底层实现：虚函数表（vtable）-虚指针（vptr）" class="headerlink" title="（2）底层实现：虚函数表（vtable）+ 虚指针（vptr）"></a>（2）底层实现：虚函数表（vtable）+ 虚指针（vptr）</h4><ul><li>虚函数表（vtable）：每个含虚函数的类（基类 &#x2F; 派生类）有一个<strong>全局唯一的 vtable</strong>，存储该类所有虚函数的地址。</li><li>虚指针（vptr）：每个对象包含一个 vptr 成员（64 位系统占 8 字节），指向所属类的 vtable。</li><li>动态绑定流程：<ol><li>基类声明虚函数，编译器为基类生成 vtable，存入基类虚函数地址。</li><li>派生类重写虚函数，编译器为派生类生成 vtable，重写函数地址替换为派生类版本，未重写的仍指向基类版本。</li><li>对象创建时，vptr 初始化指向所属类的 vtable。</li><li>调用虚函数（如<code>base_ptr-&gt;func()</code>），通过 vptr 找到 vtable，调用对应函数地址（运行时确定）。</li></ol></li></ul><h4 id="（3）纯虚函数与抽象类"><a href="#（3）纯虚函数与抽象类" class="headerlink" title="（3）纯虚函数与抽象类"></a>（3）纯虚函数与抽象类</h4><ul><li>纯虚函数：未实现的虚函数，语法<code>virtual void func() = 0;</code>，用于定义接口。</li><li>抽象类：含纯虚函数的类，<strong>不能实例化对象</strong>（仅作为基类）。</li><li>派生类规则：必须实现基类所有纯虚函数，否则仍是抽象类（无法实例化）。</li></ul><hr><h2 id="三、核心概念区分"><a href="#三、核心概念区分" class="headerlink" title="三、核心概念区分"></a>三、核心概念区分</h2><h3 id="重写（Override）vs-重载（Overload）vs-隐藏（Hide）"><a href="#重写（Override）vs-重载（Overload）vs-隐藏（Hide）" class="headerlink" title="重写（Override）vs 重载（Overload）vs 隐藏（Hide）"></a>重写（Override）vs 重载（Overload）vs 隐藏（Hide）</h3><table><thead><tr><th>对比维度</th><th>重写（Override）</th><th>重载（Overload）</th><th>隐藏（Hide）</th></tr></thead><tbody><tr><td>作用域</td><td>不同作用域（基类 vs 派生类）</td><td>同一作用域（如同一类 &#x2F; 命名空间）</td><td>不同作用域（基类 vs 派生类）</td></tr><tr><td>函数关系</td><td>基类虚函数与派生类同名函数</td><td>同名函数</td><td>派生类函数与基类同名，但不满足重写</td></tr><tr><td>关键条件</td><td>函数名、参数、返回值完全一致</td><td>参数列表不同（类型 &#x2F; 个数 &#x2F; 顺序）</td><td>不满足重写条件（如基类非虚函数）</td></tr><tr><td>多态类型</td><td>动态多态（运行期绑定）</td><td>静态多态（编译期绑定）</td><td>无多态（直接调用派生类函数）</td></tr><tr><td>访问基类函数</td><td>直接调用（基类指针 &#x2F; 引用触发）</td><td>按实参类型匹配</td><td>需用基类名限定（<code>Base::func()</code>）</td></tr></tbody></table><h3 id="虚函数的限制"><a href="#虚函数的限制" class="headerlink" title="虚函数的限制"></a>虚函数的限制</h3><ol><li>静态成员函数不能是虚函数（无<code>this</code>指针，无法访问 vptr，无法动态绑定）。</li><li>构造函数不能是虚函数（对象构造时 vptr 尚未初始化，无法访问 vtable）。</li><li>内联函数可以是虚函数，但触发动态绑定时，内联优化失效（内联是编译期，动态绑定是运行期）。</li><li>友元函数不能是虚函数（友元不是类成员，无<code>this</code>指针，无法关联 vtable）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 4. 面向对象编程OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串基础</title>
      <link href="/posts/5f08cd61.html"/>
      <url>/posts/5f08cd61.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>C 风格字符串：以<code>&#39;\0&#39;</code>结尾的字符数组，依赖<code>cstring</code>库函数，无安全检查（易溢出）</li><li>C++ <code>std::string</code>：动态管理、安全便捷，支持 SSO（小字符串优化），提供丰富成员方法</li><li>拷贝关键：C 语言<code>strcpy</code>不安全、<code>strncpy</code>需补<code>&#39;\0&#39;</code>、<code>strlcpy</code>安全非标准；C++ 直接用拷贝构造 &#x2F; 赋值 &#x2F;<code>assign</code></li></ul><hr><h2 id="一、C-风格字符串（char-）"><a href="#一、C-风格字符串（char-）" class="headerlink" title="一、C 风格字符串（char[]）"></a>一、C 风格字符串（<code>char[]</code>）</h2><p>本质是<strong>以<code>&#39;\0&#39;</code>（空字符）为结束标记</strong>的字符数组，<code>&#39;\0&#39;</code>是字符串终止的核心标识。</p><h3 id="1-初始化（高频易错点）"><a href="#1-初始化（高频易错点）" class="headerlink" title="1. 初始化（高频易错点）"></a>1. 初始化（高频易错点）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 自动添加&#x27;\0&#x27;，数组长度6（h e l l o \0）</span></span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;  <span class="comment">// 手动添加&#x27;\0&#x27;，长度3</span></span><br><span class="line"><span class="type">char</span> str3[<span class="number">10</span>] = <span class="string">&quot;hi&quot;</span>;  <span class="comment">// 未初始化部分自动填&#x27;\0&#x27;，长度10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="type">char</span> str4[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;  <span class="comment">// 无&#x27;\0&#x27;，strlen会越界扫描（未定义行为）</span></span><br></pre></td></tr></table></figure><h3 id="2-核心操作函数（cstring库）"><a href="#2-核心操作函数（cstring库）" class="headerlink" title="2. 核心操作函数（cstring库）"></a>2. 核心操作函数（<code>cstring</code>库）</h3><table><thead><tr><th>函数</th><th>功能</th><th>陷阱与注意事项</th></tr></thead><tbody><tr><td><code>strlen(s)</code></td><td>计算<code>&#39;\0&#39;</code>前的字符数（不含<code>&#39;\0&#39;</code>）</td><td>无<code>&#39;\0&#39;</code>时越界扫描；返回值是<code>size_t</code>（无符号），避免与 int 比较</td></tr><tr><td><code>strcpy(dst, src)</code></td><td>拷贝<code>src</code>到<code>dst</code>（含<code>&#39;\0&#39;</code>）</td><td><code>dst</code>容量不足会溢出；无长度检查，不安全</td></tr><tr><td><code>strcat(dst, src)</code></td><td>拼接<code>src</code>到<code>dst</code>末尾</td><td>需<code>dst</code>已含<code>&#39;\0&#39;</code>；总长度超<code>dst</code>容量会溢出</td></tr><tr><td><code>strcmp(s1, s2)</code></td><td>字典序比较</td><td>返回 0 表示相等，正数<code>s1&gt;s2</code>、负数<code>s1&lt;s2</code>；不可用<code>==</code>比较字符串</td></tr></tbody></table><hr><h2 id="二、C-std-string"><a href="#二、C-std-string" class="headerlink" title="二、C++ std::string"></a>二、C++ <code>std::string</code></h2><p>动态管理的字符串类，无需手动处理<code>&#39;\0&#39;</code>，安全便捷，是 C++ 开发首选。</p><h3 id="1-核心特性"><a href="#1-核心特性" class="headerlink" title="1. 核心特性"></a>1. 核心特性</h3><ul><li>动态大小：自动扩容，支持<code>push_back</code>、<code>append</code>等操作</li><li>安全保障：<code>at()</code>方法越界抛异常，<code>[]</code>无检查（需自行确保合法）</li><li>便捷操作：重载<code>+</code>（拼接）、<code>==</code>（比较）等运算符</li><li>内存优化：小字符串优化（SSO），短字符串存栈上（无需堆分配）</li></ul><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h3><table><thead><tr><th>方法</th><th>功能</th><th>注意事项</th></tr></thead><tbody><tr><td><code>size()</code>&#x2F;<code>length()</code></td><td>返回字符数（不含<code>&#39;\0&#39;</code>）</td><td>功能完全一致，仅历史原因并存</td></tr><tr><td><code>c_str()</code>&#x2F;<code>data()</code></td><td>转为 C 风格字符串（<code>const char*</code>）</td><td>指针有效期与<code>string</code>绑定，修改<code>string</code>后可能失效</td></tr><tr><td><code>substr(pos, len)</code></td><td>提取子串（从<code>pos</code>开始，长度<code>len</code>）</td><td><code>pos</code>越界抛异常；<code>len</code>超范围则取到字符串末尾</td></tr><tr><td><code>find(sub, pos)</code></td><td>从<code>pos</code>查找<code>sub</code>，返回起始索引</td><td>未找到返回<code>string::npos</code>（需用该常量判断，而非 - 1）</td></tr><tr><td><code>reserve(n)</code></td><td>预分配<code>n</code>个字符内存</td><td>提升扩容效率，不改变<code>size</code>（实际字符数）</td></tr><tr><td><code>resize(n, c)</code></td><td>调整字符数为<code>n</code>，不足补字符<code>c</code></td><td>可能截断长字符串或填充短字符串</td></tr></tbody></table><h3 id="3-深入特性"><a href="#3-深入特性" class="headerlink" title="3. 深入特性"></a>3. 深入特性</h3><h4 id="（1）小字符串优化（SSO）"><a href="#（1）小字符串优化（SSO）" class="headerlink" title="（1）小字符串优化（SSO）"></a>（1）小字符串优化（SSO）</h4><ul><li>短字符串（通常长度≤15）：直接存储在<code>std::string</code>对象内部（栈内存），无堆分配开销。</li><li>长字符串：存储在堆内存，<code>string</code>对象仅保存指针、长度、容量信息。</li></ul><h4 id="（2）迭代器失效"><a href="#（2）迭代器失效" class="headerlink" title="（2）迭代器失效"></a>（2）迭代器失效</h4><ul><li>触发场景：<code>push_back</code>、<code>append</code>、<code>resize</code>等可能导致扩容的操作，底层内存重分配。</li><li>后果：原有迭代器、指针、引用失效（访问即未定义行为）。</li></ul><h4 id="（3）C-风格字符串转换"><a href="#（3）C-风格字符串转换" class="headerlink" title="（3）C 风格字符串转换"></a>（3）C 风格字符串转换</h4><ul><li><code>std::string</code> → C 风格：<code>c_str()</code>（返回<code>const char*</code>，不可修改）。</li><li>C 风格 → <code>std::string</code>：直接赋值（<code>string s = c_style_str;</code>），自动识别<code>&#39;\0&#39;</code>。</li></ul><hr><h2 id="三、字符串拷贝"><a href="#三、字符串拷贝" class="headerlink" title="三、字符串拷贝"></a>三、字符串拷贝</h2><h3 id="1-C-语言拷贝函数（cstring库）"><a href="#1-C-语言拷贝函数（cstring库）" class="headerlink" title="1. C 语言拷贝函数（cstring库）"></a>1. C 语言拷贝函数（<code>cstring</code>库）</h3><h4 id="（1）strcpy（基础，不安全）"><a href="#（1）strcpy（基础，不安全）" class="headerlink" title="（1）strcpy（基础，不安全）"></a>（1）<code>strcpy</code>（基础，不安全）</h4><ul><li>核心逻辑：拷贝<code>src</code>到<code>dst</code>，直到<code>&#39;\0&#39;</code>（含<code>&#39;\0&#39;</code>），无长度检查。</li><li>特点：支持链式操作；<code>dst</code>容量不足会缓冲区溢出（高危）。</li></ul><h4 id="（2）strncpy（带长度限制，需补-0-）"><a href="#（2）strncpy（带长度限制，需补-0-）" class="headerlink" title="（2）strncpy（带长度限制，需补&#39;\0&#39;）"></a>（2）<code>strncpy</code>（带长度限制，需补<code>&#39;\0&#39;</code>）</h4><ul><li>核心逻辑：最多拷贝<code>n</code>个字节；<code>src</code>长度≤<code>n</code>时补<code>&#39;\0&#39;</code>，&gt;n 时不补<code>&#39;\0&#39;</code>。</li><li>特点：降低溢出风险，但需手动确保<code>dst</code>以<code>&#39;\0&#39;</code>结尾（否则不是合法字符串）。</li></ul><h4 id="（3）strlcpy（安全首选，非标准）"><a href="#（3）strlcpy（安全首选，非标准）" class="headerlink" title="（3）strlcpy（安全首选，非标准）"></a>（3）<code>strlcpy</code>（安全首选，非标准）</h4><ul><li>核心逻辑：目标缓冲区大小<code>dest_size</code>，最多拷贝<code>dest_size-1</code>字节，强制补<code>&#39;\0&#39;</code>。</li><li>特点：完全避免溢出；返回<code>src</code>长度（不含<code>&#39;\0&#39;</code>）；非 ISO C 标准，广泛支持（Linux&#x2F;BSD）。</li></ul><h4 id="（4）memcpy（按字节拷贝，通用）"><a href="#（4）memcpy（按字节拷贝，通用）" class="headerlink" title="（4）memcpy（按字节拷贝，通用）"></a>（4）<code>memcpy</code>（按字节拷贝，通用）</h4><ul><li>核心逻辑：拷贝<code>n</code>个字节，不依赖<code>&#39;\0&#39;</code>，适用于任意数据（字符串、数组、结构体）。</li><li>字符串场景注意：需手动计算<code>src</code>长度（含<code>&#39;\0&#39;</code>），避免遗漏终止符。</li></ul><h3 id="2-C-std-string拷贝方式"><a href="#2-C-std-string拷贝方式" class="headerlink" title="2. C++ std::string拷贝方式"></a>2. C++ <code>std::string</code>拷贝方式</h3><ul><li>拷贝构造：<code>string dest(src);</code></li><li>赋值运算符：<code>string dest = src;</code></li><li><code>assign</code>方法：<code>dest.assign(src, pos, len);</code>（从<code>src</code>第<code>pos</code>位拷贝<code>len</code>个字符）</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 3. 数组与字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板基础</title>
      <link href="/posts/6bd4602e.html"/>
      <url>/posts/6bd4602e.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>核心意义：将类型作为参数，实现通用逻辑，编译期生成具体类型代码</li><li>分类：函数模板（可隐式实例化）、类模板（需显式实例化）</li><li>模板参数：类型参数（<code>typename T</code>）、非类型参数（编译期常量）</li><li>特化：全特化（所有参数指定类型）、偏特化（仅类模板支持，部分参数指定类型）</li><li>关键区别：模板有类型检查，宏无；模板支持特化 &#x2F; 重载，宏不支持</li></ul><hr><h2 id="一、模板的核心意义"><a href="#一、模板的核心意义" class="headerlink" title="一、模板的核心意义"></a>一、模板的核心意义</h2><p>通过 “类型作为参数” 脱离具体类型约束，让通用逻辑适配多种类型，编译器自动生成对应版本代码（无重复编写成本，类型安全）。</p><hr><h2 id="二、函数模板"><a href="#二、函数模板" class="headerlink" title="二、函数模板"></a>二、函数模板</h2><h3 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h3><p>生成具体函数的 “模板”，编译器根据实参类型自动实例化对应版本。</p><h3 id="关键规则"><a href="#关键规则" class="headerlink" title="关键规则"></a>关键规则</h3><ul><li>语法：<code>template&lt;模板参数列表&gt; 返回类型 函数名(参数列表) { ... }</code></li><li>实例化：<ul><li>隐式实例化：编译器根据实参推导类型（如<code>max(1,2)</code>推导<code>T=int</code>）。</li><li>显式实例化：手动指定类型（如<code>max&lt;int&gt;(1.5,2.5)</code>强制<code>T=int</code>）。</li></ul></li><li>重载：支持模板间重载（参数列表 &#x2F; 模板参数不同），非模板函数优先级高于模板函数。</li></ul><hr><h2 id="三、类模板"><a href="#三、类模板" class="headerlink" title="三、类模板"></a>三、类模板</h2><h3 id="核心定义-1"><a href="#核心定义-1" class="headerlink" title="核心定义"></a>核心定义</h3><p>生成具体类的 “模板”，用于创建与类型相关的通用类（如<code>vector</code>、<code>map</code>）。</p><h3 id="关键规则-1"><a href="#关键规则-1" class="headerlink" title="关键规则"></a>关键规则</h3><ul><li>语法：<code>template&lt;模板参数列表&gt; class 类名 { ... };</code></li><li>实例化：必须显式指定模板参数（编译器无法推导），格式<code>类名&lt;类型&gt;</code>（如<code>Vector&lt;int&gt;</code>）。</li><li>成员函数：类外定义时需保留模板参数（如<code>template&lt;typename T&gt; void Vector&lt;T&gt;::push_back(T val) { ... }</code>）。</li></ul><hr><h2 id="四、模板参数：类型参数与非类型参数"><a href="#四、模板参数：类型参数与非类型参数" class="headerlink" title="四、模板参数：类型参数与非类型参数"></a>四、模板参数：类型参数与非类型参数</h2><h3 id="1-类型参数"><a href="#1-类型参数" class="headerlink" title="1. 类型参数"></a>1. 类型参数</h3><ul><li>声明：<code>typename</code>或<code>class</code>修饰（两者等价），代表任意类型（如<code>int</code>、<code>string</code>、自定义类）。</li><li>用途：最常用，适配不同数据类型。</li></ul><h3 id="2-非类型参数"><a href="#2-非类型参数" class="headerlink" title="2. 非类型参数"></a>2. 非类型参数</h3><ul><li>定义：代表编译期常量（值在编译期可确定）。</li><li>支持类型：整数类型（<code>int</code>、<code>size_t</code>）、全局变量 &#x2F; 函数的指针 &#x2F; 引用。</li><li>限制：不支持浮点数、类对象（编译期无法确定值）。</li><li>示例语法：<code>template&lt;int N&gt; class Array { ... };</code>（<code>N</code>为编译期常量）。</li></ul><hr><h2 id="五、模板特化：定制特定类型实现"><a href="#五、模板特化：定制特定类型实现" class="headerlink" title="五、模板特化：定制特定类型实现"></a>五、模板特化：定制特定类型实现</h2><p>为特定类型提供定制化实现，覆盖泛化版本（解决泛化模板对某些类型不适用的问题）。</p><h3 id="1-全特化"><a href="#1-全特化" class="headerlink" title="1. 全特化"></a>1. 全特化</h3><ul><li>定义：为模板所有参数指定具体类型，完全覆盖泛化版本。</li><li>语法：<code>template&lt;&gt; 类名/函数名&lt;具体类型&gt; { ... };</code>（如<code>template&lt;&gt; class Vector&lt;char&gt; { ... };</code>）。</li></ul><h3 id="2-偏特化（仅类模板支持）"><a href="#2-偏特化（仅类模板支持）" class="headerlink" title="2. 偏特化（仅类模板支持）"></a>2. 偏特化（仅类模板支持）</h3><ul><li>定义：为模板部分参数指定具体类型，函数模板不支持偏特化。</li><li>语法：<code>template&lt;剩余参数列表&gt; class 类名&lt;部分指定类型&gt; { ... };</code>（如<code>template&lt;typename T&gt; class Vector&lt;T*&gt; { ... };</code>对指针类型特化）。</li></ul><hr><h2 id="六、补充关键特性"><a href="#六、补充关键特性" class="headerlink" title="六、补充关键特性"></a>六、补充关键特性</h2><h3 id="1-惰性实例化"><a href="#1-惰性实例化" class="headerlink" title="1. 惰性实例化"></a>1. 惰性实例化</h3><p>模板仅实例化被使用的成员，未使用的成员不会生成代码（减少冗余）。</p><h3 id="2-模板与宏的核心区别"><a href="#2-模板与宏的核心区别" class="headerlink" title="2. 模板与宏的核心区别"></a>2. 模板与宏的核心区别</h3><table><thead><tr><th>对比维度</th><th>模板（Template）</th><th>宏（<code>#define</code>）</th></tr></thead><tbody><tr><td>类型检查</td><td>编译期强类型检查（安全）</td><td>无类型检查（文本替换，易错）</td></tr><tr><td>调试支持</td><td>支持（可见具体实例化类型）</td><td>不支持（替换后无宏信息）</td></tr><tr><td>灵活性</td><td>支持复杂逻辑、重载、特化</td><td>仅简单文本替换（复杂逻辑易出错）</td></tr><tr><td>代码生成</td><td>编译期生成具体类型代码</td><td>预编译期替换，不生成新代码</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 5. 模板与STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型与高并发</title>
      <link href="/posts/567736fd.html"/>
      <url>/posts/567736fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>五大 IO 模型：阻塞 IO（低并发）、非阻塞 IO（忙等）、IO 多路复用（高并发核心）、信号驱动 IO（极少用）、异步 IO（理想模型）</li><li>IO 多路复用：select（位图，FD 上限 1024）、poll（动态数组，轮询）、epoll（Linux 首选，O (1) 事件驱动）</li><li>同步 vs 异步：同步需等待 IO 就绪 &#x2F; 完成（阻塞 &#x2F; 非阻塞 &#x2F; IO 多路复用），异步无需等待（内核回调通知）</li><li>高并发模型：Reactor（事件驱动）、多线程 Reactor（主线程 epoll + 子线程池处理任务）</li><li>核心选择：百万级并发选「epoll + 线程池 + ET 模式」，中高并发选「epoll&#x2F;poll + 有限线程」，低并发选「BIO + 线程池」</li></ul><hr><h2 id="一、同步-IO-与异步-IO"><a href="#一、同步-IO-与异步-IO" class="headerlink" title="一、同步 IO 与异步 IO"></a>一、同步 IO 与异步 IO</h2><h3 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h3><ul><li><strong>同步 IO</strong>：线程发起 IO 请求后，必须等待 IO 操作（就绪或数据拷贝）完成才能继续执行，线程主动参与等待过程。<ul><li>典型：阻塞 IO、非阻塞 IO、IO 多路复用（select&#x2F;poll&#x2F;epoll）。</li></ul></li><li><strong>异步 IO</strong>：线程发起 IO 请求后，无需等待，可直接执行其他任务；内核完成 “数据拷贝” 后，通过回调 &#x2F; 信号通知线程处理结果。<ul><li>典型：POSIX AIO、Windows IOCP。</li></ul></li></ul><h3 id="关键差异"><a href="#关键差异" class="headerlink" title="关键差异"></a>关键差异</h3><ul><li>同步 IO 的核心是 “线程等待 IO 就绪 &#x2F; 完成”，即使非阻塞 IO 的轮询，线程仍在主动消耗 CPU；</li><li>异步 IO 的核心是 “线程不参与 IO 等待和数据拷贝”，完全由内核处理，效率最高但兼容性差。</li><li>易错点：IO 多路复用是<strong>同步 IO</strong>（需线程主动读取就绪数据，并非内核自动推送）。</li></ul><hr><h2 id="二、五大-IO-模型详解"><a href="#二、五大-IO-模型详解" class="headerlink" title="二、五大 IO 模型详解"></a>二、五大 IO 模型详解</h2><p>IO 操作核心流程：「发起 IO 请求→等待 IO 就绪→数据拷贝」，模型差异集中在 “等待就绪” 和 “数据拷贝” 的实现方式。</p><h3 id="1-阻塞-IO（BIO）：最简单的低并发模型"><a href="#1-阻塞-IO（BIO）：最简单的低并发模型" class="headerlink" title="1. 阻塞 IO（BIO）：最简单的低并发模型"></a>1. 阻塞 IO（BIO）：最简单的低并发模型</h3><ul><li><strong>原理</strong>：线程发起 IO 请求（如<code>recv</code>&#x2F;<code>accept</code>）后，内核阻塞线程，直到数据拷贝完成（从网卡→用户缓冲区）才唤醒线程。</li><li><strong>流程</strong>：发起请求→内核阻塞线程→数据拷贝完成→线程唤醒返回。</li><li><strong>优点</strong>：实现简单，无需处理非阻塞逻辑，开发成本低。</li><li><strong>缺点</strong>：1 线程只能处理 1 连接，并发能力极差（线程阻塞期间无法做其他事）。</li><li><strong>适用场景</strong>：连接数少（千级以下）、逻辑简单的场景（如本地工具、小规模服务）。</li></ul><h3 id="2-非阻塞-IO（NIO）：轮询式低效模型"><a href="#2-非阻塞-IO（NIO）：轮询式低效模型" class="headerlink" title="2. 非阻塞 IO（NIO）：轮询式低效模型"></a>2. 非阻塞 IO（NIO）：轮询式低效模型</h3><ul><li><strong>原理</strong>：通过<code>fcntl</code>设置 Socket 为非阻塞，线程发起 IO 请求后，内核立即返回（无论数据是否就绪）；数据未就绪时返回<code>EAGAIN</code>，线程需主动轮询重试。</li><li><strong>流程</strong>：发起请求→数据未就绪→返回<code>EAGAIN</code>→轮询重试→数据就绪→数据拷贝→返回结果。</li><li><strong>优点</strong>：线程不阻塞，理论可处理多个连接。</li><li><strong>缺点</strong>：轮询导致 CPU 空转，资源利用率极低，极少单独使用。</li><li><strong>适用场景</strong>：配合 IO 多路复用使用（避免单独轮询的 CPU 浪费）。</li></ul><h3 id="3-IO-多路复用：高并发核心模型"><a href="#3-IO-多路复用：高并发核心模型" class="headerlink" title="3. IO 多路复用：高并发核心模型"></a>3. IO 多路复用：高并发核心模型</h3><ul><li><strong>原理</strong>：通过 “中间组件”（select&#x2F;poll&#x2F;epoll）管理多个 Socket（FD），线程阻塞在中间组件上，而非单个 IO 请求；任一 FD 就绪时，中间组件通知线程处理该 FD 的 IO。</li><li><strong>流程</strong>：注册 FD 到中间组件→线程阻塞在<code>epoll_wait</code>&#x2F;<code>select</code>→FD 就绪→中间组件返回就绪 FD→线程处理 IO（<code>recv</code>&#x2F;<code>send</code>）。</li><li><strong>核心优势</strong>：单线程 &#x2F; 少量线程处理大量连接（避免线程阻塞在单个 IO），CPU 利用率高。</li></ul><h4 id="三种实现对比"><a href="#三种实现对比" class="headerlink" title="三种实现对比"></a>三种实现对比</h4><table><thead><tr><th>实现</th><th>底层结构</th><th>最大 FD 限制</th><th>效率</th><th>核心缺陷</th></tr></thead><tbody><tr><td>select</td><td>位图（bitmask）</td><td>1024（固定）</td><td>O (n)（轮询）</td><td>FD 上限低、轮询开销大（高并发卡顿）</td></tr><tr><td>poll</td><td>动态数组（fdset）</td><td>无（理论）</td><td>O (n)（轮询）</td><td>轮询开销大，无 FD 上限但高并发低效</td></tr><tr><td>epoll</td><td>红黑树 + 就绪链表</td><td>无（系统限制）</td><td>O (1)（事件驱动）</td><td>仅支持 Linux（平台依赖）</td></tr></tbody></table><h4 id="epoll-核心优化"><a href="#epoll-核心优化" class="headerlink" title="epoll 核心优化"></a>epoll 核心优化</h4><ol><li><strong>事件驱动而非轮询</strong>：内核通过回调机制记录就绪 FD，无需遍历所有注册 FD，效率 O (1)。</li><li><strong>共享内存</strong>：FD 注册信息存储在内核态，避免用户态与内核态频繁数据拷贝。</li><li><strong>支持两种触发模式</strong>：<ul><li>水平触发（LT，默认）：FD 缓冲区有数据则持续通知，易用不易漏数据（适合大多数场景）。</li><li>边缘触发（ET）：仅数据 “首次到来” 时通知一次，需一次性读完缓冲区数据，效率更高（适合高并发）。</li></ul></li></ol><h3 id="4-信号驱动-IO：极少使用的模型"><a href="#4-信号驱动-IO：极少使用的模型" class="headerlink" title="4. 信号驱动 IO：极少使用的模型"></a>4. 信号驱动 IO：极少使用的模型</h3><ul><li><strong>原理</strong>：线程通过<code>sigaction</code>注册<code>SIGIO</code>信号回调，发起 IO 请求后不阻塞；IO 就绪时，内核发送信号，线程在回调中处理 IO。</li><li><strong>优点</strong>：无需轮询，CPU 利用率高。</li><li><strong>缺点</strong>：信号处理逻辑复杂（竞态、嵌套），调试困难，实际场景极少使用。</li></ul><h3 id="5-异步-IO：理想但难用的模型"><a href="#5-异步-IO：理想但难用的模型" class="headerlink" title="5. 异步 IO：理想但难用的模型"></a>5. 异步 IO：理想但难用的模型</h3><ul><li><strong>原理</strong>：线程发起 IO 请求时指定回调函数，立即返回执行其他任务；内核完成 “数据拷贝” 后，调用回调函数通知线程。</li><li><strong>流程</strong>：发起<code>aio_read</code>（指定回调）→线程执行其他任务→内核完成数据拷贝→触发回调。</li><li><strong>优点</strong>：线程完全不参与 IO 等待和数据拷贝，并发效率最高。</li><li><strong>缺点</strong>：跨平台支持差（Linux AIO 不成熟，Windows IOCP 常用），开发复杂度高。</li><li><strong>适用场景</strong>：Windows 高并发服务（如游戏服务器），Linux 场景下极少用。</li></ul><hr><h2 id="三、高并发核心模型：Reactor-模式"><a href="#三、高并发核心模型：Reactor-模式" class="headerlink" title="三、高并发核心模型：Reactor 模式"></a>三、高并发核心模型：Reactor 模式</h2><h3 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h3><ul><li>事件驱动架构：通过<code>epoll</code>监控所有 IO 事件（连接、读、写），事件就绪后分发到对应的处理器（连接处理器、读处理器、写处理器）。</li><li>核心组件：<ul><li>事件多路分发器：<code>epoll</code>，负责监控 FD 事件。</li><li>事件处理器：处理具体事件（如<code>accept</code>新连接、<code>recv</code>数据、<code>send</code>响应）。</li><li>事件队列：存储就绪事件，供分发器调度。</li></ul></li></ul><h3 id="2-多线程-Reactor（生产环境首选）"><a href="#2-多线程-Reactor（生产环境首选）" class="headerlink" title="2. 多线程 Reactor（生产环境首选）"></a>2. 多线程 Reactor（生产环境首选）</h3><ul><li><strong>架构</strong>：主线程负责<code>epoll</code>事件监控和连接建立（<code>accept</code>），新连接分配给子线程池；子线程处理 IO 读写和业务逻辑。</li><li><strong>优势</strong>：<ul><li>主线程不处理业务，避免 IO 阻塞影响事件监控。</li><li>线程池复用线程，降低线程创建 &#x2F; 切换开销。</li><li>支持百万级并发（<code>epoll</code>管理 FD + 线程池处理业务）。</li></ul></li></ul><hr><h2 id="四、高并发瓶颈与-IO-模型选择"><a href="#四、高并发瓶颈与-IO-模型选择" class="headerlink" title="四、高并发瓶颈与 IO 模型选择"></a>四、高并发瓶颈与 IO 模型选择</h2><h3 id="1-核心瓶颈"><a href="#1-核心瓶颈" class="headerlink" title="1. 核心瓶颈"></a>1. 核心瓶颈</h3><ul><li>线程阻塞：BIO 模型中线程阻塞在 IO，限制并发数。</li><li>线程切换开销：多线程模型中，大量线程切换消耗 CPU 资源。</li><li>内核态 &#x2F; 用户态拷贝：频繁数据拷贝（如 select 的 FD 集合拷贝）降低效率。</li></ul><h3 id="2-分场景-IO-模型选择"><a href="#2-分场景-IO-模型选择" class="headerlink" title="2. 分场景 IO 模型选择"></a>2. 分场景 IO 模型选择</h3><table><thead><tr><th>并发量级</th><th>推荐模型</th><th>核心原因</th></tr></thead><tbody><tr><td>百万级（如 Web&#x2F;IM）</td><td>epoll（ET 模式）+ 多线程 Reactor + 线程池</td><td>epoll O (1) 效率，ET 模式减少通知，线程池处理业务</td></tr><tr><td>万级（中高并发）</td><td>epoll&#x2F;poll + 有限线程</td><td>平衡资源开销与并发能力，无需复杂架构</td></tr><tr><td>千级以下（低并发）</td><td>BIO + 线程池</td><td>开发简单，无需复杂 IO 管理</td></tr></tbody></table><h3 id="3-高并发优化策略"><a href="#3-高并发优化策略" class="headerlink" title="3. 高并发优化策略"></a>3. 高并发优化策略</h3><ul><li>采用 epoll ET 模式：减少事件通知次数，需一次性读完缓冲区数据。</li><li>非阻塞 IO 配合 ET 模式：避免 IO 操作阻塞线程。</li><li>线程池隔离业务逻辑：主线程仅处理 IO 事件，业务逻辑交给子线程。</li><li>减少数据拷贝：使用内存池、零拷贝技术（如<code>sendfile</code>）。</li></ul><hr><h2 id="五、问答"><a href="#五、问答" class="headerlink" title="五、问答"></a>五、问答</h2><h3 id="1-epoll-的-LT-和-ET-模式有什么区别？"><a href="#1-epoll-的-LT-和-ET-模式有什么区别？" class="headerlink" title="1. epoll 的 LT 和 ET 模式有什么区别？"></a>1. epoll 的 LT 和 ET 模式有什么区别？</h3><ul><li>LT（水平触发）：FD 缓冲区有数据则持续通知，直到数据读完；易用，不会漏数据，默认模式。</li><li>ET（边缘触发）：仅数据 “首次到来” 时通知一次，需一次性读完缓冲区；效率高，减少通知次数，适合高并发，但需处理非阻塞 IO 避免漏读。</li></ul><h3 id="2-为什么-IO-多路复用是同步-IO-而非异步-IO？"><a href="#2-为什么-IO-多路复用是同步-IO-而非异步-IO？" class="headerlink" title="2. 为什么 IO 多路复用是同步 IO 而非异步 IO？"></a>2. 为什么 IO 多路复用是同步 IO 而非异步 IO？</h3><p>因为 IO 多路复用仅解决 “等待 IO 就绪” 的阻塞问题，线程仍需主动调用<code>recv</code>&#x2F;<code>send</code>完成数据拷贝（IO 操作的核心步骤）；异步 IO 的核心是内核自动完成数据拷贝并通知线程，线程无需参与 IO 操作。</p><h3 id="3-epoll-比-select-poll-高效的原因是什么？"><a href="#3-epoll-比-select-poll-高效的原因是什么？" class="headerlink" title="3. epoll 比 select&#x2F;poll 高效的原因是什么？"></a>3. epoll 比 select&#x2F;poll 高效的原因是什么？</h3><ul><li>事件驱动而非轮询：无需遍历所有注册 FD，仅处理就绪事件。</li><li>共享内存：FD 注册信息存储在内核，避免用户态与内核态频繁拷贝。</li><li>无 FD 上限：红黑树存储 FD，支持海量连接（仅受系统资源限制）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 9. 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
            <tag> IO模型 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元与运算符重载</title>
      <link href="/posts/6ea8b1ca.html"/>
      <url>/posts/6ea8b1ca.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>友元：打破封装，允许外部函数 &#x2F; 类访问类的私有 &#x2F; 保护成员（分友元函数、友元类、友元成员函数）</li><li>运算符重载：自定义类型的运算规则，不可重载 6 个运算符，支持成员函数 &#x2F; 友元函数两种形式</li><li>特殊重载：赋值运算符<code>=</code>只能作为成员函数；<code>&lt;&lt;</code>&#x2F;<code>&gt;&gt;</code>需作为友元函数</li></ul><hr><h2 id="一、友元：打破封装的特殊访问机制"><a href="#一、友元：打破封装的特殊访问机制" class="headerlink" title="一、友元：打破封装的特殊访问机制"></a>一、友元：打破封装的特殊访问机制</h2><p>友元的核心是 “让外部实体获得类的特殊访问权限”，可访问私有（<code>private</code>）和保护（<code>protected</code>）成员，代价是削弱封装性。</p><h3 id="1-友元的种类"><a href="#1-友元的种类" class="headerlink" title="1. 友元的种类"></a>1. 友元的种类</h3><h4 id="（1）友元函数"><a href="#（1）友元函数" class="headerlink" title="（1）友元函数"></a>（1）友元函数</h4><ul><li><p>声明方式：类内用<code>friend</code>声明，定义可在类外（非成员函数，无<code>this</code>指针）。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 友元函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printA</span><span class="params">(A&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 友元函数定义（类外），可直接访问私有成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; obj.num &lt;&lt; endl; <span class="comment">// 合法：访问A的private成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关键：访问类成员时需显式传递对象参数（无<code>this</code>指针）。</p></li></ul><h4 id="（2）友元类"><a href="#（2）友元类" class="headerlink" title="（2）友元类"></a>（2）友元类</h4><ul><li><p>声明方式：类内用<code>friend class 类名;</code>，目标类的所有成员函数均可访问当前类私有成员。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 声明B为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessA</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; obj.num &lt;&lt; endl; <span class="comment">// 合法：B的成员函数访问A的private成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）友元成员函数"><a href="#（3）友元成员函数" class="headerlink" title="（3）友元成员函数"></a>（3）友元成员函数</h4><ul><li><p>声明方式：指定类的某个成员函数作为友元，更精准控制访问权限。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 声明B的show()函数为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::show</span><span class="params">(A&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(A&amp; obj)</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// B的show()函数定义，可访问A的private成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::show</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; obj.num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-友元的关键特性"><a href="#2-友元的关键特性" class="headerlink" title="2. 友元的关键特性"></a>2. 友元的关键特性</h3><ul><li>不可传递性：A 是 B 的友元，B 是 C 的友元，不代表 A 是 C 的友元。</li><li>单向性：A 声明 B 为友元，仅 B 能访问 A，A 不能访问 B。</li><li>声明位置无关：友元声明可放在类的 public&#x2F;private&#x2F;protected 任意区域，效果一致。</li></ul><hr><h2 id="二、运算符重载：自定义类型的运算规则"><a href="#二、运算符重载：自定义类型的运算规则" class="headerlink" title="二、运算符重载：自定义类型的运算规则"></a>二、运算符重载：自定义类型的运算规则</h2><p>运算符重载是赋予自定义类型（类 &#x2F; 结构体）运算符（如<code>+</code>、<code>==</code>）的运算能力，语法为<code>返回类型 operator运算符(参数列表)</code>。</p><h3 id="1-重载核心规则"><a href="#1-重载核心规则" class="headerlink" title="1. 重载核心规则"></a>1. 重载核心规则</h3><ol><li>不可重载的 6 个运算符（固定，面试高频）：<ul><li><code>.</code>（成员访问）、<code>.*</code>（成员指针访问）、<code>::</code>（作用域解析）、<code>sizeof</code>（大小计算）、<code>?:</code>（三目运算符）、<code>typeid</code>（类型信息）。</li></ul></li><li>不可改变的特性：运算符的优先级、结合性、操作数个数。</li><li>必须包含至少一个自定义类型操作数（避免重载内置类型运算）。</li></ol><h3 id="2-两种重载形式"><a href="#2-两种重载形式" class="headerlink" title="2. 两种重载形式"></a>2. 两种重载形式</h3><h4 id="（1）成员函数重载"><a href="#（1）成员函数重载" class="headerlink" title="（1）成员函数重载"></a>（1）成员函数重载</h4><ul><li><p>核心：左侧操作数为当前类对象（隐含<code>this</code>指针），参数列表只需传入右侧操作数。</p></li><li><p>适用场景：左侧操作数是当前类对象（如<code>a + b</code>，a 是当前类对象）。</p></li><li><p>示例（重载<code>+</code>）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x=<span class="number">0</span>, <span class="type">int</span> y=<span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 成员函数重载+：this指向左侧操作数</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + rhs.x, y + rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用：左侧a是this指针指向的对象</span></span><br><span class="line"><span class="function">Point <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">Point c = a + b; <span class="comment">// 等价于a.operator+(b)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）友元函数重载"><a href="#（2）友元函数重载" class="headerlink" title="（2）友元函数重载"></a>（2）友元函数重载</h4><ul><li><p>核心：无<code>this</code>指针，需显式传入所有操作数（左侧 + 右侧）。</p></li><li><p>适用场景：左侧操作数不是当前类对象（如<code>cout &lt;&lt; a</code>，左侧是<code>ostream</code>对象）。</p></li><li><p>示例（重载<code>&lt;&lt;</code>，输出自定义类型）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x=<span class="number">0</span>, <span class="type">int</span> y=<span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 友元函数重载&lt;&lt;：需访问私有成员，且左侧是ostream</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os; <span class="comment">// 支持链式输出（cout &lt;&lt; a &lt;&lt; b）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用：os=cout，p=a</span></span><br><span class="line"><span class="function">Point <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a; <span class="comment">// 等价于operator&lt;&lt;(cout, a)，输出(1,2)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-特殊重载：赋值运算符"><a href="#3-特殊重载：赋值运算符" class="headerlink" title="3. 特殊重载：赋值运算符="></a>3. 特殊重载：赋值运算符<code>=</code></h3><ul><li><p>核心规则：只能作为成员函数（编译器默认生成，执行浅拷贝）。</p></li><li><p>深拷贝需求：当类包含动态资源（如指针）时，需手动重写，避免双重释放。</p></li><li><p>示例（深拷贝赋值运算符）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 赋值运算符重载（成员函数）</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 处理自我赋值</span></span><br><span class="line">        <span class="keyword">delete</span>[] str; <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="comment">// 深拷贝：重新分配内存</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 支持链式赋值（a = b = c）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 4. 面向对象编程OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 友元 </tag>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL基础</title>
      <link href="/posts/6e08d78f.html"/>
      <url>/posts/6e08d78f.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>核心组件：容器（存储数据）、算法（操作数据）、迭代器（容器与算法桥梁）、仿函数（自定义逻辑）、适配器（接口转换）</li><li>容器分类：序列式（vector&#x2F;list&#x2F;deque）、关联式（map&#x2F;set 等，红黑树 &#x2F; 哈希表实现）、适配器（stack&#x2F;queue&#x2F;priority_queue）</li><li>关键考点：容器底层实现、迭代器失效场景、容器选型对比、算法适用条件</li></ul><hr><h2 id="一、STL-核心组件"><a href="#一、STL-核心组件" class="headerlink" title="一、STL 核心组件"></a>一、STL 核心组件</h2><ol><li><strong>容器（Containers）</strong>：类模板，封装数据结构（如 vector、map），用于存储数据。</li><li><strong>算法（Algorithms）</strong>：函数模板，实现通用操作（如 sort、find），通过迭代器操作容器。</li><li><strong>迭代器（Iterators）</strong>：类似指针的对象，提供容器元素访问接口，是容器与算法的桥梁。</li><li><strong>仿函数（Functors）</strong>：重载<code>operator()</code>的类 &#x2F; 结构体（函数对象），用于算法自定义逻辑（如比较、谓词）。</li><li><strong>适配器（Adapters）</strong>：转换已有组件接口（如 stack&#x2F;queue 基于 deque 适配，priority_queue 基于 vector 适配）。</li></ol><hr><h2 id="二、容器：分类与核心特性"><a href="#二、容器：分类与核心特性" class="headerlink" title="二、容器：分类与核心特性"></a>二、容器：分类与核心特性</h2><p>容器按存储结构分为序列式、关联式、适配器三类，核心考察底层实现、操作效率、适用场景。</p><h3 id="1-序列式容器（元素有序，依赖位置）"><a href="#1-序列式容器（元素有序，依赖位置）" class="headerlink" title="1. 序列式容器（元素有序，依赖位置）"></a>1. 序列式容器（元素有序，依赖位置）</h3><h4 id="vector：动态数组"><a href="#vector：动态数组" class="headerlink" title="vector：动态数组"></a>vector：动态数组</h4><ul><li>底层实现：连续动态数组，内存地址连续。</li><li>核心特性：<ul><li>随机访问高效（<code>[]</code>&#x2F;<code>at()</code>，<code>O(1)</code>）；尾部增删高效（<code>push_back()</code>&#x2F;<code>pop_back()</code>，<code>O(1)</code>）。</li><li>动态扩容：容量不足时申请 1.5&#x2F;2 倍新内存，拷贝旧元素（扩容成本高）。</li><li>中间 &#x2F; 头部增删低效（需移动元素，<code>O(n)</code>）。</li></ul></li><li>关键接口：<code>reserve(n)</code>（预分配内存，不改变 size）、<code>resize(n, val)</code>（调整 size，可能扩容）、<code>erase(iter)</code>（返回下一个有效迭代器）。</li><li>适用场景：频繁随机访问、尾部增删（如列表数据、缓存）。</li></ul><h4 id="list：双向链表"><a href="#list：双向链表" class="headerlink" title="list：双向链表"></a>list：双向链表</h4><ul><li>底层实现：双向链表（节点含数据、前驱 &#x2F; 后继指针），内存不连续。</li><li>核心特性：<ul><li>随机访问低效（遍历，<code>O(n)</code>），不支持<code>[]</code>访问。</li><li>任意位置增删高效（修改指针，<code>O(1)</code>，需先定位）。</li><li>迭代器为双向迭代器（支持<code>++</code>&#x2F;<code>--</code>，不支持<code>+n</code>）。</li></ul></li><li>适用场景：频繁中间增删（如链表、非 FIFO 队列）。</li></ul><h4 id="deque：双端队列"><a href="#deque：双端队列" class="headerlink" title="deque：双端队列"></a>deque：双端队列</h4><ul><li>底层实现：分段连续动态数组（多个缓冲区 + 中控器指针数组）。</li><li>核心特性：<ul><li>头尾增删高效（<code>push_front()</code>&#x2F;<code>pop_front()</code>，<code>O(1)</code>）。</li><li>随机访问效率：高于 list，低于 vector（<code>O(1)</code>，需中控器定位）。</li><li>扩容成本低于 vector（新增缓冲区，无需拷贝全部元素）。</li></ul></li><li>适用场景：双端操作队列（如 BFS 队列）。</li></ul><h3 id="2-关联式容器（元素无序，依赖键值）"><a href="#2-关联式容器（元素无序，依赖键值）" class="headerlink" title="2. 关联式容器（元素无序，依赖键值）"></a>2. 关联式容器（元素无序，依赖键值）</h3><p>分为有序（红黑树）和无序（哈希表）两类，核心考察查找效率、有序性、内存占用。</p><h4 id="有序关联容器（红黑树实现，O-logn-操作）"><a href="#有序关联容器（红黑树实现，O-logn-操作）" class="headerlink" title="有序关联容器（红黑树实现，O(logn)操作）"></a>有序关联容器（红黑树实现，<code>O(logn)</code>操作）</h4><ul><li>包含：<code>set</code>（唯一键）、<code>multiset</code>（键可重复）、<code>map</code>（键值对，键唯一）、<code>multimap</code>（键可重复）。</li><li>核心特性：<ul><li>按键升序排列（默认<code>less&lt;Key&gt;</code>），支持范围查询（<code>lower_bound</code>&#x2F;<code>upper_bound</code>）。</li><li>迭代器为双向迭代器，遍历有序。</li><li>插入 &#x2F; 删除 &#x2F; 查找时间复杂度稳定<code>O(logn)</code>。</li></ul></li></ul><h4 id="无序关联容器（哈希表实现，平均O-1-操作）"><a href="#无序关联容器（哈希表实现，平均O-1-操作）" class="headerlink" title="无序关联容器（哈希表实现，平均O(1)操作）"></a>无序关联容器（哈希表实现，平均<code>O(1)</code>操作）</h4><ul><li>包含：<code>unordered_set</code>（唯一键）、<code>unordered_multiset</code>（键可重复）、<code>unordered_map</code>（键值对，键唯一）、<code>unordered_multimap</code>（键可重复）。</li><li>核心特性：<ul><li>元素无序，迭代器为前向迭代器（仅支持<code>++</code>）。</li><li>平均插入 &#x2F; 删除 &#x2F; 查找<code>O(1)</code>，最坏<code>O(n)</code>（哈希冲突严重）。</li><li>自定义键需特化<code>std::hash</code>哈希函数。</li></ul></li></ul><h4 id="map-vs-unordered-map"><a href="#map-vs-unordered-map" class="headerlink" title="map vs unordered_map"></a><code>map</code> vs <code>unordered_map</code></h4><table><thead><tr><th>对比维度</th><th>map（红黑树）</th><th>unordered_map（哈希表）</th></tr></thead><tbody><tr><td>查找效率</td><td><code>O(logn)</code>（稳定）</td><td>平均<code>O(1)</code>，最坏<code>O(n)</code></td></tr><tr><td>内存占用</td><td>较低（仅键值对 + 树结构）</td><td>较高（哈希表需额外空间解决冲突）</td></tr><tr><td>有序性</td><td>支持（按键升序）</td><td>不支持</td></tr><tr><td>迭代器类型</td><td>双向迭代器（<code>++</code>&#x2F;<code>--</code>）</td><td>前向迭代器（仅<code>++</code>）</td></tr><tr><td>适用场景</td><td>有序遍历、范围查询</td><td>频繁查找，不关心顺序</td></tr></tbody></table><h3 id="3-容器适配器（接口转换）"><a href="#3-容器适配器（接口转换）" class="headerlink" title="3. 容器适配器（接口转换）"></a>3. 容器适配器（接口转换）</h3><ul><li><code>stack</code>：栈（LIFO），默认底层<code>deque</code>，接口：<code>push()</code>&#x2F;<code>pop()</code>&#x2F;<code>top()</code>。</li><li><code>queue</code>：队列（FIFO），默认底层<code>deque</code>，接口：<code>push()</code>&#x2F;<code>pop()</code>&#x2F;<code>front()</code>&#x2F;<code>back()</code>。</li><li><code>priority_queue</code>：优先队列（最大堆），底层<code>vector</code>+ 堆算法，接口：<code>push()</code>&#x2F;<code>pop()</code>&#x2F;<code>top()</code>。</li></ul><hr><h2 id="三、迭代器：类型与失效"><a href="#三、迭代器：类型与失效" class="headerlink" title="三、迭代器：类型与失效"></a>三、迭代器：类型与失效</h2><h3 id="1-迭代器类型（按功能划分）"><a href="#1-迭代器类型（按功能划分）" class="headerlink" title="1. 迭代器类型（按功能划分）"></a>1. 迭代器类型（按功能划分）</h3><table><thead><tr><th>迭代器类型</th><th>支持操作（除<code>++</code>外）</th><th>对应容器示例</th></tr></thead><tbody><tr><td>输入迭代器</td><td><code>*</code>（读）、<code>==</code>&#x2F;<code>!=</code></td><td><code>istream_iterator</code></td></tr><tr><td>输出迭代器</td><td><code>*</code>（写）</td><td><code>ostream_iterator</code></td></tr><tr><td>前向迭代器</td><td>输入 + 输出功能，支持多遍访问</td><td><code>unordered_set</code>&#x2F;<code>unordered_map</code></td></tr><tr><td>双向迭代器</td><td>前向功能 +<code>--</code></td><td><code>list</code>、<code>map</code>、<code>set</code></td></tr><tr><td>随机访问迭代器</td><td>双向功能 +<code>+n</code>&#x2F;<code>-n</code>&#x2F;<code>[]</code></td><td><code>vector</code>、<code>deque</code>、数组</td></tr></tbody></table><h3 id="2-迭代器失效场景"><a href="#2-迭代器失效场景" class="headerlink" title="2. 迭代器失效场景"></a>2. 迭代器失效场景</h3><h4 id="vector-迭代器失效"><a href="#vector-迭代器失效" class="headerlink" title="vector 迭代器失效"></a>vector 迭代器失效</h4><ul><li>插入（<code>push_back</code>&#x2F;<code>insert</code>）：扩容则所有迭代器失效；未扩容则插入位置及之后失效。</li><li>删除（<code>erase</code>）：删除位置及之后失效，需用<code>iter = vec.erase(iter)</code>更新迭代器。</li></ul><h4 id="list-迭代器失效"><a href="#list-迭代器失效" class="headerlink" title="list 迭代器失效"></a>list 迭代器失效</h4><ul><li>插入：迭代器不失效（仅修改指针）。</li><li>删除：仅被删除元素的迭代器失效，其余有效。</li></ul><h4 id="map-set-迭代器失效"><a href="#map-set-迭代器失效" class="headerlink" title="map&#x2F;set 迭代器失效"></a>map&#x2F;set 迭代器失效</h4><ul><li>插入：迭代器不失效（红黑树调整不改变节点地址）。</li><li>删除：仅被删除节点的迭代器失效，其余有效。</li></ul><hr><h2 id="四、算法：常用算法与适用条件"><a href="#四、算法：常用算法与适用条件" class="headerlink" title="四、算法：常用算法与适用条件"></a>四、算法：常用算法与适用条件</h2><h3 id="1-核心算法"><a href="#1-核心算法" class="headerlink" title="1. 核心算法"></a>1. 核心算法</h3><ul><li><strong>排序</strong>：<code>sort(first, last)</code>，需随机访问迭代器（<code>vector</code>&#x2F;<code>deque</code>），底层是 introsort（快排 + 堆排 + 插入排序）。<ul><li>注意：<code>list</code>不支持<code>std::sort</code>，需用成员函数<code>list::sort()</code>。</li></ul></li><li><strong>查找</strong>：<ul><li><code>find(first, last, val)</code>：线性查找（<code>O(n)</code>），支持所有迭代器。</li><li><code>binary_search(first, last, val)</code>：二分查找（<code>O(logn)</code>），需有序序列 + 随机访问 &#x2F; 双向迭代器。</li></ul></li><li><strong>遍历</strong>：<code>for_each(first, last, func)</code>，对元素执行<code>func</code>（函数 &#x2F; 仿函数）。</li><li><strong>删除</strong>：<code>remove(first, last, val)</code>（逻辑删除，移动元素），需配合<code>erase</code>真正删除：<code>container.erase(remove(...), container.end())</code>。</li></ul><h3 id="2-仿函数（函数对象）"><a href="#2-仿函数（函数对象）" class="headerlink" title="2. 仿函数（函数对象）"></a>2. 仿函数（函数对象）</h3><ul><li>定义：重载<code>operator()</code>的类 &#x2F; 结构体，可携带状态，比函数指针灵活。</li><li>用途：算法中传递自定义逻辑（如<code>sort</code>的比较规则、<code>find_if</code>的筛选条件）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 5. 模板与STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核心问题与机制</title>
      <link href="/posts/739aa5fc.html"/>
      <url>/posts/739aa5fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>字节序：主机序（小端 &#x2F; 大端）→ 网络序（大端），转换函数<code>htons()</code>&#x2F;<code>ntohs()</code>、<code>htonl()</code>&#x2F;<code>ntohl()</code></li><li>TCP 核心问题：粘包 &#x2F; 半包（流式无边界），解决方案：固定长度、分隔符、消息头 + 消息体（最常用）</li><li>UDP 特性：无粘包、可能丢包、数据报大小受限，读写用<code>sendto()</code>&#x2F;<code>recvfrom()</code></li><li>并发模型：多线程 &#x2F; 多进程（简单低并发）、I&#x2F;O 多路复用（epoll 核心，高并发）、线程池 &#x2F; 进程池（平衡开销）</li><li>可靠性保障：超时（<code>SO_RCVTIMEO</code>）、心跳（应用层 &#x2F; TCP keepalive）、重连（指数退避）</li><li>序列化：Protobuf&#x2F;FlatBuffers（高性能）、JSON&#x2F;XML（可读性）、自定义二进制（紧凑）</li><li>安全防护：SYN 洪水（SYN Cookie）、数据加密（SSL&#x2F;TLS）、限流（防火墙 &#x2F; 应用层）</li></ul><hr><h2 id="一、字节序转换（跨平台通信基础）"><a href="#一、字节序转换（跨平台通信基础）" class="headerlink" title="一、字节序转换（跨平台通信基础）"></a>一、字节序转换（跨平台通信基础）</h2><ul><li><strong>主机字节序</strong>：CPU 存储数据的方式，分小端（低字节存低地址，主流架构）和大端（低字节存高地址）。</li><li><strong>网络字节序</strong>：统一为大端（避免跨平台差异），所有网络传输数据需转换为此格式。</li><li><strong>核心转换函数</strong>：<ul><li>短整型（2 字节）：<code>htons()</code>（主机→网络）、<code>ntohs()</code>（网络→主机）</li><li>长整型（4 字节）：<code>htonl()</code>（主机→网络）、<code>ntohl()</code>（网络→主机）</li></ul></li></ul><hr><h2 id="二、TCP-粘包与半包问题"><a href="#二、TCP-粘包与半包问题" class="headerlink" title="二、TCP 粘包与半包问题"></a>二、TCP 粘包与半包问题</h2><p>TCP 是<strong>字节流协议</strong>（无消息边界），导致接收方无法直接区分完整消息。</p><h3 id="1-问题成因"><a href="#1-问题成因" class="headerlink" title="1. 问题成因"></a>1. 问题成因</h3><ul><li><strong>粘包</strong>：Nagle 算法合并小数据包、接收方缓冲区未及时读取，多个消息合并为一个 TCP 报文。</li><li><strong>半包</strong>：消息超过 MSS（最大报文段长度）被拆分、接收方缓冲区不足，一个消息仅读取部分数据。</li></ul><h3 id="2-解决方案（应用层定义消息边界）"><a href="#2-解决方案（应用层定义消息边界）" class="headerlink" title="2. 解决方案（应用层定义消息边界）"></a>2. 解决方案（应用层定义消息边界）</h3><table><thead><tr><th>方案类型</th><th>核心逻辑</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>固定长度消息</td><td>约定每个消息长度固定，接收方按固定长度读取</td><td>实现简单</td><td>灵活性差，消息长度不确定时浪费带宽</td></tr><tr><td>分隔符标记</td><td>用特殊字符（如<code>\r\n</code>）作为消息结束标记</td><td>灵活，无需预设长度</td><td>需处理消息内容包含分隔符的情况</td></tr><tr><td>消息头 + 消息体</td><td>4 字节消息头存储消息体长度，先读头再读体</td><td>通用、灵活，无冗余</td><td>需额外解析消息头，逻辑稍复杂</td></tr></tbody></table><ul><li>最常用：<strong>消息头 + 消息体</strong>（兼顾灵活性和效率）。</li></ul><hr><h2 id="三、UDP-数据报（无连接传输）"><a href="#三、UDP-数据报（无连接传输）" class="headerlink" title="三、UDP 数据报（无连接传输）"></a>三、UDP 数据报（无连接传输）</h2><h3 id="1-核心特性"><a href="#1-核心特性" class="headerlink" title="1. 核心特性"></a>1. 核心特性</h3><ul><li>无连接、无粘包（数据报独立传输）、不可靠（可能丢包、乱序）。</li><li>数据报大小受限（通常不超过 MTU，约 1500 字节），超出会被分片或丢弃。</li></ul><h3 id="2-关键读写函数"><a href="#2-关键读写函数" class="headerlink" title="2. 关键读写函数"></a>2. 关键读写函数</h3><ul><li><code>sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen)</code>：指定目标地址发送数据。</li><li><code>recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen)</code>：接收数据并获取源地址。</li></ul><hr><h2 id="四、并发连接处理（服务器高并发核心）"><a href="#四、并发连接处理（服务器高并发核心）" class="headerlink" title="四、并发连接处理（服务器高并发核心）"></a>四、并发连接处理（服务器高并发核心）</h2><h3 id="1-常见并发模型对比"><a href="#1-常见并发模型对比" class="headerlink" title="1. 常见并发模型对比"></a>1. 常见并发模型对比</h3><table><thead><tr><th>模型类型</th><th>核心原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>多线程 &#x2F; 多进程（每连接一个）</td><td>为每个连接创建独立线程 &#x2F; 进程处理</td><td>实现简单，无共享状态问题</td><td>资源开销大，支持并发数有限（几千）</td><td>连接数少、逻辑复杂（如数据库连接）</td></tr><tr><td>I&#x2F;O 多路复用（select&#x2F;poll&#x2F;epoll）</td><td>单线程管理多个连接，仅处理有事件的连接</td><td>资源开销低，支持高并发（百万级）</td><td>逻辑复杂，需处理非阻塞 I&#x2F;O</td><td>Web 服务器、即时通讯等高并发场景</td></tr><tr><td>线程池 &#x2F; 进程池</td><td>预先创建固定线程 &#x2F; 进程，分配连接处理</td><td>平衡资源开销与并发能力</td><td>线程数固定，极端情况可能瓶颈</td><td>中等并发、连接生命周期短的场景</td></tr></tbody></table><h3 id="2-epoll-核心优势（Linux-高并发首选）"><a href="#2-epoll-核心优势（Linux-高并发首选）" class="headerlink" title="2. epoll 核心优势（Linux 高并发首选）"></a>2. epoll 核心优势（Linux 高并发首选）</h3><ul><li>事件驱动而非轮询：仅通知就绪连接，效率 O (1)（select&#x2F;poll 为 O (n)）。</li><li>共享内存：fd 集合存储在内核，避免用户态与内核态频繁拷贝。</li><li>支持两种触发模式：<ul><li>水平触发（LT，默认）：缓冲区有数据则持续通知，易用不易漏。</li><li>边缘触发（ET）：仅数据到来时通知一次，需一次性读完缓冲区，效率更高。</li></ul></li></ul><hr><h2 id="五、连接可靠性保障（避免-“假死”-连接）"><a href="#五、连接可靠性保障（避免-“假死”-连接）" class="headerlink" title="五、连接可靠性保障（避免 “假死” 连接）"></a>五、连接可靠性保障（避免 “假死” 连接）</h2><h3 id="1-超时处理"><a href="#1-超时处理" class="headerlink" title="1. 超时处理"></a>1. 超时处理</h3><ul><li>问题：<code>recv()</code>&#x2F;<code>send()</code>默认阻塞，连接异常时可能永久阻塞。</li><li>解决方案：用<code>setsockopt()</code>设置超时参数（<code>SO_RCVTIMEO</code>接收超时、<code>SO_SNDTIMEO</code>发送超时），或结合<code>epoll_wait()</code>的超时参数。</li></ul><h3 id="2-心跳机制（检测连接存活）"><a href="#2-心跳机制（检测连接存活）" class="headerlink" title="2. 心跳机制（检测连接存活）"></a>2. 心跳机制（检测连接存活）</h3><ul><li>原理：定期发送心跳包，未收到回应则判定连接失效。</li><li>实现方式：<ul><li>应用层心跳：业务协议中加入固定格式心跳包（如每 30 秒发送，5 秒未回应断连）。</li><li>TCP keepalive：内核层定期发送探测包，默认超时较长（需调整参数）。</li></ul></li></ul><h3 id="3-断连重连（客户端）"><a href="#3-断连重连（客户端）" class="headerlink" title="3. 断连重连（客户端）"></a>3. 断连重连（客户端）</h3><ul><li>核心策略：指数退避（重连间隔 1s→2s→4s→…→上限 60s），避免频繁重试冲击服务器。</li><li>限制：超过最大重试次数后报警（如网络彻底故障）。</li></ul><hr><h2 id="六、数据序列化与反序列化（跨平台传输）"><a href="#六、数据序列化与反序列化（跨平台传输）" class="headerlink" title="六、数据序列化与反序列化（跨平台传输）"></a>六、数据序列化与反序列化（跨平台传输）</h2><h3 id="核心要求：跨平台兼容、效率、可读性"><a href="#核心要求：跨平台兼容、效率、可读性" class="headerlink" title="核心要求：跨平台兼容、效率、可读性"></a>核心要求：跨平台兼容、效率、可读性</h3><table><thead><tr><th>方案类型</th><th>核心特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>自定义二进制格式</td><td>手动打包 &#x2F; 解析，处理大小端</td><td>紧凑高效，字节流小</td><td>开发复杂，兼容性差</td><td>对效率要求极高、协议固定的场景</td></tr><tr><td>JSON&#x2F;XML（文本格式）</td><td>文本标记数据结构</td><td>可读性好，跨平台性强</td><td>冗余大，解析效率低</td><td>调试友好、数据量小的场景</td></tr><tr><td>Protobuf&#x2F;FlatBuffers</td><td>IDL 定义结构，自动生成代码（二进制）</td><td>效率高，支持版本兼容</td><td>可读性差，需工具解析</td><td>高性能场景（游戏、分布式系统）</td></tr></tbody></table><hr><h2 id="七、网络安全与攻击防护（面试高频）"><a href="#七、网络安全与攻击防护（面试高频）" class="headerlink" title="七、网络安全与攻击防护（面试高频）"></a>七、网络安全与攻击防护（面试高频）</h2><h3 id="1-SYN-洪水攻击"><a href="#1-SYN-洪水攻击" class="headerlink" title="1. SYN 洪水攻击"></a>1. SYN 洪水攻击</h3><ul><li>原理：攻击者发送大量<code>SYN</code>报文但不完成三次握手，耗尽服务器半连接队列资源。</li><li>防护：开启 SYN Cookie（服务器用 Cookie 验证请求合法性，不维护半连接队列）。</li></ul><h3 id="2-数据传输加密"><a href="#2-数据传输加密" class="headerlink" title="2. 数据传输加密"></a>2. 数据传输加密</h3><ul><li>方案：用 SSL&#x2F;TLS 协议（如 HTTPS）对传输数据加密，避免明文被窃听或篡改。</li></ul><h3 id="3-端口扫描与限流"><a href="#3-端口扫描与限流" class="headerlink" title="3. 端口扫描与限流"></a>3. 端口扫描与限流</h3><ul><li>防护：防火墙限制异常 IP 连接频率，或应用层实现限流（如单 IP 每秒最多 10 次连接）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 9. 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
            <tag> 问题 </tag>
            
            <tag> 机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="/posts/91149a63.html"/>
      <url>/posts/91149a63.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>协议栈：TCP&#x2F;IP 四层模型（应用层→传输层→网络层→数据链路层）</li><li>TCP vs UDP：TCP 面向连接、可靠流式；UDP 无连接、高效数据报</li><li>三次握手：建立 TCP 连接，确保双方收发能力正常；四次挥手：断开连接，释放全双工通道</li><li>TIME_WAIT：客户端第四次挥手后停留 2MSL，确保 ACK 送达、旧报文失效</li><li>Socket：网络编程接口，由 “IP + 端口” 唯一标识，TCP 需按固定流程（绑定 - 监听 - 连接 - 收发）编程</li></ul><hr><h2 id="一、TCP-IP-四层模型"><a href="#一、TCP-IP-四层模型" class="headerlink" title="一、TCP&#x2F;IP 四层模型"></a>一、TCP&#x2F;IP 四层模型</h2><ul><li>应用层：提供具体业务协议（HTTP、FTP、DNS），定义数据格式和交互逻辑</li><li>传输层：TCP&#x2F;UDP，负责端到端（进程间）数据传输（可靠 &#x2F; 高效）</li><li>网络层：IP 协议，负责跨网络路由转发（寻址）</li><li>数据链路层：处理物理介质上的帧传输（如以太网帧）</li></ul><hr><h2 id="二、TCP-与-UDP-核心对比"><a href="#二、TCP-与-UDP-核心对比" class="headerlink" title="二、TCP 与 UDP 核心对比"></a>二、TCP 与 UDP 核心对比</h2><table><thead><tr><th>对比维度</th><th>TCP（传输控制协议）</th><th>UDP（用户数据报协议）</th></tr></thead><tbody><tr><td>连接性</td><td>面向连接（三次握手建连，四次挥手断连）</td><td>无连接（直接发送，无需建连）</td></tr><tr><td>可靠性</td><td>可靠（重传、序列号、确认、滑动窗口、拥塞控制）</td><td>不可靠（无重传，可能丢包 &#x2F; 乱序）</td></tr><tr><td>传输速率</td><td>低（含确认、重传等额外开销）</td><td>高（无额外开销，仅传输数据）</td></tr><tr><td>数据形式</td><td>字节流（无边界，需应用层定义分割）</td><td>数据报（有边界，一次收发一个完整报文）</td></tr><tr><td>拥塞控制</td><td>有（避免网络过载）</td><td>无（可能导致网络拥塞）</td></tr><tr><td>适用场景</td><td>文件传输、HTTP、邮件（需可靠性）</td><td>实时通信（视频 &#x2F; 语音）、DNS（需实时性）</td></tr></tbody></table><h3 id="1-TCP：面向连接的可靠传输"><a href="#1-TCP：面向连接的可靠传输" class="headerlink" title="1. TCP：面向连接的可靠传输"></a>1. TCP：面向连接的可靠传输</h3><ul><li>核心特性：<ul><li>面向连接：通信前必须通过三次握手建立连接，结束后通过四次挥手断开。</li><li>可靠保障：通过<strong>序列号</strong>（保证有序）、<strong>确认应答</strong>（ACK，确保接收）、<strong>重传机制</strong>（丢失重发）、<strong>滑动窗口</strong>（流量控制）、<strong>拥塞控制</strong>（避免网络过载）实现数据不丢、不重、有序。</li><li>字节流：数据无天然边界，需应用层自行处理粘包 &#x2F; 半包问题。</li></ul></li><li>典型协议：HTTP、FTP、SMTP、SSH。</li></ul><h3 id="2-UDP：无连接的高效传输"><a href="#2-UDP：无连接的高效传输" class="headerlink" title="2. UDP：无连接的高效传输"></a>2. UDP：无连接的高效传输</h3><ul><li>核心特性：<ul><li>无连接：无需建连 &#x2F; 断连，直接发送数据，开销极低。</li><li>不可靠：不保证数据到达、有序，无重传机制（丢包需应用层处理）。</li><li>数据报：每个报文是独立单元（有边界），接收方一次接收一个完整报文（无粘包）。</li></ul></li><li>典型协议：RTP（实时音视频）、DNS、DHCP、游戏数据传输。</li></ul><hr><h2 id="三、三次握手与四次挥手"><a href="#三、三次握手与四次挥手" class="headerlink" title="三、三次握手与四次挥手"></a>三、三次握手与四次挥手</h2><h3 id="1-三次握手（建立-TCP-连接）"><a href="#1-三次握手（建立-TCP-连接）" class="headerlink" title="1. 三次握手（建立 TCP 连接）"></a>1. 三次握手（建立 TCP 连接）</h3><ul><li>目的：确认双方 “发送” 和 “接收” 能力正常，协商初始序列号（避免历史报文干扰）。</li><li>流程（客户端→服务器）：<ol><li>第一次握手：客户端发<code>SYN</code>报文（同步请求），携带初始序列号<code>seq = x</code>。</li><li>第二次握手：服务器回<code>SYN+ACK</code>报文（同步 + 确认），携带自身初始序列号<code>seq = y</code>、确认号<code>ack = x + 1</code>（表示已接收客户端<code>x</code>）。</li><li>第三次握手：客户端回<code>ACK</code>报文，确认号<code>ack = y + 1</code>（表示已接收服务器<code>y</code>）。</li></ol></li><li>关键问答：为什么需要三次握手？<ul><li>避免 “过期连接请求” 浪费服务器资源。若客户端旧<code>SYN</code>报文延迟到达，服务器二次握手后，客户端会因识别为无效请求而不发第三次<code>ACK</code>，服务器超时后释放资源（二次握手会导致服务器误建连）。</li></ul></li></ul><h3 id="2-四次挥手（断开-TCP-连接）"><a href="#2-四次挥手（断开-TCP-连接）" class="headerlink" title="2. 四次挥手（断开 TCP 连接）"></a>2. 四次挥手（断开 TCP 连接）</h3><ul><li>目的：TCP 是全双工通信（双方可同时发数据），需分别关闭各自的发送通道。</li><li>流程（客户端先发起关闭）：<ol><li>第一次挥手：客户端发<code>FIN</code>报文（终止请求），<code>seq = u</code>，表示不再发送数据。</li><li>第二次挥手：服务器回<code>ACK</code>报文，<code>ack = u + 1</code>，表示确认关闭请求（此时服务器→客户端通道仍可发数据）。</li><li>第三次挥手：服务器数据发送完毕，发<code>FIN</code>报文，<code>seq = v</code>，表示不再发送数据。</li><li>第四次挥手：客户端回<code>ACK</code>报文，<code>ack = v + 1</code>，表示确认关闭（此时客户端→服务器通道关闭）。</li></ol></li><li>关键问答：为什么需要四次挥手？<ul><li>全双工特性导致：第二次挥手仅确认客户端的关闭请求，服务器可能仍有未发送完的数据，需等数据发完后，再通过第三次挥手关闭自身发送通道，因此需四次交互。</li></ul></li></ul><h3 id="3-TIME-WAIT-状态"><a href="#3-TIME-WAIT-状态" class="headerlink" title="3. TIME_WAIT 状态"></a>3. TIME_WAIT 状态</h3><ul><li>触发场景：客户端发送第四次挥手的<code>ACK</code>后进入该状态。</li><li>停留时间：默认 2MSL（MSL 是报文最大生存时间，通常 1 分钟）。</li><li>核心目的：<ol><li>确保服务器能收到第四次挥手的<code>ACK</code>（若服务器未收到，会重发<code>FIN</code>，客户端可在<code>TIME_WAIT</code>内重传）。</li><li>避免客户端新连接收到旧连接的残留报文（2MSL 足够让网络中旧报文失效）。</li></ol></li></ul><hr><h2 id="四、Socket：网络编程接口"><a href="#四、Socket：网络编程接口" class="headerlink" title="四、Socket：网络编程接口"></a>四、Socket：网络编程接口</h2><h3 id="1-Socket-本质"><a href="#1-Socket-本质" class="headerlink" title="1. Socket 本质"></a>1. Socket 本质</h3><ul><li>操作系统提供的网络通信接口，封装了 TCP&#x2F;UDP 底层协议细节。</li><li>唯一标识：<code>IP地址 + 端口号</code>（如<code>(192.168.1.1, 8080)</code>），对应进程间通信的端点。</li></ul><h3 id="2-TCP-Socket-编程流程（极简示例）"><a href="#2-TCP-Socket-编程流程（极简示例）" class="headerlink" title="2. TCP Socket 编程流程（极简示例）"></a>2. TCP Socket 编程流程（极简示例）</h3><h4 id="服务器端（被动连接）"><a href="#服务器端（被动连接）" class="headerlink" title="服务器端（被动连接）"></a>服务器端（被动连接）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建TCP Socket</span></span><br><span class="line">    <span class="type">int</span> listen_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定IP和端口</span></span><br><span class="line">    sockaddr_in serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;         <span class="comment">// IPv4</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 绑定所有网卡IP</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);       <span class="comment">// 端口转换为网络序</span></span><br><span class="line">    <span class="built_in">bind</span>(listen_fd, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 监听（最大等待连接数10）</span></span><br><span class="line">    <span class="built_in">listen</span>(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待客户端连接（返回与该客户端通信的新Socket）</span></span><br><span class="line">    sockaddr_in client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> conn_fd = <span class="built_in">accept</span>(listen_fd, (sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 收发数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(conn_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);     <span class="comment">// 接收客户端数据</span></span><br><span class="line">    <span class="built_in">send</span>(conn_fd, <span class="string">&quot;Hello Client&quot;</span>, <span class="number">12</span>, <span class="number">0</span>);   <span class="comment">// 发送响应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 关闭Socket</span></span><br><span class="line">    <span class="built_in">close</span>(conn_fd);</span><br><span class="line">    <span class="built_in">close</span>(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端（主动连接）"><a href="#客户端（主动连接）" class="headerlink" title="客户端（主动连接）"></a>客户端（主动连接）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建TCP Socket</span></span><br><span class="line">    <span class="type">int</span> client_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    sockaddr_in serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 服务器IP</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);                  <span class="comment">// 服务器端口</span></span><br><span class="line">    <span class="built_in">connect</span>(client_fd, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 收发数据</span></span><br><span class="line">    <span class="built_in">send</span>(client_fd, <span class="string">&quot;Hello Server&quot;</span>, <span class="number">12</span>, <span class="number">0</span>);           <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);             <span class="comment">// 接收响应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭Socket</span></span><br><span class="line">    <span class="built_in">close</span>(client_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-UDP-Socket-收发示例"><a href="#3-UDP-Socket-收发示例" class="headerlink" title="3. UDP Socket 收发示例"></a>3. UDP Socket 收发示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UDP服务器端（接收数据）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">// SOCK_DGRAM指定UDP</span></span><br><span class="line"></span><br><span class="line">    sockaddr_in serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">    <span class="built_in">bind</span>(sock_fd, (sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    sockaddr_in client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">// 接收数据并获取客户端地址</span></span><br><span class="line">    <span class="built_in">recvfrom</span>(sock_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, (sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">    <span class="comment">// 回复客户端</span></span><br><span class="line">    <span class="built_in">sendto</span>(sock_fd, <span class="string">&quot;Hello UDP Client&quot;</span>, <span class="number">15</span>, <span class="number">0</span>, (sockaddr*)&amp;client_addr, client_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-TCP-粘包解决方案示例（消息头-消息体，最常用）"><a href="#4-TCP-粘包解决方案示例（消息头-消息体，最常用）" class="headerlink" title="4. TCP 粘包解决方案示例（消息头 + 消息体，最常用）"></a>4. TCP 粘包解决方案示例（消息头 + 消息体，最常用）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端：打包消息（4字节长度+消息体）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_msg</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">    len = <span class="built_in">htonl</span>(len); <span class="comment">// 长度转换为网络序</span></span><br><span class="line">    <span class="comment">// 先发送消息长度（4字节）</span></span><br><span class="line">    <span class="built_in">send</span>(sock_fd, &amp;len, <span class="built_in">sizeof</span>(len), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 再发送消息体</span></span><br><span class="line">    <span class="built_in">send</span>(sock_fd, data.<span class="built_in">c_str</span>(), data.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端：解析消息（先读长度，再读对应长度的消息体）</span></span><br><span class="line"><span class="function">std::string <span class="title">recv_msg</span><span class="params">(<span class="type">int</span> sock_fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先接收消息长度（4字节）</span></span><br><span class="line">    <span class="built_in">recv</span>(sock_fd, &amp;len, <span class="built_in">sizeof</span>(len), <span class="number">0</span>);</span><br><span class="line">    len = <span class="built_in">ntohl</span>(len); <span class="comment">// 转换为主机序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再接收消息体</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">recv</span>(sock_fd, buf, len, <span class="number">0</span>);</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">data</span><span class="params">(buf)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 9. 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/posts/895e9db.html"/>
      <url>/posts/895e9db.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>数据竞争：多线程并发读写共享资源（至少一个写操作）的未定义行为</li><li>互斥锁：<code>std::mutex</code>（基础）、<code>lock_guard</code>（RAII 推荐）、<code>unique_lock</code>（灵活，配条件变量）</li><li>条件变量：<code>wait()</code>（阻塞 + 释锁）、<code>notify_one()</code>&#x2F;<code>notify_all()</code>，需配互斥锁 + 谓词（解虚假唤醒）</li><li>原子操作：<code>std::atomic</code>（硬件级原子性，无锁），核心内存序（relaxed&#x2F;acquire&#x2F;release&#x2F;seq_cst）</li><li>读写锁：<code>std::shared_mutex</code>（读共享、写独占），优化读多写少场景</li><li>常见问题：死锁（固定加锁顺序避免）、虚假唤醒（谓词检查解决）、活锁 &#x2F; 饥饿（延迟 &#x2F; 公平锁缓解）</li></ul><hr><h2 id="一、线程同步的目标"><a href="#一、线程同步的目标" class="headerlink" title="一、线程同步的目标"></a>一、线程同步的目标</h2><ol><li>保证数据一致性：避免多线程读写共享资源导致的结果不可预测。</li><li>控制执行顺序：确保线程按业务逻辑要求的顺序执行（如生产者先生产，消费者后消费）。</li></ol><hr><h2 id="二、核心同步机制"><a href="#二、核心同步机制" class="headerlink" title="二、核心同步机制"></a>二、核心同步机制</h2><h3 id="1-互斥锁：独占式临界区访问"><a href="#1-互斥锁：独占式临界区访问" class="headerlink" title="1. 互斥锁：独占式临界区访问"></a>1. 互斥锁：独占式临界区访问</h3><ul><li><strong>核心原理</strong>：通过 “加锁 - 操作 - 解锁”，保证同一时间仅一个线程进入临界区（访问共享资源的代码段）。</li></ul><h4 id="关键锁类型与特性"><a href="#关键锁类型与特性" class="headerlink" title="关键锁类型与特性"></a>关键锁类型与特性</h4><table><thead><tr><th>锁类型</th><th>核心特性</th><th>适用场景</th></tr></thead><tbody><tr><td><code>std::mutex</code></td><td>基础互斥锁，不可递归加锁</td><td>简单独占访问，配合 RAII 锁使用</td></tr><tr><td><code>std::lock_guard</code></td><td>RAII 自动管理（构造加锁、析构解锁）</td><td>无需手动控制锁，避免漏解锁 &#x2F; 异常</td></tr><tr><td><code>std::unique_lock</code></td><td>灵活控制（可延迟加锁、手动解锁）</td><td>配合条件变量，需动态控制锁状态</td></tr><tr><td><code>std::recursive_mutex</code></td><td>允许同一线程重复加锁</td><td>递归函数访问临界区（不推荐，易藏错）</td></tr><tr><td><code>std::timed_mutex</code></td><td>支持超时尝试加锁（<code>try_lock_for</code>）</td><td>避免无限阻塞，需限时获取锁场景</td></tr></tbody></table><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>std::mutex</code>的<code>lock()</code>&#x2F;<code>unlock()</code>必须成对出现，否则引发死锁；优先用<code>lock_guard</code>&#x2F;<code>unique_lock</code>（RAII 安全）。</li><li>不可递归加锁普通<code>std::mutex</code>（同一线程多次<code>lock()</code>会死锁）。</li></ul><h3 id="2-条件变量：线程间等待-通知"><a href="#2-条件变量：线程间等待-通知" class="headerlink" title="2. 条件变量：线程间等待 - 通知"></a>2. 条件变量：线程间等待 - 通知</h3><ul><li><strong>核心原理</strong>：实现线程协作，让线程在条件不满足时阻塞（释放 CPU，避免忙等），条件满足时被唤醒。</li></ul><h4 id="核心接口与规则"><a href="#核心接口与规则" class="headerlink" title="核心接口与规则"></a>核心接口与规则</h4><ul><li><code>wait(lock, predicate)</code>：先释放锁→阻塞等待→被唤醒后重新加锁→检查谓词，为<code>true</code>则继续，否则再次阻塞（解决虚假唤醒）。</li><li><code>notify_one()</code>：唤醒一个等待线程（避免资源浪费，优先使用）。</li><li><code>notify_all()</code>：唤醒所有等待线程（适合多个线程需响应条件变化）。</li></ul><h4 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h4><ul><li>必须与<code>std::unique_lock</code>配合：<code>wait()</code>需手动控制锁的释放与重获取。</li><li>必须用谓词检查条件：避免操作系统虚假唤醒（无<code>notify</code>时的唤醒）。</li><li>依赖互斥锁的原因：保证条件判断和修改的原子性（防止检查期间条件被篡改）。</li></ul><h3 id="3-原子变量：无锁同步"><a href="#3-原子变量：无锁同步" class="headerlink" title="3. 原子变量：无锁同步"></a>3. 原子变量：无锁同步</h3><ul><li><strong>核心原理</strong>：基于硬件级原子操作（如 CPU<code>LOCK</code>指令），保证读写操作不可分割，无需加锁即可避免数据竞争。</li></ul><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>非阻塞：不会导致线程挂起，性能远高于互斥锁（高并发场景优先）。</li><li>支持操作：仅简单操作（<code>++</code>&#x2F;<code>--</code>&#x2F;<code>load</code>&#x2F;<code>store</code>&#x2F;<code>exchange</code>），复杂逻辑仍需锁。</li><li>内存序（面试高频）：<ul><li><code>memory_order_relaxed</code>：仅保证操作原子性，不保证内存可见性 &#x2F; 顺序。</li><li><code>memory_order_acquire</code>&#x2F;<code>release</code>：读（acquire）后可见所有写（release）操作，保证顺序。</li><li><code>memory_order_seq_cst</code>：默认，最强保证（全局顺序一致），性能略低。</li></ul></li></ul><h4 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h4><ul><li><code>std::atomic</code> vs <code>volatile</code>：<ul><li><code>volatile</code>：仅禁止编译器优化（每次从内存读取），不保证原子性（多线程读写仍竞争）。</li><li><code>atomic</code>：保证原子性 + 内存可见性，是线程安全的。</li></ul></li></ul><h3 id="4-读写锁：读多写少优化"><a href="#4-读写锁：读多写少优化" class="headerlink" title="4. 读写锁：读多写少优化"></a>4. 读写锁：读多写少优化</h3><ul><li><strong>核心原理</strong>：区分读 &#x2F; 写操作，允许多线程同时读（共享锁），仅允许单线程写（独占锁）。</li><li>标准库实现：<code>std::shared_mutex</code>（C++17+），配合<code>std::shared_lock</code>（读锁）、<code>std::unique_lock</code>（写锁）。</li><li>适用场景：读操作远多于写操作（如缓存、配置读取），避免读操作互相阻塞。</li></ul><hr><h2 id="三、同步机制对比表"><a href="#三、同步机制对比表" class="headerlink" title="三、同步机制对比表"></a>三、同步机制对比表</h2><table><thead><tr><th>机制</th><th>核心原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>互斥锁</td><td>独占临界区</td><td>适用所有场景，实现简单</td><td>阻塞，高并发性能损耗大</td><td>复杂临界区（多步操作）</td></tr><tr><td>条件变量</td><td>等待 - 通知机制</td><td>解决执行顺序，避免忙等</td><td>需配互斥锁，逻辑复杂</td><td>生产者 - 消费者、线程协作</td></tr><tr><td>原子变量</td><td>硬件级原子操作</td><td>非阻塞，性能极高</td><td>仅支持简单操作</td><td>计数器、标记位、简单共享数据</td></tr><tr><td>读写锁</td><td>读共享、写独占</td><td>优化读多写少场景性能</td><td>写操作可能饥饿，实现复杂</td><td>缓存、配置等读多写少场景</td></tr></tbody></table><hr><h2 id="四、同步常见问题与解决方案"><a href="#四、同步常见问题与解决方案" class="headerlink" title="四、同步常见问题与解决方案"></a>四、同步常见问题与解决方案</h2><h3 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h3><ul><li>定义：多个线程互相等待对方释放锁，导致永久阻塞。</li><li>避免方案：<ol><li>固定加锁顺序：所有线程按相同顺序加锁（如先<code>mtx1</code>后<code>mtx2</code>）。</li><li>批量加锁：用<code>std::lock(mtx1, mtx2)</code>一次性加锁所有需要的锁。</li><li>限时等待：用<code>try_lock_for</code>&#x2F;<code>try_lock_until</code>，超时则释放已持锁。</li><li>减少锁粒度：缩小临界区范围，缩短持有锁的时间。</li></ol></li></ul><h3 id="2-活锁"><a href="#2-活锁" class="headerlink" title="2. 活锁"></a>2. 活锁</h3><ul><li>定义：线程不断释放 &#x2F; 重试获取锁，因相互冲突始终无法推进（看似活跃实则无进展）。</li><li>解决方案：重试前随机延迟（降低冲突概率），或引入优先级机制。</li></ul><h3 id="3-饥饿"><a href="#3-饥饿" class="headerlink" title="3. 饥饿"></a>3. 饥饿</h3><ul><li>定义：部分线程长期无法获取资源（如低优先级线程被高优先级线程抢占）。</li><li>避免方案：使用公平锁（按请求顺序分配锁），限制高优先级线程执行时长。</li></ul><hr><h2 id="五、问答"><a href="#五、问答" class="headerlink" title="五、问答"></a>五、问答</h2><h3 id="1-条件变量为什么必须配合互斥锁使用？"><a href="#1-条件变量为什么必须配合互斥锁使用？" class="headerlink" title="1. 条件变量为什么必须配合互斥锁使用？"></a>1. 条件变量为什么必须配合互斥锁使用？</h3><ol><li>检查条件时加锁，防止检查期间条件被其他线程修改（保证条件判断原子性）。</li><li><code>wait()</code>阻塞前释放锁，允许其他线程修改条件（避免线程间互相阻塞）。</li><li>唤醒后重新加锁，确保后续操作基于最新的条件状态（保证数据一致性）。</li></ol><h3 id="2-如何解决条件变量的虚假唤醒？"><a href="#2-如何解决条件变量的虚假唤醒？" class="headerlink" title="2. 如何解决条件变量的虚假唤醒？"></a>2. 如何解决条件变量的虚假唤醒？</h3><p>在<code>wait()</code>的第二个参数传入条件谓词（如<code>wait(lock, []{ return flag; })</code>），唤醒后再次检查条件，只有条件为<code>true</code>才继续执行，否则重新阻塞。</p><h3 id="3-std-atomic和volatile的核心区别？"><a href="#3-std-atomic和volatile的核心区别？" class="headerlink" title="3. std::atomic和volatile的核心区别？"></a>3. <code>std::atomic</code>和<code>volatile</code>的核心区别？</h3><p><code>volatile</code>仅禁止编译器优化，保证变量每次从内存读取，但不保证原子性（多线程读写仍会竞争）；<code>std::atomic</code>既保证原子性（操作不可分割），又保证内存可见性（一个线程的修改对其他线程立即可见），是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 8. 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 线程 </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用和移动语义</title>
      <link href="/posts/4d855a6b.html"/>
      <url>/posts/4d855a6b.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>左值 vs 右值：左值有持久地址（可 &amp; 取址），右值是临时对象 &#x2F; 字面量（不可 &amp; 取址）</li><li>右值引用（T&amp;&amp;）：绑定右值，延长其生命周期，支持修改绑定对象</li><li>移动语义：通过移动构造 &#x2F; 赋值转移资源（而非拷贝），提升性能（避免深拷贝）</li><li>std::move：将左值转为右值引用（仅转换，不移动资源），原对象不应再使用</li><li>完美转发：std::forward 保持参数左值 &#x2F; 右值属性，用于模板传递参数</li></ul><hr><h2 id="一、左值与右值：值的核心分类"><a href="#一、左值与右值：值的核心分类" class="headerlink" title="一、左值与右值：值的核心分类"></a>一、左值与右值：值的核心分类</h2><p>核心区别：是否有持久内存地址、能否被取址。</p><h3 id="1-左值"><a href="#1-左值" class="headerlink" title="1. 左值"></a>1. 左值</h3><ul><li>定义：可放在赋值左侧，有持久内存地址，生命周期较长（如变量、函数返回的左值引用）。</li><li>特征：可被<code>&amp;</code>取址（<code>&amp;a</code>合法），可被赋值（<code>a = 5</code>合法）。</li><li>示例：<code>int x = 10;</code>（x 是左值）、<code>int&amp; func()</code>（返回左值引用，是左值）。</li></ul><h3 id="2-右值"><a href="#2-右值" class="headerlink" title="2. 右值"></a>2. 右值</h3><ul><li>定义：只能放在赋值右侧，无持久内存地址（或地址无意义），生命周期短暂。</li><li>分类：<ul><li>纯右值：字面量（<code>5</code>、<code>&quot;hello&quot;</code>）、表达式结果（<code>x + y</code>）、临时对象（<code>func()</code>返回非引用时）。</li><li>将亡值：即将被销毁的对象（如返回局部对象的函数返回值）。</li></ul></li><li>特征：不可被<code>&amp;</code>取址（<code>&amp;5</code>编译报错），通常是临时结果。</li></ul><hr><h2 id="二、右值引用（T-）：绑定右值的引用类型"><a href="#二、右值引用（T-）：绑定右值的引用类型" class="headerlink" title="二、右值引用（T&amp;&amp;）：绑定右值的引用类型"></a>二、右值引用（T&amp;&amp;）：绑定右值的引用类型</h2><p>专门用于绑定右值，是移动语义和完美转发的基础。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>绑定对象</strong>：仅能绑定右值（纯右值或将亡值），不能直接绑定左值（需通过<code>std::move</code>转换）。</li><li><strong>生命周期延长</strong>：绑定临时对象后，临时对象生命周期延长至与右值引用相同（避免被立即销毁）。</li><li><strong>可修改性</strong>：与<code>const T&amp;</code>（常量左值引用，只读）不同，<code>T&amp;&amp;</code>可修改绑定的右值（因右值即将销毁，修改无副作用）。</li></ul><h3 id="三种引用对比"><a href="#三种引用对比" class="headerlink" title="三种引用对比"></a>三种引用对比</h3><table><thead><tr><th>引用类型</th><th>语法</th><th>可绑定对象</th><th>能否修改绑定值</th><th>典型用途</th></tr></thead><tbody><tr><td>左值引用</td><td><code>T&amp;</code></td><td>左值</td><td>能（非 const）</td><td>传递参数、返回引用</td></tr><tr><td>常量左值引用</td><td><code>const T&amp;</code></td><td>左值、右值</td><td>不能</td><td>接收任意值（避免拷贝）</td></tr><tr><td>右值引用</td><td><code>T&amp;&amp;</code></td><td>右值（纯右值、将亡值）</td><td>能</td><td>实现移动语义、完美转发</td></tr></tbody></table><hr><h2 id="三、移动语义：避免冗余拷贝"><a href="#三、移动语义：避免冗余拷贝" class="headerlink" title="三、移动语义：避免冗余拷贝"></a>三、移动语义：避免冗余拷贝</h2><p>核心是 “转移资源所有权” 而非复制资源，解决深拷贝的性能问题。</p><h3 id="1-移动构造函数与移动赋值运算符"><a href="#1-移动构造函数与移动赋值运算符" class="headerlink" title="1. 移动构造函数与移动赋值运算符"></a>1. 移动构造函数与移动赋值运算符</h3><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><ul><li><p>语法：<code>T(T&amp;&amp; other) noexcept;</code></p></li><li><p>作用：接管<code>other</code>的动态资源（如指针指向的内存），将<code>other</code>置为 “可安全销毁” 状态（如指针置空）。</p></li><li><p>示例核心逻辑：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">str</span>(other.str) &#123;</span><br><span class="line">    other.str = <span class="literal">nullptr</span>; <span class="comment">// 掏空原对象，避免析构时重复释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><ul><li>语法：<code>T&amp; operator=(T&amp;&amp; other) noexcept;</code></li><li>作用：先释放当前对象资源，再接管<code>other</code>的资源，最后将<code>other</code>置空。</li></ul><h3 id="2-核心优势"><a href="#2-核心优势" class="headerlink" title="2. 核心优势"></a>2. 核心优势</h3><ul><li>性能优化：将深拷贝（内存分配 + 数据复制）简化为指针赋值，大幅提升效率。</li><li>资源安全：针对将亡值（如临时对象），转移资源不影响其他对象。</li><li>支持不可拷贝对象的转移：某些资源（如文件句柄）不可拷贝，但可通过移动转移所有权。</li></ul><hr><h2 id="四、std-move：左值转右值引用（非实际移动）"><a href="#四、std-move：左值转右值引用（非实际移动）" class="headerlink" title="四、std::move：左值转右值引用（非实际移动）"></a>四、std::move：左值转右值引用（非实际移动）</h2><ul><li><strong>作用</strong>：强制将左值转换为右值引用（仅修改值的属性，不实际移动资源）。</li><li><strong>关键特性</strong>：<ul><li>转换后原对象仍 “有效但不应再使用”（资源可能已被转移）。</li><li>可用于任何对象（内置类型、自定义类型），无性能开销。</li></ul></li><li>示例：<code>String s1; String s2 = std::move(s1);</code>（s1 转为右值引用，触发 s2 的移动构造）。</li></ul><hr><h2 id="五、完美转发：保持参数值类别"><a href="#五、完美转发：保持参数值类别" class="headerlink" title="五、完美转发：保持参数值类别"></a>五、完美转发：保持参数值类别</h2><ul><li><p><strong>核心问题</strong>：模板中传递参数时，左值 &#x2F; 右值属性可能丢失（如右值被转为左值引用）。</p></li><li><p><strong>解决方案</strong>：<code>std::forward&lt;T&gt;(t)</code>，根据<code>T</code>的类型保持参数的左值 &#x2F; 右值属性。</p></li><li><p><strong>典型场景</strong>：模板转发参数至内部函数，确保参数类型正确传递：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t)); <span class="comment">// 保持t的左值/右值属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六、补充"><a href="#六、补充" class="headerlink" title="六、补充"></a>六、补充</h2><ul><li><strong>noexcept 的作用</strong>：移动构造 &#x2F; 赋值若加<code>noexcept</code>，标准容器（如<code>vector</code>）扩容时会优先选择移动而非拷贝（避免异常导致数据丢失），否则可能 fallback 到拷贝，失去优化意义。</li><li><strong>移动语义 vs 拷贝语义</strong>：拷贝是 “复制资源，原对象不变”；移动是 “转移资源，原对象失效”。</li><li><strong>右值引用为何能提升性能</strong>：针对临时对象（右值），无需拷贝其资源，直接转移所有权，消除冗余的内存分配和复制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 7. 现代C++特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 右值引用 </tag>
            
            <tag> 移动语义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/posts/bbcf5ff7.html"/>
      <url>/posts/bbcf5ff7.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>语法：<code>[捕获列表](参数) mutable -&gt; 返回类型 { 函数体 }</code>，仅捕获列表和函数体为必填</li><li>捕获列表：控制外部变量访问（值捕获<code>[=]</code>、引用捕获<code>[&amp;]</code>、混合捕获<code>[=, &amp;x]</code>等）</li><li>类型：编译器生成的唯一匿名闭包类型，无捕获可转函数指针，有捕获需<code>std::function</code>包装</li><li>核心优势：匿名、就地定义、灵活访问外部变量，简化算法参数（如<code>sort</code>比较函数）</li></ul><hr><h2 id="一、语法结构"><a href="#一、语法结构" class="headerlink" title="一、语法结构"></a>一、语法结构</h2><p>Lambda 由 5 部分组成，仅捕获列表和函数体不可省略：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture-list](parameter-list) <span class="keyword">mutable</span> <span class="keyword">noexcept</span> -&gt; <span class="keyword">return</span>-type &#123; function-body &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>捕获列表（<code>[]</code>）</strong>：核心，指定外部变量的访问方式（值 &#x2F; 引用）。</li><li><strong>参数列表（<code>()</code>）</strong>：与普通函数一致，无参数时可省略。</li><li><strong><code>mutable</code></strong>：可选，允许修改值捕获的变量（默认值捕获为<code>const</code>）。</li><li><strong><code>noexcept</code></strong>：可选，声明不抛出异常。</li><li><strong>返回类型（<code>-&gt; type</code>）</strong>：可选，编译器可自动推导（函数体<code>return</code>类型唯一时）。</li><li><strong>函数体（<code>{}</code>）</strong>：执行逻辑，可访问捕获的变量和参数。</li></ul><hr><h2 id="二、捕获列表"><a href="#二、捕获列表" class="headerlink" title="二、捕获列表"></a>二、捕获列表</h2><p>控制 Lambda 如何访问外部变量，需遵守明确的规则和禁忌。</p><h3 id="1-基础捕获方式"><a href="#1-基础捕获方式" class="headerlink" title="1. 基础捕获方式"></a>1. 基础捕获方式</h3><h4 id="（1）按值捕获（-var-）"><a href="#（1）按值捕获（-var-）" class="headerlink" title="（1）按值捕获（[var]）"></a>（1）按值捕获（<code>[var]</code>）</h4><ul><li>特性：拷贝外部变量形成副本，修改副本不影响外部；默认副本为<code>const</code>，需修改加<code>mutable</code>。</li><li>关键：捕获时机为 Lambda 创建时，而非调用时。</li></ul><h4 id="（2）按引用捕获（-var-）"><a href="#（2）按引用捕获（-var-）" class="headerlink" title="（2）按引用捕获（[&amp;var]）"></a>（2）按引用捕获（<code>[&amp;var]</code>）</h4><ul><li>特性：捕获变量的引用，修改会影响外部；需确保 Lambda 调用时，变量仍有效（避免悬垂引用）。</li></ul><h4 id="（3）默认捕获（-）"><a href="#（3）默认捕获（-）" class="headerlink" title="（3）默认捕获（[=]&#x2F;[&amp;]）"></a>（3）默认捕获（<code>[=]</code>&#x2F;<code>[&amp;]</code>）</h4><ul><li><code>[=]</code>：默认按值捕获所有用到的外部变量（仅捕获实际使用的变量）。</li><li><code>[&amp;]</code>：默认按引用捕获所有用到的外部变量。</li></ul><h4 id="（4）混合捕获（默认-显式）"><a href="#（4）混合捕获（默认-显式）" class="headerlink" title="（4）混合捕获（默认 + 显式）"></a>（4）混合捕获（默认 + 显式）</h4><ul><li>规则：显式捕获需与默认捕获方式相反（避免冲突）。<ul><li>合法：<code>[=, &amp;x]</code>（默认值捕获，仅<code>x</code>引用捕获）、<code>[&amp;, y]</code>（默认引用捕获，仅<code>y</code>值捕获）。</li><li>非法：<code>[=, x]</code>（重复值捕获）、<code>[&amp;, &amp;y]</code>（重复引用捕获）。</li></ul></li></ul><h3 id="2-捕获禁忌"><a href="#2-捕获禁忌" class="headerlink" title="2. 捕获禁忌"></a>2. 捕获禁忌</h3><ul><li>不能捕获局部变量的地址或引用（除通过捕获列表显式引用捕获）。</li><li>函数参数不能被捕获（需通过参数列表传递）。</li><li>全局 &#x2F; 静态变量无需捕获，可直接访问。</li></ul><hr><h2 id="三、类型与存储"><a href="#三、类型与存储" class="headerlink" title="三、类型与存储"></a>三、类型与存储</h2><p>Lambda 的本质是编译器生成的匿名闭包类（重载<code>operator()</code>，即仿函数）。</p><h3 id="1-核心类型特性"><a href="#1-核心类型特性" class="headerlink" title="1. 核心类型特性"></a>1. 核心类型特性</h3><ul><li>每个 Lambda 的类型唯一（即使代码完全相同），无法直接声明，需用<code>auto</code>推导。</li><li>无捕获的 Lambda：可隐式转换为函数指针（如<code>void(*func)() = [](){};</code>）。</li><li>有捕获的 Lambda：不可转函数指针，需用<code>std::function</code>包装（通用函数包装器）。</li></ul><h3 id="2-std-function包装-Lambda"><a href="#2-std-function包装-Lambda" class="headerlink" title="2. std::function包装 Lambda"></a>2. <code>std::function</code>包装 Lambda</h3><ul><li>用途：存储有捕获的 Lambda，解决类型唯一化问题，适用于函数参数、返回值等场景。</li><li>示例：<code>std::function&lt;int(int)&gt; func = [](int x){ return x*2; };</code></li></ul><hr><h2 id="四、问答"><a href="#四、问答" class="headerlink" title="四、问答"></a>四、问答</h2><h3 id="Lambda-与普通函数、仿函数的区别？"><a href="#Lambda-与普通函数、仿函数的区别？" class="headerlink" title="Lambda 与普通函数、仿函数的区别？"></a>Lambda 与普通函数、仿函数的区别？</h3><table><thead><tr><th>对比维度</th><th>普通函数</th><th>仿函数（函数对象）</th><th>Lambda 表达式</th></tr></thead><tbody><tr><td>状态存储</td><td>无状态（不能访问外部变量）</td><td>可通过成员变量存储状态</td><td>可通过捕获列表灵活访问外部变量</td></tr><tr><td>定义方式</td><td>全局 &#x2F; 命名空间可见</td><td>需定义类，代码冗余</td><td>匿名、就地定义，简洁高效</td></tr><tr><td>类型特性</td><td>固定类型（可直接声明）</td><td>自定义类类型</td><td>编译器生成唯一匿名类型</td></tr><tr><td>适用场景</td><td>通用全局逻辑</td><td>需复用的带状态逻辑</td><td>短小、临时的局部逻辑（如算法参数）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 7. 现代C++特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型推导</title>
      <link href="/posts/6d04aba6.html"/>
      <url>/posts/6d04aba6.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>auto：根据初始化表达式推导变量类型，忽略顶层 const 和引用，有明确使用限制（函数参数 &#x2F; 非静态成员 &#x2F; 数组）</li><li>decltype：推导表达式精确类型（不执行表达式），完全保留 const 和引用，无需变量初始化</li><li>模板类型推导：分按值、按引用、万能引用（T&amp;&amp;）三种场景，核心是处理 const 和引用的折叠规则</li><li>核心区别：auto 简化变量声明，decltype 获取精确类型，模板推导适配函数 &#x2F; 模板参数场景</li></ul><hr><h2 id="一、auto：自动推导变量类型"><a href="#一、auto：自动推导变量类型" class="headerlink" title="一、auto：自动推导变量类型"></a>一、auto：自动推导变量类型</h2><p>核心用途是简化长类型声明，推导规则聚焦 “忽略顶层修饰，保留底层约束”。</p><h3 id="1-核心推导规则"><a href="#1-核心推导规则" class="headerlink" title="1. 核心推导规则"></a>1. 核心推导规则</h3><ul><li>必须初始化：编译器依赖初始化表达式推导类型，未初始化编译报错。</li><li>顶层 const &#x2F; 引用忽略：变量本身的 const 和引用会被舍弃，底层 const（指向常量的约束）保留。<ul><li>顶层 const 示例：<code>const int x=10; auto a=x;</code>（a 推导为 int，顶层 const 忽略）</li><li>引用示例：<code>int&amp; ref=y; auto c=ref;</code>（c 推导为 int，引用忽略）</li><li>底层 const 示例：<code>const int* p=&amp;x; auto e=p;</code>（e 推导为 <code>const int*</code>，底层 <code>const</code> 保留）</li></ul></li><li>需保留引用 &#x2F;const：显式添加<code>&amp;</code>或<code>const</code>，如<code>auto&amp; b=x;</code>（b 推导为 <code>const int&amp;</code>）、<code>const auto f=x;</code>（f 推导为 <code>const int</code>）。</li></ul><h3 id="2-面试高频限制"><a href="#2-面试高频限制" class="headerlink" title="2. 面试高频限制"></a>2. 面试高频限制</h3><ul><li>不能用于函数参数：<code>void func(auto x)</code>（编译报错，无法推导未初始化参数）。</li><li>不能用于非静态成员变量：类成员初始化时机与 auto 推导冲突。</li><li>不能推导数组类型：<code>int arr[5]; auto p=arr;</code>（p 推导为 <code>int*</code>，而非 <code>int [5]</code>）。</li></ul><hr><h2 id="二、decltype：推导表达式精确类型"><a href="#二、decltype：推导表达式精确类型" class="headerlink" title="二、decltype：推导表达式精确类型"></a>二、decltype：推导表达式精确类型</h2><p>核心优势是 “保留原始类型”，无需执行表达式，适配需精确类型的场景（如模板返回值）。</p><h3 id="1-核心推导规则-1"><a href="#1-核心推导规则-1" class="headerlink" title="1. 核心推导规则"></a>1. 核心推导规则</h3><ul><li>推导变量名：结果为变量的<strong>声明类型</strong>（完全保留 const 和引用）。<ul><li>示例：<code>const int&amp; ref=x; decltype(ref) r=ref;</code>（r 推导为 const int&amp;）。</li></ul></li><li>推导表达式：结果为表达式的<strong>返回类型</strong>（根据值类别判断，不执行表达式）。<ul><li>示例：<code>decltype(x+y)</code>（x+y 是 <code>int</code> 类型，推导为 <code>int</code>）；<code>decltype(*p)</code>（<code>*p</code> 是左值，推导为 <code>int&amp;</code>）。</li></ul></li><li>推导函数调用：结果为函数<strong>返回类型</strong>（不执行函数）。<ul><li>示例：<code>decltype(func(3))</code>（推导为 func 的返回类型，无论 func 是否执行）。</li></ul></li></ul><hr><h2 id="三、auto-与-decltype-核心区别"><a href="#三、auto-与-decltype-核心区别" class="headerlink" title="三、auto 与 decltype 核心区别"></a>三、auto 与 decltype 核心区别</h2><table><thead><tr><th>对比维度</th><th>auto</th><th>decltype</th></tr></thead><tbody><tr><td>推导依据</td><td>变量初始化表达式的类型</td><td>任意表达式的类型（不执行表达式）</td></tr><tr><td>const &#x2F; 引用处理</td><td>忽略顶层 const 和引用，保留底层 const</td><td>完全保留表达式的 const 和引用属性</td></tr><tr><td>初始化要求</td><td>必须初始化（否则无法推导）</td><td>无需初始化（推导表达式类型）</td></tr><tr><td>核心用途</td><td>简化变量声明（如迭代器、复杂模板类型）</td><td>获取精确类型（如模板返回值、表达式类型）</td></tr></tbody></table><hr><h2 id="四、模板类型推导"><a href="#四、模板类型推导" class="headerlink" title="四、模板类型推导"></a>四、模板类型推导</h2><p>模板参数 T 的推导规则与 auto 类似，但需区分 “传递方式”，核心分三类场景。</p><h3 id="1-按值传递（模板参数为-T）"><a href="#1-按值传递（模板参数为-T）" class="headerlink" title="1. 按值传递（模板参数为 T）"></a>1. 按值传递（模板参数为 T）</h3><ul><li>推导规则：忽略实参的顶层 const 和引用，底层 const 保留。<ul><li>示例：<code>template&lt;typename T&gt; void func(T x);</code><ul><li><code>const int a=10; func(a);</code>（T 推导为 int，顶层 const 忽略）</li><li><code>int&amp; b=20; func(b);</code>（T 推导为 int，引用忽略）</li><li><code>const int* c=&amp;a; func(c);</code>（T 推导为 <code>const int*</code>，底层 <code>const</code> 保留）</li></ul></li></ul></li></ul><h3 id="2-按引用传递（模板参数为-T-）"><a href="#2-按引用传递（模板参数为-T-）" class="headerlink" title="2. 按引用传递（模板参数为 T&amp;）"></a>2. 按引用传递（模板参数为 T&amp;）</h3><ul><li>推导规则：保留实参的 const 和引用，T 推导为 “实参去掉引用后的类型”。<ul><li>示例：<code>template&lt;typename T&gt; void func(T&amp; x);</code><ul><li><code>int a=10; func(a);</code>（T 推导为 int，x 类型为 int&amp;）</li><li><code>const int b=20; func(b);</code>（T 推导为 <code>const int</code>，x 类型为 <code>const int&amp;</code>）</li><li>禁止传递字面量：<code>func(5);</code>（编译报错，非 <code>const</code> 引用无法绑定字面量）</li></ul></li></ul></li></ul><h3 id="3-万能引用（模板参数为-T-）"><a href="#3-万能引用（模板参数为-T-）" class="headerlink" title="3. 万能引用（模板参数为 T&amp;&amp;）"></a>3. 万能引用（模板参数为 T&amp;&amp;）</h3><ul><li>核心场景：同时适配左值和右值实参，依赖 “引用折叠” 规则推导。</li><li>引用折叠规则（面试高频）：<ul><li>左值引用 + 左值引用→左值引用（<code>T&amp; + &amp; → T&amp;</code>）</li><li>左值引用 + 右值引用→左值引用（<code>T&amp; + &amp;&amp; → T&amp;</code>）</li><li>右值引用 + 右值引用→右值引用（<code>T&amp;&amp; + &amp;&amp; → T&amp;&amp;</code>）</li></ul></li><li>推导示例：<code>template&lt;typename T&gt; void func(T&amp;&amp; x);</code><ul><li>传递左值：<code>int a=10; func(a);</code>（T 推导为 <code>int&amp;</code>，x 类型为 <code>int&amp;</code>）</li><li>传递右值：<code>func(20);</code>（T 推导为 <code>int</code>，x 类型为 <code>int&amp;&amp;</code>）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 7. 现代C++特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> 类型推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程基础</title>
      <link href="/posts/b9f6280b.html"/>
      <url>/posts/b9f6280b.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>线程 vs 进程：进程是资源分配单位（独立内存），线程是调度单位（共享进程内存），线程通信成本更低</li><li>线程创建：<code>std::thread</code>支持函数、Lambda、函数对象三种方式</li><li>线程管理：<code>join()</code>等待回收、<code>detach()</code>分离（慎用）、<code>joinable()</code>检查状态</li><li>线程标识：<code>std::this_thread::get_id()</code>获取 ID，<code>std::thread::id</code>判断唯一性</li><li>线程状态：就绪、运行、阻塞、终止</li></ul><hr><h2 id="一、线程的基本概念"><a href="#一、线程的基本概念" class="headerlink" title="一、线程的基本概念"></a>一、线程的基本概念</h2><h3 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h3><ul><li>进程：程序的一次执行实例，拥有独立内存空间（代码、数据、堆栈），是资源分配的最小单位。</li><li>线程：进程内的执行单元，共享进程的代码、全局数据等资源，拥有独立的栈和寄存器，是调度的最小单位。</li><li>核心区别：<ul><li>资源隔离：进程间地址空间独立，线程间共享进程内存。</li><li>通信成本：进程间通信（IPC）需跨地址空间（成本高），线程间直接共享数据（成本低）。</li><li>轻量化：线程比进程更轻量，创建、切换、销毁开销更小。</li></ul></li></ul><h3 id="2-线程的优势"><a href="#2-线程的优势" class="headerlink" title="2. 线程的优势"></a>2. 线程的优势</h3><ul><li>并发执行多个任务，提升程序响应速度。</li><li>充分利用多核 CPU 资源，提高 CPU 利用率。</li><li>比进程更轻量，资源消耗少、调度效率高。</li></ul><h3 id="3-用户线程-vs-内核线程"><a href="#3-用户线程-vs-内核线程" class="headerlink" title="3. 用户线程 vs 内核线程"></a>3. 用户线程 vs 内核线程</h3><ul><li>用户线程：用户空间管理，不依赖内核，创建销毁快，但内核无法感知，调度需用户实现。</li><li>内核线程：内核空间管理，内核直接调度，支持真正并行，但创建销毁开销比用户线程高。</li><li>常见映射：1:1（内核线程对应用户线程）、M:N（多个用户线程映射到多个内核线程）。</li></ul><hr><h2 id="二、线程创建（std-thread）"><a href="#二、线程创建（std-thread）" class="headerlink" title="二、线程创建（std::thread）"></a>二、线程创建（std::thread）</h2><p>C++11 <code>std::thread</code>标准化线程操作，跨平台兼容，无需依赖平台 API。</p><h3 id="核心创建方式"><a href="#核心创建方式" class="headerlink" title="核心创建方式"></a>核心创建方式</h3><ol><li>函数 &#x2F; 函数指针：传递函数地址及参数。</li><li>Lambda 表达式：简洁高效，推荐用于短小逻辑。</li><li>类成员函数：传递成员函数指针、对象指针及参数。</li></ol><h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h3><ul><li>线程创建后需立即管理（<code>join()</code>或<code>detach()</code>），否则析构时抛出<code>std::terminate</code>异常。</li><li>传递参数时，默认按值拷贝，需传递引用时用<code>std::ref</code>&#x2F;<code>std::cref</code>（避免拷贝开销或悬垂引用）。</li></ul><hr><h2 id="三、线程生命周期与管理"><a href="#三、线程生命周期与管理" class="headerlink" title="三、线程生命周期与管理"></a>三、线程生命周期与管理</h2><h3 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1. 线程状态"></a>1. 线程状态</h3><ul><li>就绪：已创建，等待 CPU 调度（具备运行条件）。</li><li>运行：占用 CPU，执行线程逻辑。</li><li>阻塞：因等待资源（如锁、IO）暂停执行，释放 CPU。</li><li>终止：线程执行完毕或被强制终止，资源等待回收。</li></ul><h3 id="2-线程管理函数"><a href="#2-线程管理函数" class="headerlink" title="2. 线程管理函数"></a>2. 线程管理函数</h3><h4 id="（1）join"><a href="#（1）join" class="headerlink" title="（1）join()"></a>（1）<code>join()</code></h4><ul><li>功能：主线程阻塞，等待子线程执行完毕后再继续，回收子线程资源（避免 “僵尸线程”）。</li><li>限制：一个线程只能调用一次<code>join()</code>，调用后<code>joinable()</code>返回<code>false</code>。</li></ul><h4 id="（2）detach"><a href="#（2）detach" class="headerlink" title="（2）detach()"></a>（2）<code>detach()</code></h4><ul><li>功能：主线程与子线程分离，子线程后台运行，主线程不等待。</li><li>风险：子线程依赖的主线程资源（如局部变量）可能提前释放，导致悬垂引用（崩溃风险）。</li><li>适用场景：子线程逻辑独立，不依赖主线程局部资源，且无需主线程等待。</li></ul><h4 id="（3）joinable"><a href="#（3）joinable" class="headerlink" title="（3）joinable()"></a>（3）<code>joinable()</code></h4><ul><li>功能：检查线程是否可<code>join</code>（未调用<code>join()</code>&#x2F;<code>detach()</code>，且线程未终止）。</li><li>用途：避免重复<code>join</code>或<code>detach</code>导致的未定义行为（如<code>join()</code>已调用的线程）。</li></ul><hr><h2 id="四、线程标识"><a href="#四、线程标识" class="headerlink" title="四、线程标识"></a>四、线程标识</h2><ul><li>线程 ID：<code>std::thread::id</code>类型，每个线程有唯一标识（可通过<code>==</code>&#x2F;<code>!=</code>判断唯一性）。</li><li>获取方式：<ul><li>子线程 ID：<code>std::thread t(func); t.get_id();</code></li><li>当前线程 ID：<code>std::this_thread::get_id();</code></li></ul></li><li>特殊 ID：默认构造的<code>std::thread::id</code>表示 “无关联线程”（可判断线程是否有效）。</li></ul><hr><h2 id="五、易错点"><a href="#五、易错点" class="headerlink" title="五、易错点"></a>五、易错点</h2><ol><li>未管理<code>std::thread</code>：创建后未调用<code>join()</code>&#x2F;<code>detach()</code>，析构时抛异常。</li><li><code>detach()</code>后访问主线程局部资源：子线程可能在主线程局部变量销毁后执行，导致悬垂引用。</li><li>重复<code>join()</code>：对已<code>join</code>的线程再次调用<code>join()</code>，引发未定义行为（需用<code>joinable()</code>检查）。</li><li>线程参数按值传递：需传递引用时未用<code>std::ref</code>，导致拷贝开销或修改无效。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 8. 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象</title>
      <link href="/posts/3a517f26.html"/>
      <url>/posts/3a517f26.html</url>
      
        <content type="html"><![CDATA[<h2 id="核心要点速览"><a href="#核心要点速览" class="headerlink" title="核心要点速览"></a>核心要点速览</h2><ul><li>访问控制：public（接口）、private（实现）、protected（继承）</li><li>const 成员：const 成员变量需初始化列表初始化；const 成员函数不可修改成员变量</li><li>static 成员：静态成员变量类共享、类外初始化；静态成员函数无 this 指针、仅访问静态成员</li><li>构造函数：可重载、非虚函数；含默认 &#x2F; 带参 &#x2F; 拷贝 &#x2F; 移动构造</li><li>析构函数：不可重载；基类需设为虚函数避免资源泄漏</li><li>类大小：仅取决于非静态数据成员，遵循内存对齐</li></ul><hr><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li>类：抽象的数据类型模板，定义对象的属性（数据成员）和行为（成员函数）。</li><li>对象：类的具体实例，占用实际内存，拥有类定义的属性和行为。</li></ul><hr><h2 id="二、核心特性：封装"><a href="#二、核心特性：封装" class="headerlink" title="二、核心特性：封装"></a>二、核心特性：封装</h2><p>核心是 “隐藏实现细节，暴露公共接口”，通过访问控制符实现。</p><table><thead><tr><th>访问控制符</th><th>可访问范围</th><th>作用</th></tr></thead><tbody><tr><td><code>public</code></td><td>类内、类外、派生类</td><td>暴露接口，供外部调用</td></tr><tr><td><code>private</code></td><td>仅类内和友元</td><td>隐藏数据成员和内部实现</td></tr><tr><td><code>protected</code></td><td>类内、友元、派生类（类外不可访问）</td><td>为继承预留访问权限</td></tr></tbody></table><ul><li>封装意义：保障数据安全、提升代码维护性、降低使用复杂度。</li></ul><hr><h2 id="三、构造函数：对象的初始化"><a href="#三、构造函数：对象的初始化" class="headerlink" title="三、构造函数：对象的初始化"></a>三、构造函数：对象的初始化</h2><ul><li>核心特点：函数名与类名相同，无返回值，对象创建时自动调用，可重载，不能为虚函数。</li></ul><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><h4 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1. 默认构造函数"></a>1. 默认构造函数</h4><ul><li>定义：无参数，或所有参数都有默认值。</li><li>编译器行为：未定义任何构造函数时自动生成；定义其他构造函数后需手动定义。</li></ul><h4 id="2-带参构造函数"><a href="#2-带参构造函数" class="headerlink" title="2. 带参构造函数"></a>2. 带参构造函数</h4><ul><li>用途：通过参数灵活初始化对象。</li></ul><h4 id="3-拷贝构造函数"><a href="#3-拷贝构造函数" class="headerlink" title="3. 拷贝构造函数"></a>3. 拷贝构造函数</h4><ul><li>定义：参数必须为 “同类对象的 const 引用”（避免无限递归）。</li><li>调用时机：对象初始化、函数按值传参、函数返回值为对象（非引用）。</li><li>浅拷贝 vs 深拷贝：<ul><li><p>浅拷贝：仅复制表层数据，指针成员共享内存，可能导致双重释放。</p></li><li><p>深拷贝：为指针成员重新分配内存并复制数据，示例：</p><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] str; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-移动构造函数"><a href="#4-移动构造函数" class="headerlink" title="4. 移动构造函数"></a>4. 移动构造函数</h4><ul><li><p>核心：接管原对象动态资源，避免拷贝，提升效率。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        str = other.str;</span><br><span class="line">        other.str = <span class="literal">nullptr</span>; <span class="comment">// 掏空原对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">String s2 = std::<span class="built_in">move</span>(s1); <span class="comment">// 接管s1资源</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><ul><li><p>用途：优先初始化成员变量，推荐使用。</p></li><li><p>必须使用的场景：const 成员、引用成员、无默认构造函数的类成员，示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>&amp; b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x, <span class="type">int</span>&amp; y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四、析构函数：对象的清理"><a href="#四、析构函数：对象的清理" class="headerlink" title="四、析构函数：对象的清理"></a>四、析构函数：对象的清理</h2><ul><li><p>核心特点：函数名<code>~类名</code>，无参数、无返回值，不可重载，对象生命周期结束时自动调用。</p></li><li><p>必须手动定义的场景：类包含动态分配资源（如 new 的内存）。</p></li><li><p>虚析构函数（基类必备，避免资源泄漏）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; <span class="keyword">delete</span>[] data; &#125; <span class="comment">// 虚析构</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; <span class="keyword">delete</span>[] derivedData; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五、this-指针"><a href="#五、this-指针" class="headerlink" title="五、this 指针"></a>五、this 指针</h2><ul><li><p>本质：非静态成员函数中隐式传递的指针，指向当前调用对象（类型<code>类名* const</code>）。</p></li><li><p>用途：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123; <span class="keyword">this</span>-&gt;name = name; &#125; <span class="comment">// 区分成员与参数</span></span><br><span class="line"><span class="function">Person&amp; <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; <span class="comment">// 链式调用</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六、静态成员（属于类）"><a href="#六、静态成员（属于类）" class="headerlink" title="六、静态成员（属于类）"></a>六、静态成员（属于类）</h2><h3 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h3><ul><li><p>特点：所有对象共享，存储在全局数据区，类内声明、类外初始化：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Counter::count = <span class="number">0</span>; <span class="comment">// 类外初始化</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2. 静态成员函数"></a>2. 静态成员函数</h3><ul><li><p>特点：无 this 指针，无需创建对象即可调用，仅能访问静态成员：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; count++; &#125; <span class="comment">// 仅访问静态成员</span></span><br><span class="line">Counter::<span class="built_in">increment</span>(); <span class="comment">// 直接调用</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七、类的大小计算"><a href="#七、类的大小计算" class="headerlink" title="七、类的大小计算"></a>七、类的大小计算</h2><ul><li><p>核心规则：仅取决于非静态数据成员，遵循内存对齐，与成员函数、静态成员无关。</p></li><li><p>示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Empty); <span class="comment">// 1字节（占位）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">char</span> c; <span class="type">int</span> i; &#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(A); <span class="comment">// 8字节（1+3填充+4，对齐系数4）</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八、问答"><a href="#八、问答" class="headerlink" title="八、问答"></a>八、问答</h2><ul><li>构造函数和析构函数的调用顺序？<ul><li>构造：先定义先构造；析构：后构造先析构。</li></ul></li><li>拷贝构造函数的参数为什么必须是引用？<ul><li>避免值传递引发的无限递归（形参初始化需再次调用拷贝构造）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 4. 面向对象编程OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共白头</title>
      <link href="/posts/9a70fb8f.html"/>
      <url>/posts/9a70fb8f.html</url>
      
        <content type="html"><![CDATA[<div style="display: flex; flex-wrap: wrap; align-items: center; gap: 30px; margin: 30px 0; padding: 20px; background: #f9f9f9; border-radius: 8px;"> <!-- 左侧图片 --> <div style="flex: 0 0 300px; min-width: 250px;"> <img src="\img\post\v2-0c5fb6dee232d596a4e6ee7ed35c2ba7_1440w.jpg" alt="" style="width: 100%; height: auto; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"> </div> <!-- 右侧文字 --> <div style="flex: 1; min-width: 300px;"> <h3 style="margin-top: 0; color: #333; font-size: 20px;">共白头</h3> <p style="line-height: 1.8; color: #555; font-size: 16px; margin: 10px 0;"> 忽有故人心上过，回首山河已入冬。<br><br> 他朝若是同淋雪，此生也算共白头。<br><br> 白头若是雪可替，世间何来伤心人。<br><br> 此时若有君在侧，何须淋雪作白头。 </p> </div> </div>]]></content>
      
      
      <categories>
          
          <category> 诗词 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/comments/index.html"/>
      <url>/comments/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
